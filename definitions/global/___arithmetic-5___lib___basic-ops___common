((/arithmetic-5/lib/basic-ops/common.lisp::collect-+ (nil nil nil (+) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::collect-* (nil nil nil (*) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::bubble-down (nil nil (declare) nil nil nil nil) (nil nil (ignore) nil nil nil nil) ((match) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::addend-pattern (nil nil nil nil nil nil (cond)) (nil nil ((variablep addend) (fquotep addend) (eq (ffn-symb addend) (quote UNARY--)) (and (eq (ffn-symb addend) (quote BINARY-*)) (rational-constant-p (arg1 addend))) t) nil nil nil nil) ((addend addend addend) nil (arg1 arg2) nil nil nil nil) ((addend addend) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-addend-patterns-p (nil nil nil (cond) nil nil nil) (nil nil ((quotep pattern-1) t) nil nil nil nil) ((nil) nil nil (equal) nil nil nil) ((pattern-1 pattern-2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-addend-p (nil nil nil (let) nil nil nil) (((addend-pattern (addend-pattern addend))) nil nil (matching-addend-patterns-p) nil nil nil) ((pattern addend-pattern) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-pattern-base (nil nil nil nil (cond) nil nil) (nil nil ((variablep x) (and (fquotep x) (consp (cdr x))) t) nil nil nil nil) ((x x) nil nil nil (if) nil nil) (nil (2) (unquote) nil (and) nil nil) ((x) nil (power-of-2 not not) nil nil nil nil) ((x) nil nil (equal equal) nil nil nil) ((x x) nil (quote quote) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-exponents (nil nil nil (equal) nil nil nil) (nil nil (addend-pattern addend-pattern) nil nil nil nil) ((exp-1 exp-2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-pattern-gather-exponents (nil nil nil nil nil nil (cond)) (nil nil ((variablep factor) (and (fquotep factor) (consp (cdr factor))) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) ((factor factor) nil (recursive-call) (let) (cond) nil nil) (nil nil ((and (power-of-2-generalized factor) (not (equal factor (quote (quote 1)))) (not (equal factor (quote (quote -1))))) (rational-constant-p factor) t arg1 (base (factor-pattern-base (arg1 factor)))) nil (if) nil nil) ((factor base) (2) (abs unquote exponent acl2-numberp `) nil nil nil nil) ((factor base) nil (unquote arg2) (EXPT-WITH-CONST-BASE) nil nil nil) ((factor factor) nil (, ,) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-factor-gather-exponents-patterns-p (nil nil nil nil (cond) nil nil) (nil nil ((acl2-numberp pattern-1) (eq (fn-symb pattern-1) (quote EXPT-WITH-CONST-BASE)) t) nil nil nil nil) (nil nil nil (equal) (and) (cond) nil) ((pattern-1 pattern-2) nil (not (equal (arg1 pattern-1) 0) (equal (arg1 pattern-1) pattern-2) (eq (fn-symb pattern-2) (quote EXPT-WITH-CONST-BASE)) t) (eq equal) nil nil nil) ((pattern-1 nil t nil) nil (fn-symb quote arg1) (equal or) nil nil nil) ((pattern-1 pattern-2 EXPT-WITH-CONST-BASE pattern-2) (0) nil (equal equal) nil nil nil) (nil nil (arg1 arg1 arg2 arg2) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-factor-gather-exponents-p (nil nil nil (let) nil nil nil) (((factor-pattern (factor-pattern-gather-exponents factor))) nil nil (matching-factor-gather-exponents-patterns-p) nil nil nil) ((pattern factor-pattern) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-pattern-scatter-exponents (nil nil nil nil nil nil (cond)) (nil nil ((variablep factor) (fquotep factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) ((factor factor) (0) (recursive-call) (let) nil nil nil) (nil nil (arg1 (base (factor-pattern-base (arg1 factor)))) nil (cond) nil nil) ((factor) nil (exponent (acl2-numberp base) (quotep exponent) t) nil nil nil nil) ((base) nil (arg2 ` `) nil nil nil nil) ((factor) nil nil (EXPT-WITH-CONST-BASE EXPT) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-factor-scatter-exponents-patterns-p (nil nil nil nil nil (cond) nil) (nil nil ((acl2-numberp pattern-1) (eq (fn-symb pattern-1) (quote EXPT-WITH-CONST-BASE)) (eq (fn-symb pattern-1) (quote EXPT)) t) nil nil nil nil) ((nil) nil nil (equal) (cond cond) nil nil) ((pattern-1 pattern-2) nil ((equal (arg1 pattern-1) 0) (eq (fn-symb pattern-2) (quote EXPT-WITH-CONST-BASE)) t (equal (arg1 pattern-1) 0) (eq (fn-symb pattern-2) (quote EXPT)) t) nil nil nil nil) ((nil nil nil nil) nil nil (matching-exponents and) nil nil nil) (nil nil (arg2 arg2) (equal matching-exponents) nil nil nil) ((pattern-1 pattern-2) nil (arg1 arg1 arg2 arg2) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::matching-factor-scatter-exponents-p (nil nil nil (let) nil nil nil) (((factor-pattern (factor-pattern-scatter-exponents factor))) nil nil (matching-factor-scatter-exponents-patterns-p) nil nil nil) ((pattern factor-pattern) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::good-val-triple-p (nil nil nil nil nil nil nil) (nil nil (consp real/rationalp consp real/rationalp consp real/rationalp) nil nil nil nil) ((x) nil (car cdr cadr cddr caddr) nil nil nil nil) ((x x x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::val-< (nil nil nil nil nil nil nil) (nil nil ((< (car x) (car y)) (< (car y) (car x)) (< (cadr x) (cadr y)) (< (cadr y) (cadr x)) (< (caddr x) (caddr y)) t) nil nil nil nil) ((t nil t nil t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::info-entry-p (nil nil nil (and) nil nil nil) (nil nil (true-listp good-val-triple-p) nil nil nil nil) ((x) nil (cadr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::info-list-p (nil nil nil nil (if) nil nil) (nil nil (consp) (and eq) nil nil nil) ((x x nil) nil (info-entry-p recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-val-gather-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (abs) (+) (if) nil nil) (nil (1) (unquote rational-constant-p abs recursive-call recursive-call) nil nil nil nil) ((exponent) nil (arg1 unquote arg1 arg2) nil nil nil nil) ((exponent exponent exponent) nil (arg1) nil nil nil nil) ((exponent) nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-val-gather-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (constant-p factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil nil (recursive-call recursive-call) (let) (list list list) nil nil) (((val (unquote factor))) (0 1 0 0 0 0 1 0) (arg1 arg1 factor-val-gather-exponents1) nil (if) nil nil) ((factor factor) nil (rationalp arg2) nil (list list) nil nil) ((val factor) (0 0 0 0 1) (abs) nil nil nil nil) ((val) nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-val-scatter-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (abs) (+) (if) nil nil) (nil (1) (unquote rational-constant-p abs recursive-call recursive-call) nil nil nil nil) ((exponent) nil (arg1 unquote arg1 arg2) nil nil nil nil) ((exponent exponent exponent) nil (arg1) nil nil nil nil) ((exponent) nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-val-scatter-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (constant-p factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil nil (recursive-call recursive-call) (let) (list list list) nil nil) (((val (unquote factor))) (0 1 0 0 0 0 1 0) (arg1 arg1 factor-val-scatter-exponents1) nil (if) nil nil) ((factor factor) nil (rationalp arg2) nil (list list) nil nil) ((val factor) (0 0 0 0 1) (abs) nil nil nil nil) ((val) nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-gather-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-gather-exponents factor-val-gather-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::assoc-factor-gather-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-gather-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-gather-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (val-< (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-gather-exponents-info-list (nil nil nil nil nil (cond) nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote BINARY-*)) (eq (fn-symb x) (quote UNARY--)) t) nil nil nil nil) (nil nil (recursive-call list) (let cons) nil nil nil) (((temp (factor-gather-exponents-info-list (arg2 x)))) nil (factor-gather-exponents-info-entry recursive-call arg1 factor-gather-exponents-info-entry) nil (if) nil nil) ((temp nil x x) nil (arg1 arg2) (factor-gather-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-factor-gather-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-gather-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-rational-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-real/rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-rational-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-rational-match-in-factor-gather-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-gather-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-non-zero-rational-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-non-zero-real/rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-non-zero-rational-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-non-zero-rational-match-in-factor-gather-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-gather-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-scatter-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-scatter-exponents factor-val-scatter-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::assoc-factor-scatter-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-scatter-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-scatter-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (val-< (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::factor-scatter-exponents-info-list (nil nil nil nil nil (cond) nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote UNARY--)) (eq (fn-symb x) (quote BINARY-*)) t) nil nil nil nil) (nil nil (factor-gather-exponents-info-list list) (let cons) nil nil nil) (((temp (factor-scatter-exponents-info-list (arg2 x)))) nil (arg1 factor-scatter-exponents-info-entry recursive-call factor-scatter-exponents-info-entry) nil (if) nil nil) ((temp nil x x) nil (arg1 arg2) (factor-scatter-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-factor-scatter-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-scatter-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-rational-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-real/rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-rational-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-rational-match-in-factor-scatter-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-scatter-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::first-non-zero-rational-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-non-zero-real/rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::find-non-zero-rational-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-non-zero-rational-match-in-factor-scatter-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-scatter-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::arith-factor-pattern-scatter-exponents (nil nil nil nil nil nil (cond)) (nil nil ((variablep factor) (fquotep factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) ((factor factor) (0) (`) (let) nil nil nil) (nil nil (UNARY-/ (base (factor-pattern-base (arg1 factor)))) nil (if) nil nil) (nil nil (, exponent acl2-numberp) nil (list if) nil nil) ((base base exponent base) nil (recursive-call arg2 quote quotep `) nil nil nil nil) ((factor EXPT-WITH-CONST-BASE exponent) nil (arg1) (EXPT) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::arith-matching-factor-scatter-exponents-patterns-p (nil nil nil nil nil nil nil) (nil nil ((acl2-numberp pattern-1) (eq (fn-symb pattern-1) (quote EXPT-WITH-CONST-BASE)) (eq (fn-symb pattern-1) (quote EXPT)) (eq (fn-symb pattern-1) (quote UNARY-/)) (eq (fn-symb pattern-2) (quote UNARY-/)) t) nil nil nil nil) ((nil nil) nil nil (equal equal) nil (cond cond) nil) ((pattern-2 pattern-1) nil ((equal (arg1 pattern-1) 0) (eq (fn-symb pattern-2) (quote EXPT-WITH-CONST-BASE)) (eq (fn-symb pattern-2) (quote UNARY-/)) t (equal (arg1 pattern-1) 0) (eq (fn-symb pattern-2) (quote EXPT)) (eq (fn-symb pattern-2) (quote UNARY-/)) t arg1 arg1) nil nil nil nil) ((nil nil nil nil pattern-1 pattern-2) nil nil (matching-exponents matching-exponents and let) nil nil nil) ((pattern-1 (pattern-2-arg1 (arg1 pattern-2))) nil (arg2 arg2 arg1) (equal matching-exponents) (and) nil nil) ((pattern-1 pattern-2 pattern-2) nil (arg1 arg1 arg2 arg2) (eq equal matching-exponents) nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::arith-matching-factor-scatter-exponents-p (nil nil nil (let) nil nil nil) (((factor-pattern (arith-factor-pattern-scatter-exponents factor))) nil nil (arith-matching-factor-scatter-exponents-patterns-p) nil nil nil) ((pattern factor-pattern) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::but-nth (nil nil nil nil (cond) nil nil) (nil nil ((atom list) (<= n 0) t) nil nil nil nil) ((nil) nil (cdr) (recursive-call) nil nil nil) ((list) nil (cdr) (+) nil nil nil) ((list n) (-1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::how-many (nil nil nil nil (cond) nil nil) (nil nil ((atom list) (equal (car list) x) t) nil nil nil nil) ((ans ans) nil nil nil (recursive-call) nil nil) ((x) nil (cdr) (+) nil nil nil) ((list ans) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::prime-factors-1 (nil nil nil (condense-factors) nil nil nil) ((nil) nil nil nil nil (prime-factors-2) nil) ((n i ith-prime factors) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-5/lib/basic-ops/common.lisp::prime-factors (nil nil nil nil nil nil nil) (nil nil ((not (integerp n)) (equal n -1) (equal n 0) (equal n 1) (< 0 n) t) nil nil nil nil) ((nil) nil (quote quote `) nil nil (prime-factors-1 prime-factors-1) nil) (((-1 . 1) (0 . 1) (1 . 1) n nil) (0 2 0 2) (- quote) nil nil nil nil) ((n) (-1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
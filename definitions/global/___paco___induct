((/paco/induct.lisp::unchangeables (nil nil nil nil (cond) nil nil) (nil nil ((endp formals) (and (member-eq (car formals) subset) (eq (car quick-block-info) (quote unchanging))) t) nil nil nil nil) ((ans) nil nil nil nil nil (recursive-call recursive-call)) ((subset subset ans) nil (cdr cdr cdr cdr cdr cdr) (all-vars1) nil nil nil) ((formals args quick-block-info ans formals args quick-block-info) nil (car) nil nil nil nil) ((args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::changeables (nil nil nil nil (cond) nil nil) (nil nil ((endp formals) (and (member-eq (car formals) subset) (not (eq (car quick-block-info) (quote unchanging)))) t) nil nil nil nil) ((ans) nil nil nil nil nil (recursive-call recursive-call)) ((subset subset ans) nil (cdr cdr cdr cdr cdr cdr) (cons) nil nil nil) ((formals args quick-block-info ans formals args quick-block-info) nil (car) nil nil nil nil) ((args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::sound-induction-principle-mask1 (nil nil nil (cond) nil nil nil) (nil nil ((endp formals) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (nil nil nil ((var (car formals))) (mv-let) nil nil) (nil nil (arg q) (mask-ele cons) nil (cond) nil) ((new-unchangeables new-changeables mask-ele) nil (car car (member-eq var subset) (and (variablep arg) (eq q (quote unchanging))) (and (variablep arg) (not (member-eq arg changeables)) (not (member-eq arg unchangeables))) t) nil nil nil nil) ((args quick-block-info subset new-unchangeables new-changeables) nil (cdr cdr cdr) (cond cond) (mv mv) nil nil)) (/paco/induct.lisp::sound-induction-principle-mask (nil nil nil (let) nil nil nil) (nil nil ((unchangeables (unchangeables formals (fargs term) quick-block-info subset nil))) (cond) nil nil nil) (nil nil (changeables (or (not (no-duplicatesp-equal changeables)) (not (all-variablep changeables)) (intersectp-eq changeables unchangeables)) t) nil nil nil nil) ((nil) nil nil nil nil nil (changeables)) ((formals quick-block-info subset nil formals quick-block-info subset unchangeables changeables) nil (fargs fargs) nil nil nil nil) ((term term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::count-non-nils (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (car lst) t) nil nil nil nil) (nil (0) (1+ recursive-call) nil nil nil nil) (nil nil (recursive-call cdr) nil nil nil nil) ((lst) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::controllers (nil nil nil nil (cond) nil nil) (nil nil ((endp formals) (member (car formals) subset) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call recursive-call) nil) ((subset subset ans) nil (cdr cdr cdr cdr) (all-vars1) nil nil nil) ((formals args ans formals args) nil (car) nil nil nil nil) ((args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::changed/unchanged-vars (nil nil nil nil (cond) nil nil) (nil nil ((endp mask) (eq (car mask) x) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call recursive-call) nil) ((x x ans) nil (cdr cdr cdr cdr) (all-vars1) nil nil nil) ((args mask ans args mask) nil (car) nil nil nil nil) ((args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::tests-and-alists/alist (nil nil nil nil nil (cond) nil) (nil nil ((endp mask) (null (car mask)) (eq (car mask) (quote changeable)) t) nil nil nil nil) ((nil) nil nil (cons let) nil (recursive-call) nil) ((alist (vars (all-vars (car args)))) nil (cdr cdr cdr) (cons append) nil (recursive-call) nil) ((args mask call-args alist) nil (car cdr cdr cdr) (sublis-var pairlis) nil (recursive-call) nil) ((args alist args mask call-args vars vars alist) nil (car cdr cdr cdr) nil nil nil nil) ((call-args args mask call-args) nil nil nil nil nil nil)) (/paco/induct.lisp::tests-and-alists/alists (nil nil nil (cond) nil nil nil) (nil nil ((endp calls) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil nil (tests-and-alists/alist recursive-call) nil) ((alist args mask alist args mask) nil (fargs cdr) nil nil nil nil) ((calls) nil (car) nil nil nil nil) ((calls) nil nil nil nil nil nil)) (/paco/induct.lisp::tests-and-alists (nil nil nil nil nil nil (make)) ((recursive-call :tests :alists) nil nil (sublis-var-lst) nil (tests-and-alists/alists) nil) ((alist alist args mask) nil nil nil (access access) nil nil) ((tests-and-calls tc :tests tests-and-calls tc :calls) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::tests-and-alists-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp machine) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil nil (tests-and-alists recursive-call) nil) ((alist args mask alist args mask) nil (car cdr) nil nil nil nil) ((machine machine) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::flesh-out-induction-principle (nil nil nil nil nil nil nil) ((candidate :score :controllers :changed-vars :unchangeable-vars :tests-and-alists-lst :justification justification :induction-term term :xinduction-term xterm :other-terms nil :xother-terms nil :xancestry nil) nil nil (/) nil (controllers changed/unchanged-vars changed/unchanged-vars tests-and-alists-lst) nil) ((formals nil mask nil mask nil mask machine) nil (count-non-nils length fargs quote fargs quote fargs fargs) (pairlis) (access) nil nil) ((mask mask term justification justification :subset changeable term unchangeable term formals term) nil (fargs) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::intrinsic-suggested-induction-cand (nil nil nil (cond) nil nil nil) (nil nil ((enabled-numep (fn-nume :INDUCTION (ffn-symb term) wrld) ens) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((mask (sound-induction-principle-mask term formals quick-block-info (access justification justification :subset)))) nil nil (cond) nil nil nil) (nil nil (mask t) nil nil nil nil) ((nil) nil (list) nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::get-induction-cands-from-cl-set1 (nil nil nil (cond) nil nil nil) (nil nil ((endp cl-set) t) nil nil nil nil) ((ans) nil nil nil nil (mv-let) nil) (nil nil (contradictionp declare) nil nil (type-alist-clause) (get-induction-cands-lst)) ((type-alist nil ens wrld type-alist ens wrld) nil (car ignore car) nil nil (recursive-call) nil) ((cl-set contradictionp cl-set ens wrld ans) nil (cdr) nil nil nil nil) ((cl-set) nil nil nil nil nil nil)) (/paco/induct.lisp::get-induction-cands-from-cl-set (nil nil nil nil nil (get-induction-cands-from-cl-set1) nil) ((cl-set wrld nil) nil nil nil (access) nil nil) ((rewrite-constant :ens) nil nil nil (access) nil nil) ((prove-spec-var pspv :rewrite-constant) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::pigeon-hole-fn-measure (nil nil nil nil nil (case) nil) ((fn) nil (pair-fitp alist-fitp otherwise) nil nil nil nil) (nil (1 2 3) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::flush-cand1-down-cand2 (nil nil nil (cond) nil nil nil) (nil nil ((and (subsetp-eq (access candidate cand1 :changed-vars) (access candidate cand2 :changed-vars)) (subsetp-eq (access candidate cand1 :unchangeable-vars) (access candidate cand2 :unchangeable-vars)) (pigeon-holep (access candidate cand1 :tests-and-alists-lst) (access candidate cand2 :tests-and-alists-lst) nil (quote tests-and-alists-fitp))) t) nil nil nil nil) ((nil) nil nil nil nil nil nil) ((candidate cand2 :score :controllers :other-terms :xother-terms) nil nil (+ union-eq add-to-set-equal add-to-set-equal) nil nil nil) (nil nil nil (union-equal union-equal) (access access access access access access) nil nil) ((candidate cand1 :score candidate cand2 :score candidate cand1 :controllers candidate cand2 :controllers candidate cand1 :induction-term candidate cand1 :xinduction-term) nil nil nil (access access access access) nil nil) ((candidate cand1 :other-terms candidate cand2 :other-terms candidate cand1 :xother-terms candidate cand2 :xother-terms) nil nil nil nil nil nil)) (/paco/induct.lisp::flush-candidates (nil nil nil (or) nil nil nil) (nil nil nil (flush-cand1-down-cand2 flush-cand1-down-cand2) nil nil nil) ((cand1 cand2 cand2 cand1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::alists-agreep (nil nil nil nil (cond) nil nil) (nil nil ((endp vars) (equal (let ((temp (assoc-eq (car vars) alist1))) (cond (temp (cdr temp)) (t (car vars)))) (let ((temp (assoc-eq (car vars) alist2))) (cond (temp (cdr temp)) (t (car vars))))) t) nil nil nil nil) ((t nil) nil nil nil (recursive-call) nil nil) ((alist1 alist2) nil (cdr) nil nil nil nil) ((vars) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::irreconcilable-alistsp (nil nil nil (cond) nil nil nil) (nil nil ((endp alist1) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((temp (assoc-eq (caar alist1) alist2))) nil nil nil (cond) nil nil) (nil nil ((null temp) (equal (cdar alist1) (cdr temp)) t) nil nil nil nil) ((t) nil nil (recursive-call recursive-call) nil nil nil) ((alist2 alist2) nil (cdr cdr) nil nil nil nil)) (/paco/induct.lisp::affinity (nil nil nil (and) nil nil nil) (nil nil nil (eq) (alists-agreep) nil nil) ((alist1 alist2 vars) nil nil (irreconcilable-alistsp eq) nil nil nil) ((alist1 alist2 aff) nil (quote) nil nil nil nil) ((antagonists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::member-affinity (nil nil nil nil (cond) nil nil) (nil nil ((endp alist-lst) (affinity aff alist (car alist-lst) vars) t) nil nil nil nil) ((nil t) nil nil nil nil (recursive-call) nil) ((aff alist vars) nil (cdr) nil nil nil nil) ((alist-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::occur-affinity (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (member-affinity aff alist (access tests-and-alists (car lst) :alists) vars) t) nil nil nil nil) ((nil t) nil nil nil nil (recursive-call) nil) ((aff alist vars) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::some-occur-affinity (nil nil nil (cond) nil nil nil) (nil nil ((endp alists) t) nil nil nil nil) ((nil) nil nil (or) nil nil nil) (nil nil nil nil nil (occur-affinity recursive-call) nil) ((aff lst vars aff lst vars) nil (car cdr) nil nil nil nil) ((alists alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::all-occur-affinity (nil nil nil (cond) nil nil nil) (nil nil ((endp alists) t) nil nil nil nil) ((t) nil nil (and) nil nil nil) (nil nil nil nil nil (occur-affinity recursive-call) nil) ((aff lst vars aff lst vars) nil (car cdr) nil nil nil nil) ((alists alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::contains-affinity (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (member-affinity aff (car lst) (cdr lst) vars) t) nil nil nil nil) ((nil t) nil nil nil (recursive-call) nil nil) ((aff vars) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::antagonistic-tests-and-alists-lstp (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil nil (or) nil nil) (nil nil nil (recursive-call) (contains-affinity) (some-occur-affinity) nil) ((vars vars vars) nil (quote quote cdr cdr) nil (access access) nil nil) ((antagonists tests-and-alists :alists antagonists tests-and-alists :alists lst lst) nil (car car) nil nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/induct.lisp::antagonistic-tests-and-alists-lstsp (nil nil nil (cond) nil nil nil) (nil nil ((endp lst1) t) nil nil nil nil) ((nil) nil nil (or) nil nil nil) (nil nil nil nil (recursive-call) (some-occur-affinity) nil) ((lst2 vars lst2 vars) nil (quote cdr) nil (access) nil nil) ((antagonists tests-and-alists :alists lst1) nil (car) nil nil nil nil) ((lst1) nil nil nil nil nil nil)) (/paco/induct.lisp::every-alist1-matedp (nil nil nil (cond) nil nil nil) (nil nil ((endp lst1) t) nil nil nil nil) ((t) nil nil (and) nil nil nil) (nil nil nil nil (recursive-call) (all-occur-affinity) nil) ((lst2 vars lst2 vars) nil (quote cdr) nil (access) nil nil) ((mates tests-and-alists :alists lst1) nil (car) nil nil nil nil) ((lst1) nil nil nil nil nil nil)) (/paco/induct.lisp::merge-alist1-into-alist2 (nil nil nil (cond) nil nil nil) (nil nil ((alists-agreep alist1 alist2 vars) t) nil nil nil nil) ((alist2) nil nil (union-equal) nil nil nil) ((alist1 alist2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::merge-alist1-lst-into-alist2 (nil nil nil (cond) nil nil nil) (nil nil ((endp alist1-lst) t) nil nil nil nil) ((alist2) nil nil nil (recursive-call) nil nil) ((vars) nil (cdr) nil (merge-alist1-into-alist2) nil nil) ((alist1-lst alist2 vars) nil (car) nil nil nil nil) ((alist1-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::merge-lst1-into-alist2 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst1) t) nil nil nil nil) ((alist2) nil nil nil (recursive-call) nil nil) ((vars) nil (cdr) nil (merge-alist1-lst-into-alist2) nil nil) ((lst1 alist2 vars) nil nil nil (access) nil nil) ((tests-and-alists :alists) nil (car) nil nil nil nil) ((lst1) nil nil nil nil nil nil)) (/paco/induct.lisp::merge-lst1-into-alist2-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp alist2-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil (merge-lst1-into-alist2 recursive-call) nil nil) ((lst1 vars lst1 vars) nil (car cdr) nil nil nil nil) ((alist2-lst alist2-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::merge-lst1-into-lst2 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst2) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil (recursive-call) (change) nil) ((tests-and-alists :alists lst1 vars) nil (car cdr) nil (merge-lst1-into-alist2-lst) nil nil) ((lst2 lst1 vars lst2) nil nil nil (access) nil nil) ((tests-and-alists :alists) nil (car) nil nil nil nil)) (/paco/induct.lisp::merge-tests-and-alists-lsts (nil nil nil nil nil (cond) nil) (nil nil ((antagonistic-tests-and-alists-lstp lst1 vars) (antagonistic-tests-and-alists-lstsp lst1 lst2 vars) (not (every-alist1-matedp lst1 lst2 vars)) t) nil nil nil nil) ((nil nil nil) nil nil nil (merge-lst1-into-lst2) nil nil) ((lst1 lst2 vars) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::merge-cand1-into-cand2 (nil nil nil (let) nil nil nil) (((vars (or (intersection-eq (access candidate cand1 :controllers) (intersection-eq (access candidate cand2 :controllers) (intersection-eq (access candidate cand1 :changed-vars) (access candidate cand2 :changed-vars)))) (intersection-eq (access candidate cand1 :changed-vars) (access candidate cand2 :changed-vars))))) nil nil (cond) nil nil nil) (nil nil ((and vars (not (intersectp-eq (access candidate cand1 :unchangeable-vars) (access candidate cand2 :changed-vars))) (not (intersectp-eq (access candidate cand2 :unchangeable-vars) (access candidate cand1 :changed-vars)))) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((temp (merge-tests-and-alists-lsts (access candidate cand1 :tests-and-alists-lst) (access candidate cand2 :tests-and-alists-lst) vars))) nil nil (cond) nil nil nil) (nil nil (temp t) nil nil nil nil) ((nil) nil nil nil nil nil nil)) (/paco/induct.lisp::merge-candidates (nil nil nil (or) nil nil nil) (nil nil nil (merge-cand1-into-cand2 merge-cand1-into-cand2) nil nil nil) ((cand1 cand2 cand2 cand1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::controller-variables1 (nil nil nil nil (cond) nil nil) (nil nil ((endp controller-pocket) (and (car controller-pocket) (variablep (car args))) t) nil nil nil nil) ((nil) nil nil (add-to-set-eq recursive-call) nil nil nil) (nil nil (car cdr cdr) (recursive-call) nil nil nil) ((args args controller-pocket) nil (cdr cdr) nil nil nil nil) ((args controller-pocket) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::controller-variables (nil nil nil (cond) nil nil nil) (nil nil ((endp controller-alists) t) nil nil nil nil) ((nil) nil nil (union-eq) nil nil nil) (nil nil nil (controller-variables1 recursive-call) nil nil nil) ((term) nil (fargs cdr cdr) nil nil nil nil) ((term controller-alists) nil nil (assoc-eq) nil nil nil) (nil nil (ffn-symb car) nil nil nil nil)) (/paco/induct.lisp::induct-vars1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (union-eq) nil nil nil) (nil nil nil (controller-variables recursive-call) nil nil nil) ((wrld) nil (car cdr) nil nil (getprop) nil) ((lst nil wrld lst) nil (ffn-symb quote) nil nil nil nil) ((controller-alists) nil (car) nil nil nil nil)) (/paco/induct.lisp::induct-vars (nil nil nil (induct-vars1) nil nil nil) ((wrld) nil nil (cons) nil nil nil) (nil nil nil nil (access access) nil nil) ((candidate cand :induction-term candidate cand :other-terms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::vetoedp (nil nil nil nil nil nil (cond)) (nil nil ((endp lst) (equal cand (car lst)) (and changed-vars-flg (intersectp-eq vars (access candidate (car lst) :changed-vars))) (intersectp-eq vars (access candidate (car lst) :unchangeable-vars)) t) nil nil nil nil) ((nil t t) nil nil nil nil (recursive-call recursive-call) nil) ((cand vars changed-vars-flg cand vars changed-vars-flg) nil (cdr cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::compute-vetoes1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (vetoedp (car lst) (intersection-eq (access candidate (car lst) :changed-vars) (induct-vars (car lst) wrld)) cand-lst t) t) nil nil nil nil) ((nil) nil nil (cons) (recursive-call) nil nil) ((cand-lst wrld) nil (cdr car) nil (recursive-call) nil nil) ((lst lst cand-lst wrld) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::compute-vetoes2 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (vetoedp (car lst) (access candidate (car lst) :changed-vars) cand-lst nil) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((cand-lst) nil (cdr car) (recursive-call) nil nil nil) ((lst lst cand-lst) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::compute-vetoes (nil nil nil nil (or) nil nil) ((cand-lst) nil nil (compute-vetoes2) (compute-vetoes1) nil nil) ((cand-lst cand-lst wrld cand-lst cand-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-complexity1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (getprop (ffn-symb (car lst)) (quote primitive-recursive-defunp) nil wrld) t) nil nil nil nil) (nil (0) (1+) (recursive-call) nil nil nil) ((wrld) nil (cdr) (recursive-call) nil nil nil) ((lst wrld) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::maximal-elements-apply (nil nil nil nil nil (case) nil) ((fn) nil (induction-complexity score otherwise) nil nil nil nil) (nil (0) nil (induction-complexity1) (access) nil nil) ((wrld candidate x :score) nil nil (cons) nil nil nil) (nil nil nil nil (access access) nil nil) ((candidate x :induction-term candidate x :other-terms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::maximal-elements1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((winners) nil nil (let) nil nil nil) (((temp (maximal-elements-apply fn (car lst) wrld))) nil nil nil (cond) nil nil) (nil nil ((> temp maximum) (= temp maximum) t) nil nil nil nil) (nil nil nil nil nil nil (recursive-call recursive-call recursive-call)) ((temp fn wrld maximum fn wrld winners maximum fn wrld) nil (cdr list cdr cdr) (cons) nil nil nil)) (/paco/induct.lisp::maximal-elements (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (endp (cdr lst)) t) nil nil nil nil) ((nil lst) nil (reverse) nil nil nil nil) (nil nil nil nil nil nil (maximal-elements1)) ((fn wrld) nil (cdr list) nil (maximal-elements-apply) nil nil) ((lst fn wrld) nil (car car) nil nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/induct.lisp::intersectp-eq/union-equal (nil nil nil (cond) nil nil nil) (nil nil ((intersectp-eq (car x) (car y)) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (union-eq union-equal) nil nil nil) (nil nil (car car cdr cdr) nil nil nil nil) ((x y x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::equal/union-equal (nil nil nil (cond) nil nil nil) (nil nil ((equal (car x) (car y)) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (car) (union-equal) nil nil nil) ((x) nil (cdr cdr) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::subsetp-equal/smaller (nil nil nil nil (cond) nil nil) (nil nil ((subsetp-equal x y) (subsetp-equal y x) t) nil nil nil nil) ((x y nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::m&m-apply (nil nil nil nil nil nil nil) ((fn) nil (intersectp-eq/union-equal equal/union-equal flush-candidates merge-candidates subsetp-equal/smaller) nil nil nil nil) (nil nil nil (intersectp-eq/union-equal equal/union-equal flush-candidates merge-candidates subsetp-equal/smaller) nil nil nil) ((x y x y x y x y x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::count-off (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (cons recursive-call) nil nil nil) ((n) nil (car 1+ cdr) nil nil nil nil) ((lst n lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::m&m-search (nil nil nil nil (cond) nil nil) (nil nil ((endp y-lst) (member (caar y-lst) del) t) nil nil nil nil) (nil nil nil (mv let) nil (recursive-call) nil) ((nil nil x del fn (z (m&m-apply fn x (cdar y-lst)))) nil (cdr) (cond) nil nil nil) ((y-lst) nil (z t) nil nil nil nil) (nil nil nil (mv) nil (recursive-call) nil) ((z x del fn) nil (caar cdr) nil nil nil nil)) (/paco/induct.lisp::count-undel (nil nil nil nil (cond) nil nil) (nil nil ((endp pairs) (member (caar pairs) del) t) nil nil nil nil) (nil (0) nil (recursive-call +) nil nil nil) ((del) (1) (cdr) (recursive-call) nil nil nil) ((pairs del) nil (cdr) nil nil nil nil) ((pairs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::exists-pair-with-car (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (equal x (caar lst)) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((x) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::m&m1 (nil nil nil nil (cond) nil nil) (nil nil ((endp pairs) (member (caar pairs) del) t) nil nil nil nil) ((ans) nil nil nil (mv-let) nil (recursive-call)) ((del ans n fn) nil (cdr mrg) (cond) nil (m&m-search) nil) ((pairs y-id del fn) nil (cdar cdr (null mrg) t) nil nil nil nil) ((pairs pairs) nil nil nil nil nil (recursive-call recursive-call)) ((del n fn ans fn) nil (cdr 1+) (cons cons cons) nil nil nil)) (/paco/induct.lisp::m&m (nil nil nil nil nil nil (m&m1)) ((nil nil fn) nil (length) (count-off) nil nil nil) ((bag bag) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) nil (/paco/induct.lisp::or-subset-trees (nil nil nil nil nil (cond) nil) (nil nil ((or (eq tree1 t) (eq tree2 t)) (null tree1) (null tree2) t) nil nil nil nil) ((t tree2 tree1) nil nil (cons-subset-tree) nil nil nil) (nil nil nil (recursive-call recursive-call) nil nil nil) (nil nil (car-subset-tree car-subset-tree cdr-subset-tree cdr-subset-tree) nil nil nil nil) ((tree1 tree2 tree1 tree2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::m&m-over-powerset1 (nil nil nil nil (cond) nil nil) (nil nil ((eq stree t) (endp st) t) nil nil nil nil) (nil nil nil (mv let) (mv-let) nil nil) ((t ans (z (m&m subset fn))) nil (stree1) (cond) (mv-let) nil (recursive-call)) ((ans1 ans fn) nil ((and z (null (cdr z))) t cdr cdr-subset-tree stree2) (cons mv) nil nil (recursive-call)) ((st subset stree ans2 subset ans1 fn ans2) nil (car cdr) (mv mv or-subset-trees cons-subset-tree) nil nil nil) ((t nil ans st st stree1 stree2 stree1) nil (car-subset-tree) (cons) nil nil nil)) (/paco/induct.lisp::m&m-over-powerset (nil nil nil nil nil (mv-let) nil) ((ans) nil (stree declare) nil nil nil (m&m-over-powerset1)) ((ans st nil nil nil fn) nil (ignore) nil nil nil nil) ((stree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::all-picks2 (nil nil nil (cond) nil nil nil) (nil nil ((endp pocket) t) nil nil nil nil) ((ans) nil nil (cons) nil nil nil) (nil nil nil (cons) (recursive-call) nil nil) ((pick pick ans) nil (car cdr) nil nil nil nil) ((pocket pocket) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::all-picks2r (nil nil nil (cond) nil nil nil) (nil nil ((endp pocket) t) nil nil nil nil) ((ans) nil nil nil (recursive-call) nil nil) ((pick) nil (cdr) (cons) nil nil nil) ((pocket ans) nil nil (cons) nil nil nil) ((pick) nil (car) nil nil nil nil) ((pocket) nil nil nil nil nil nil)) (/paco/induct.lisp::all-picks1 (nil nil nil (cond) nil nil nil) (nil nil ((endp picks) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call) nil) ((pocket rflg) nil (cdr) nil (if) nil nil) ((picks rflg) nil nil nil (all-picks2r all-picks2) nil nil) ((pocket ans pocket ans) nil (car car) nil nil nil nil) ((picks picks) nil nil nil nil nil nil)) (/paco/induct.lisp::all-picks (nil nil nil (cond) nil nil nil) (nil nil ((endp pockets) t) nil nil nil nil) (nil nil (quote) nil nil (all-picks1) nil) ((nil nil rflg) nil (car) (recursive-call) nil nil nil) ((pockets) nil (cdr not) nil nil nil nil) ((pockets rflg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::dumb-negate-lit-lst-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp cl-set) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (dumb-negate-lit-lst recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((cl-set cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-hyp-clause-segments2 (nil nil nil (cond) nil nil nil) (nil nil ((endp alists) t) nil nil nil nil) ((ans) nil nil (cons) nil nil nil) (nil nil nil (sublis-var-lst) (recursive-call) nil nil) ((cl cl ans) nil (car cdr) nil nil nil nil) ((alists alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-hyp-clause-segments1 (nil nil nil (cond) nil nil nil) (nil nil ((endp cl-set) t) nil nil nil nil) ((ans) nil nil nil (induction-hyp-clause-segments2) nil nil) ((alists) nil (car) nil (recursive-call) nil nil) ((cl-set alists ans) nil (cdr) nil nil nil nil) ((cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-hyp-clause-segments (nil nil nil (all-picks) nil nil nil) ((nil) nil nil nil (induction-hyp-clause-segments1) nil nil) ((alists nil) nil (dumb-negate-lit-lst-lst) nil nil nil nil) ((cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-formula3 (nil nil nil (cond) nil nil nil) (nil nil ((endp hyp-segments) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call) nil) ((neg-tests cl) nil (cdr) (conjoin-clause-to-clause-set) nil nil nil) ((hyp-segments ans) nil nil (disjoin-clauses) nil nil nil) ((neg-tests) nil nil (disjoin-clauses) nil nil nil) ((cl) nil (car) nil nil nil nil)) (/paco/induct.lisp::induction-formula2 (nil nil nil (cond) nil nil nil) (nil nil ((endp ta-lst) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call) nil) ((cl cl-set) nil (cdr) nil nil (induction-formula3) nil) ((ta-lst cl ans) nil (dumb-negate-lit-lst) (induction-hyp-clause-segments) nil nil nil) ((cl-set) nil nil nil (access access) nil nil) ((tests-and-alists :tests tests-and-alists :alists) nil (car car) nil nil nil nil)) (/paco/induct.lisp::induction-formula1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((ans) nil nil nil nil (recursive-call) nil) ((cl-set ta-lst) nil (cdr) nil nil (induction-formula2) nil) ((lst cl-set ta-lst ans) nil (car) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-formula (nil nil nil (m&m) nil nil nil) (nil nil (reverse quote) nil nil nil nil) ((subsetp-equal/smaller) nil nil nil nil (induction-formula1) nil) ((cl-set cl-set ta-lst nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::all-picks-size (nil nil nil (cond) nil nil nil) (nil nil ((endp cl-set) t) nil nil nil nil) (nil (1) nil (*) nil nil nil) (nil nil (length recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((cl-set cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induction-formula-size1 (nil nil nil (cond) nil nil nil) (nil nil ((endp ta-lst) t) nil nil nil nil) (nil (0) nil (+) nil nil nil) (nil nil nil (*) (recursive-call) nil nil) ((concl-size hyps-size concl-size) nil (cdr) (expt) nil nil nil) ((hyps-size ta-lst) nil (length) nil nil nil nil) (nil nil nil nil (access) nil nil)) (/paco/induct.lisp::induction-formula-size (nil nil nil nil (induction-formula-size1) nil nil) ((ta-lst) nil (all-picks-size length) nil nil nil nil) ((cl-set cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::termify-clause-set (nil nil nil nil (cond) nil nil) (nil nil ((endp clauses) (endp (cdr clauses)) t) nil nil nil nil) ((*t*) nil (disjoin) nil nil (fcons-term*) nil) ((*nil*) nil (car quote disjoin recursive-call) nil nil nil nil) ((clauses if) nil (car cdr) nil nil nil nil) ((clauses clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::inform-simplify3 (nil nil nil (cond) nil nil nil) (nil nil ((endp terms) t) nil nil nil nil) ((ans) nil nil nil (recursive-call) nil nil) ((alist) nil (cdr) (add-to-set-equal) nil nil nil) ((terms ans) nil nil (sublis-var) nil nil nil) ((alist) nil (car) nil nil nil nil) ((terms) nil nil nil nil nil nil)) (/paco/induct.lisp::inform-simplify2 (nil nil nil (cond) nil nil nil) (nil nil ((endp alists) t) nil nil nil nil) ((ans) nil nil nil (recursive-call) nil nil) ((terms) nil (cdr) nil (inform-simplify3) nil nil) ((alists terms ans) nil (car) nil nil nil nil) ((alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::inform-simplify1 (nil nil nil (cond) nil nil nil) (nil nil ((endp ta-lst) t) nil nil nil nil) ((ans) nil nil nil (recursive-call) nil nil) ((terms) nil (cdr) nil (inform-simplify2) nil nil) ((ta-lst terms ans) nil nil nil (access) nil nil) ((tests-and-alists :alists) nil (car) nil nil nil nil) ((ta-lst) nil nil nil nil nil nil)) (/paco/induct.lisp::inform-simplify (nil nil nil nil nil nil nil) ((prove-spec-var pspv :rewrite-constant :induction-concl-terms terms :induction-hyp-terms) nil nil nil (inform-simplify1) (change) nil) ((rewrite-constant :ens ta-lst terms nil) nil nil nil (access access) nil nil) ((prove-spec-var pspv :rewrite-constant prove-spec-var pspv :global-ens) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::remove-trivial-clauses (nil nil nil nil (cond) nil nil) (nil nil ((endp clauses) (trivial-clause-p (car clauses) ens wrld) t) nil nil nil nil) ((nil) nil nil (cons) (recursive-call) nil nil) ((ens wrld) nil (cdr car) nil (recursive-call) nil nil) ((clauses clauses ens wrld) nil (cdr) nil nil nil nil) ((clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/induct.lisp::induct-clause (nil nil nil (let) nil nil nil) (nil nil ((cl-set (list cl))) (cond) nil nil nil) (nil nil (induct-hint-val (eq induct-hint-val :DO-NOT-INDUCT) t) nil nil nil nil) (nil nil nil (let*) (access) (mv) nil) ((prove-spec-var pspv :induct-hint-val nil nil nil) nil (quote) (cond) nil nil nil) ((MISS) nil (candidates flushed-candidates merged-candidates unvetoed-candidates complicated-candidates high-scoring-candidates winning-candidate winning-candidate t) nil nil nil nil) (nil nil (car <induct-clause-id>) (m&m cond compute-vetoes) (get-induction-cands-from-cl-set maximal-elements maximal-elements) (mv) nil)))
((/centaur/vl/loader/parse-utils.lisp::wrap-list-in-forces (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((x) nil (` recursive-call) nil nil nil nil) (nil nil (force cdr) nil nil nil nil) ((x) nil (,) nil nil nil nil) (nil nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/centaur/vl/loader/parse-utils.lisp::adjust-guard-for-theorems (nil nil nil nil (if) nil nil) (nil nil (` `) (and) nil nil nil) (nil nil (consp force) (eq and) nil nil nil) ((x ,) nil (car quote wrap-list-in-forces ,) nil nil nil nil) ((x and x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/vl/loader/parse-utils.lisp::expand-and-maybe-induct-hint-fn (nil nil nil (and) nil nil nil) (nil nil (not) (let*) nil nil nil) (nil nil (cdr) ((fn (car fncall))) (if) nil nil) ((recursivep) nil (car frees recursivep ` `) nil nil nil nil) ((id) nil nil (remove-eq) (:in-theory) nil (acl2::getprop :expand)) ((fn nil world (:free (, frees) (, fncall)) :in-theory :induct :expand (:free (, frees) (, fncall))) nil (quote cdr quote quote ,) (e/d e/d) nil nil nil) ((tokens fncall acl2::recursivep acl2::current-acl2-world fncall) nil (,) ((:induction (, fn)) (:definition (, fn)) (:definition (, fn))) nil nil nil)) (/centaur/vl/loader/parse-utils.lisp::defparser-fn (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (args-for-def decls body count result result-hints resultp-of-nil true-listp fails guard hint-chicken-switch verify-guards thm-hyps) nil nil nil nil) (nil nil (throw-away-keyword-parts car cdr cdr cdr cdr cdr cdr) (butlast extract-keyword-from-args extract-keyword-from-args extract-keyword-from-args ACL2::add-to-ruleset add-macro-alias add-untranslate-pattern) (if defmacro) nil (defund)) ((args args-for-def :resultp-of-nil args :guard args :verify-guards args guard defparser-type-prescriptions nil) (1) (last ` ` , , , declare ,@ quote , , (, fn-name) (, name) local ,@ ,@ ,@ ,@ ,@) (extract-keyword-from-args extract-keyword-from-args extract-keyword-from-args extract-keyword-from-args extract-keyword-from-args extract-keyword-from-args list) ((,@ (butlast formals 2)) let) nil nil) ((args :count args :result args :result-hints args :true-listp args :fails args :hint-chicken-switch args name &optional fn-name formals decls (__function__ (quote (, name))) (:type-prescription (, fn-name)) name fn-name) nil (force tokens warnings quote ,@ declare , ,@ ,@ in-theory) (and cond cond) (xargs if) (cond) (cond)) ((formals :guard body formals nil) nil (force , vl-tokenlist-p quote quote , , ,@ ignorable enable not ` (not fails) (equal (symbol-name fails) NEVER) (equal (symbol-name fails) GRACEFULLY) t (not result) t (not true-listp) t (not count) (equal (symbol-name count) WEAK) (equal (symbol-name count) STRONG) (equal (symbol-name count) STRONG-ON-VALUE) t) (butlast) nil nil nil)) (/centaur/vl/loader/parse-utils.lisp::vl-gather-forms-of-type (nil nil nil nil (cond) nil nil) (nil nil ((atom forms) (and (consp (car forms)) (member-eq (caar forms) types)) t) nil nil nil nil) ((nil) nil nil (cons recursive-call) nil nil nil) ((types) nil (car cdr) (recursive-call) nil nil nil) ((forms types forms) nil (cdr) nil nil nil nil) ((forms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/vl/loader/parse-utils.lisp::vl-mutual-recursion-fn (nil nil nil (let*) nil nil nil) (nil nil nil nil ((main-types (quote (defun defund))) mv-let) nil nil) (nil nil (pre-types post-types all-types) (erp) (vl-macroexpand-all-until-recognized-type if) nil nil) ((val state forms all-types state erp) nil (quote quote) (let) (append mv) nil nil) ((defmacro main-types pre-types post-types erp val state) nil nil ((pre-forms (vl-gather-forms-of-type val pre-types))) (mv) (add-untranslate-pattern) nil) ((add-macro-alias encapsulate acl2::add-to-ruleset in-theory nil state) nil (main-forms post-forms `) nil nil nil nil) (nil nil nil (vl-gather-forms-of-type vl-gather-forms-of-type) nil (encapsulate) nil)))
((/clause-processors/SULFA/books/sat/local-clause-simp.lisp::negate-f-expr (nil nil nil nil nil (cond) nil) (nil nil ((integerp f0) (eq f0 *f-false*) (eq f0 *f-true*) t) nil nil nil nil) ((*f-true* *f-false*) nil (-) nil nil (er) nil) ((f0 hard Invalid f-expression:~x0~% f0) nil (quote) nil nil nil nil) ((recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::remove-lit (nil nil nil nil (if) nil nil) (nil nil (posp) nil (update-pos-vari update-neg-vari) nil nil) ((lit lit $sat $sat) (0 0) (-) nil nil nil nil) ((lit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::remove-old (nil nil nil nil (if) nil nil) (($sat) nil (endp) (let) nil nil nil) ((clause ($sat (remove-lit (car clause) $sat))) nil nil (recursive-call) nil nil nil) (($sat) nil (cdr) nil nil nil nil) ((clause) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::add-lit (nil nil nil nil (if) nil nil) (nil nil (posp) nil (update-pos-vari update-neg-vari) nil nil) ((lit lit $sat $sat) (1 1) (-) nil nil nil nil) ((lit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::oposite-lit (nil nil nil nil (if) nil nil) (nil nil (posp) (equal equal) nil nil nil) ((lit) (1 1) nil (neg-vari pos-vari) nil nil nil) ((lit $sat $sat) nil (-) nil nil nil nil) ((lit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::duplicate-lit (nil nil nil nil (if) nil nil) (nil nil (posp) (equal equal) nil nil nil) ((lit) (1 1) nil (pos-vari neg-vari) nil nil nil) ((lit $sat $sat) nil (-) nil nil nil nil) ((lit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::local-clause-opt (nil nil nil nil nil nil (cond)) (nil nil ((endp clause) (not (integerp (car clause))) (duplicate-lit (car clause) $sat) (oposite-lit (car clause) $sat) t) nil nil nil nil) (nil nil nil (let let let) (cond recursive-call) nil nil) ((($sat (remove-old ans $sat)) ans $sat ($sat (remove-old ans $sat)) ($sat (add-lit (car clause) $sat))) nil ((eq *f-false* (car clause)) (eq *f-true* (car clause)) t cdr) nil (mv mv recursive-call) nil nil) ((nil ans $sat clause t nil $sat $sat) nil (cdr) (let cons) (recursive-call mv) nil nil) ((ans $sat ($sat (remove-old ans $sat)) ans $sat clause ans) nil (cdr car) nil (mv) (er) nil) ((clause t nil $sat hard Illegal f-expression: ~x0~% clause) nil (quote car) nil nil nil nil)) (/clause-processors/SULFA/books/sat/local-clause-simp.lisp::add-cnf-clause (nil nil nil nil (mv-let) nil nil) (nil nil nil (always-true) (local-clause-opt cond) nil nil) ((clause $sat clause nil $sat) nil (always-true clause t) nil nil nil nil) (nil nil nil (mv let*) (mv-let) nil nil) (($sat state) nil (($sat (update-num-f-clauses (1+ (num-f-clauses $sat)) $sat)) f-var ++f-var) (mv let*) nil nil nil) (($sat state $sat $sat) nil (state) (($sat (update-num-f-clauses (+ 2 (num-f-clauses $sat)) $sat)) mv) nil nil nil) (($sat state) nil (state state) nil nil (print-object$-ser) nil)))
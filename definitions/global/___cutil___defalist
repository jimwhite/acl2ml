((/cutil/defalist.lisp::defalist-fn (nil nil nil (b*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (mksym-package-symbol x a n y (unless (and (symbol-listp formals) (no-duplicatesp formals))) (unless (member x formals)) (when (or (member a formals) (member n formals) (member y formals))) (unless (and (consp key) (symbolp (car key)))) keyp key-formals (unless (and (consp val) (symbolp (car val)))) valp val-formals (unless (member keyp-of-nil (quote (t nil :unknown)))) (unless (member valp-of-nil (quote (t nil :unknown)))) (unless (booleanp verify-guards)) (unless (or (eq mode :logic) (eq mode :program))) short long doc last-ditch-hint def (when (eq mode :program))) nil nil nil nil) ((name nil logic) nil (car cdr car cdr ` ` ` ,@ , local local local ,@ ,@ ,@) (intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol or or) (er er if set-inhibit-warnings) (er er er er er er er defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm) nil) ((X name A name N name Y name hard The formals must be a list of unique symbols, but the ~
            formals are ~x0. formals hard The formals must contain X, but are ~x0.~% formals hard As a special restriction, formals may not mention a, n, ~
            or y, but the formals are ~x0. formals hard The key recognizer must be a function applied ~
             to the formals, but is ~x0. key key key hard The value recognizer must be a function applied ~
             to the formals, but is ~x0. val val val hard? keyp-of-nil must be a boolean or :unknown. hard? valp-of-nil must be a boolean or :unknown. hard :verify-guards must be a boolean, but is ~x0. verify-guards hard :mode must be one of :logic or :program, but is ~x0. mode short long nil theory free non-rec doc def :hints :hints :hints :hints :hints :hints (, last-ditch-hint) :hints (, last-ditch-hint) :hints (, last-ditch-hint) :rule-classes :hints :rule-classes :hints :rule-classes :hints :rule-classes :hints :hints :hints :hints :hints :hints :hints :hints :hints (, last-ditch-hint) :hints (, last-ditch-hint) :hints (, last-ditch-hint) :hints (, last-ditch-hint) :hints :hints :hints :hints) nil (quote quote quote quote quote quote quote quote quote ` in-theory in-theory , (Goal :in-theory (enable (, name))) , (Goal :in-theory (enable (, name))) , (Goal :induct (len (, x)) :in-theory (enable append)) , (Goal :induct (len (, x)) :in-theory (enable rev)) , (Goal :induct (revappend (, x) (, y)) :in-theory (enable revappend)) , , , , (:rewrite :backchain-limit-lst 0) (Goal :induct (len (, x)) :in-theory (enable member-equal)) , (:rewrite) (Goal :induct (len (, x)) :in-theory (enable member-equal)) , (:rewrite) (Goal :induct (len (, x)) :in-theory (enable member-equal)) , (:rewrite) (Goal :induct (len (, x)) :in-theory (enable subsetp-equal)) , (Goal :induct (nthcdr (, n) (, x)) :in-theory (enable nthcdr)) , (Goal :in-theory (enable simpler-take) :induct (simpler-take (, n) (, x))) , (Goal :induct (repeat (, a) (, n)) :in-theory (enable repeat)) , (Goal :induct (last (, x)) :in-theory (enable last)) , (Goal :in-theory (enable butlast)) , (Goal :induct (len (, x)) :in-theory (enable set-difference-equal)) , (Goal :induct (len (, x)) :in-theory (enable union-equal)) , , , , , (Goal :in-theory (enable hons-acons)) , (Goal :induct (hons-shrink-alist (, x) (, y)) :in-theory (enable hons-shrink-alist)) , (Goal :induct (make-fal (, x) (, y)) :in-theory (enable make-fal)) , (Goal :induct (len (, x)) :in-theory (enable hons-assoc-equal))) (and and and progn deftheory implies equal and equal equal equal implies implies implies implies implies implies implies implies implies equal and implies implies implies implies implies implies implies and implies equal implies implies implies) (or) (defund) nil) ((defalist defalist defalist defalist defalist defalist defalist defalist defalist parents parents parents short long (defxdoc (, name) :parents (, parents) :short (, short) :long (, long)) stable-under-simplificationp (,@ formals)) nil (quote , declare ,@ , theory , not , (, name) , not ` (, name) , (, name) (, name) , (, name) , (, name) (, name) (, name) , , , , force , , (, name) , not ` force , , force , , force (, name) (, name) not ` force (, name) , (, name) , (, name) , (, name) ,) (set-difference-equal mksym equal mksym mksym and mksym mksym and equal equal equal mksym and equal and equal :rewrite and equal :rewrite mksym and equal :rewrite mksym equal mksym and equal mksym or mksym equal mksym and equal mksym equal mksym and equal mksym equal mksym equal mksym equal mksym equal mksym mksym and mksym and equal) (if mksym mksym mksym mksym mksym and mksym) (str::cat and :rewrite) nil) ((@(call  ) recognizes
association lists where every key satisfies @(see  ) and
each value satisfies @(see  ). <p>This is an ordinary @(see defalist).</p> @(def  ) name doc def car-cons cdr-cons car-cdr-elim zp len natp deflist-lemma-1 deflist-lemma-2 deflist-lemma-3 deflist-lemma-4 deflist-lemma-6 name last-ditch-hint name last-ditch-hint true-listp (defthm (, (mksym name (quote -of-list-fix))) (equal ((, name) (,@ (subst (` (list-fix (, x))) x formals))) ((, name) (,@ formals))) :hints ((Goal :induct (len (, x)) :in-theory (enable list-fix)) (, last-ditch-hint))) name last-ditch-hint name last-ditch-hint name last-ditch-hint keyp name valp name name name t name t :backchain-limit-lst :corollary last-ditch-hint keyp name t :corollary last-ditch-hint valp name t :corollary last-ditch-hint name :corollary last-ditch-hint name t last-ditch-hint name t last-ditch-hint name last-ditch-hint true-listp (defthm (, (mksym name (quote -of-mergesort))) (equal ((, name) (,@ (subst (` (mergesort (, x))) x formals))) ((, name) (,@ formals))) :hints ((Goal :cases (((, name) (,@ formals)))) (, last-ditch-hint))) name t last-ditch-hint name t last-ditch-hint name t last-ditch-hint name t last-ditch-hint name t name t name t true-listp (defthm (, (mksym name (quote -of-union))) (implies (and (force ((, name) (,@ formals))) (force ((, name) (,@ (subst y x formals))))) ((, name) (,@ (subst (` (union (, x) (, y))) x formals)))) :hints ((Goal :use ((:instance deflist-lemma-5 (x (, x)) (y (, y))) (:instance (, (mksym name (quote -of-append))))) :in-theory (disable (, (mksym name (quote -of-append))))) (, last-ditch-hint))) name t name last-ditch-hint name last-ditch-hint name last-ditch-hint valp name last-ditch-hint) (0) (symbol-name symbol-name symbol-name symbol-name :in-theory consp , quote current-theory current-theory quote consp (, name) , quote ,@ consp (, keyp) (, valp) (, name) quote ,@ (, name) (, name) quote ,@ ,@ quote ,@ (, name) (, name) quote ,@ (, keyp) , quote ,@ (, valp) , quote ,@ (, name) quote (, name) consp quote (, name) (, keyp) quote (, name) (, valp) quote (, name) (, name) , quote (, name) (, name) quote force force (, name) quote ,@ zp quote (, name) (, name) quote force force (, name) quote (, name) (, name) quote force force (, name) quote (, name) (, name) quote ,@ (, name) quote ,@ (, name) quote (, name) (, name) quote ,@ (, keyp) (, valp) (, name) quote force force ,@ quote force force ,@ quote ,@ (, valp) ,) (mksym member-equal implies member-equal implies member-equal implies subsetp-equal implies) (and) (and) nil)))
((/coi/util/recursion-support.lisp::syn-truep (nil nil nil nil nil (and) nil) (nil nil (consp consp not) (equal) nil nil nil) ((x) nil (car quote cdr) (equal) nil nil nil) ((x quote x) nil (cadr quote) nil nil nil nil) ((x nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) nil (/coi/util/recursion-support.lisp::syn-falsep (nil nil nil (or) nil nil nil) (nil nil (null) nil nil (and) nil) ((x) nil (consp consp) (equal equal) nil nil nil) ((x) nil (car quote cdr cadr quote) nil nil nil nil) ((x quote x x nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) nil (/coi/util/recursion-support.lisp::syn-if (nil nil (`) nil nil nil nil) (nil nil nil nil (if) nil nil) (nil nil (, , ,) nil nil nil nil) ((x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-lazy-if (nil nil nil nil (cond) nil nil) (nil nil ((syn-falsep x) (syn-truep x) t) nil nil nil nil) ((z y) nil nil nil (syn-if) nil nil) ((x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-not (nil nil nil nil nil (cond) nil) (nil nil ((syn-falsep x) (syn-truep x) (and (consp x) (consp (cdr x)) (equal (car x) (quote not))) t) nil nil nil nil) ((syn-true syn-false) nil (cadr `) nil nil nil nil) ((x) nil (not) nil nil nil nil) (nil nil (,) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-lazy-ite (nil nil nil nil nil nil nil) (nil nil ((syn-falsep x) (syn-truep x) (equal y z) (and (syn-falsep y) (syn-truep z)) (and (syn-truep y) (syn-falsep z)) t) nil nil nil nil) ((z y y) nil (syn-not syn-not) nil (syn-if) nil nil) ((x x x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-conjoin (nil nil nil nil nil nil (cond)) (nil nil ((syn-falsep x) (syn-falsep y) (syn-truep y) (syn-truep x) t) nil nil nil nil) ((syn-false syn-false x y) nil nil nil (syn-if) nil nil) ((x y syn-false) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-and-fn (nil nil nil nil (if) nil nil) (nil nil (consp ` `) nil nil nil nil) ((args syn-true) nil nil (syn-conjoin) nil nil nil) (nil nil (, ,) nil nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((args) nil (cdr) nil nil nil nil) ((args) nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::syn-quote (nil nil (`) nil nil nil nil) (nil nil (quote) nil nil nil nil) (nil nil (,) nil nil nil nil) ((v) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::base-value (nil nil nil nil (mv) nil nil) ((syn-true term) nil (syn-quote) nil nil nil nil) ((:ignore) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::rec-value (nil nil nil nil (mv) nil nil) ((syn-false term) nil (syn-quote) nil nil nil nil) ((:ignore) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::pair-args-with-true (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((args) nil (recursive-call) (cons) nil nil nil) ((syn-true) nil (car cdr) nil nil nil nil) ((args args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::lift-base (nil nil nil (let) nil nil nil) (((vars (pair-args-with-true args))) nil nil (met) nil nil nil) (nil nil ((case base)) (let) nil nil nil) (((case (syn-not case))) nil nil (let) (lift-base-fn) nil nil) ((flist body vars (case (or case (syn-false)))) nil nil (mv) nil nil nil) ((case base) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::lift-recursion-guard (nil nil nil (met) nil nil nil) (nil nil ((case base)) nil (syn-lazy-if) nil nil) ((case body base) nil nil nil (lift-base) nil nil) ((flist body args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::value-pair (nil nil nil (list) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::duplo-spine (nil nil nil nil nil nil (cond)) (nil nil ((atom term) (acl2::quotep term) (member (car term) flist) (acl2::lambda-expr-p term) t) nil nil nil nil) (nil nil (`) (let met met met) nil nil nil) (((nterm (cdr (assoc term valist)))) nil (` (args nargs) ` (args nargs) (args nargs) `) (value-pair met) nil nil nil) (nil nil (, , (vars nvars)) (value-pair (, (car term)) let value-pair) (duplo-args duplo-args duplo-args) nil nil) ((term term flist valist flist valist (nbody (duplo-spine flist valist (lambda-body term))) flist valist) nil (, , cdr ,@ ,@ lambda-args cdr (, (car term)) (, (car term))) nil (duplo-args make-lambda-application) nil nil) ((term nterm term args nargs term flist valist nbody term) nil (lambda-formals ,@ ,@) (append append) nil nil nil)) (/coi/util/recursion-support.lisp::var-alist-rec (nil nil nil nil (if) nil nil) ((res) nil (endp) (let) nil nil nil) ((vars (res (acons (car vars) (symbol-fns::prefix prefix (car vars)) res))) nil nil nil nil (recursive-call) nil) ((prefix omit res) nil (cdr) nil nil nil nil) ((vars) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::var-alist (nil nil nil nil nil (var-alist-rec) nil) ((prefix vars vars nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::duplicate-defun (nil nil nil (let) nil nil nil) (((body (defun-body defun))) nil nil (met) nil nil nil) (nil nil ((doc decls body)) (let) nil nil nil) (((args (defun-args defun))) nil (decompose-defun-body) (let) nil nil nil) ((body (vars (term-vars body args))) nil nil (let) nil nil nil) (((valist (var-alist prefix vars))) nil nil nil (met) nil nil) (nil nil ((c1 b1) declare) (let) nil nil nil)) (/coi/util/recursion-support.lisp::congruence-induction-function (nil nil nil (let) nil nil nil) (nil nil ((body (defun-body defun))) (met) nil nil nil) (nil nil (fn (doc decls body)) (let) nil nil nil) (((measure (get-xarg-keys-from-decls :measure decls))) nil (defun-name decompose-defun-body) (let) nil nil nil) ((defun body (measure (and measure (` ((declare (xargs :measure (,@ measure)))))))) nil nil (let) nil nil nil) (((fn-induction (symbol-fns::suffix fn (quote -induction)))) nil nil (let) nil nil nil) (((body (replace-function-names (` ((, fn))) (quote -induction) body))) nil nil (let) nil nil nil)) (/coi/util/recursion-support.lisp::prefix-list (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((list) nil nil (symbol-fns::prefix recursive-call) nil nil nil) ((prefix prefix) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/recursion-support.lisp::congruence-induction-reduction-proof (nil nil nil (let*) nil nil nil) (nil nil ((xargs (prefix-list (quote equiv-) args)) `) nil nil nil nil) (nil nil (fn-induction-to-fn) nil nil (defthm) nil) ((:hints) nil (, (Goal :in-theory (quote ((:rewrite val-value-pair) (:induction (, fn-induction)) (:definition (, fn-induction)) (:definition (, fn)))) :induct ((, fn-induction) (,@ args) (,@ xargs)))) (and) (symbol-fns::suffix) nil nil) ((fn-induction fn fn-induction-to-fn) nil (quote) (equal equal and) nil nil nil) ((-to- acl2::stable-under-simplificationp) nil ((, fn) (, fn) quote) (acl2::val acl2::val) nil nil nil) (nil (0 1) (,@ ,@ :in-theory) ((, fn-induction) (, fn-induction)) nil nil nil)))
(nil (/textbook/chap6/selected-solutions.lisp::natsp (nil nil nil nil (if) nil nil) ((t) nil (endp) nil (and) nil nil) ((x) nil (integerp recursive-call) (<=) nil nil nil) (nil (0) (car car cdr) nil nil nil nil) ((x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::prefix (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (endp (cdr x)) t) nil nil nil nil) ((nil nil) nil nil (cons) nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::lex (nil nil nil nil (if) nil nil) (nil (0) (endp) nil (if) nil nil) ((tuple) nil (endp 1+) (cons) nil nil nil) (nil nil (cdr car recursive-call car) nil nil nil nil) ((tuple tuple) nil (prefix last) nil nil nil nil) ((tuple tuple) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::lex-< (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (< (car x) (car y)) t) nil nil nil nil) ((nil t) nil nil (and) nil nil nil) (nil nil nil (equal recursive-call) nil nil nil) (nil nil (car car cdr cdr) nil nil nil nil) ((x y x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::lex-equal-hint (nil nil nil (cond) nil nil nil) (nil nil ((or (endp x) (endp y) (endp (cdr x)) (endp (cdr y))) t) nil nil nil nil) (nil nil nil (list recursive-call) nil nil nil) ((x y) nil (prefix prefix) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::upto (nil nil nil nil (if) nil nil) (nil (0) nil (+) (and) nil nil) (nil (1) (integerp integerp) (<= recursive-call) nil nil nil) ((i max i max max) nil nil (+) nil nil nil) ((i) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::g (nil nil nil nil (if) nil nil) ((j) nil (zp) nil (if) nil nil) ((i i) nil (zp) nil (if) nil nil) ((j) nil nil (< recursive-call recursive-call) nil nil nil) ((i j i j) nil nil (- -) nil nil nil) ((j i i j) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::mlen (nil nil nil nil (if) nil nil) (nil (0) nil (or +) nil nil nil) (nil (1) (consp consp) (recursive-call) nil nil nil) ((x y) nil (cdr cdr) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::flen (nil nil nil nil (if) nil nil) (nil (0) nil (equal +) nil nil nil) ((x nil) (1) (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::ack (nil nil nil nil (if) nil nil) (nil (1) (zp) nil (if) nil nil) ((x) nil (zp) (recursive-call) (if) nil nil) ((y) (2) (1-) (equal + recursive-call) nil nil nil) ((x x y y) (1 2) (1-) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil (recursive-call) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil (not) nil nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) ((t t) nil (recursive-call) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) ((t nil) nil (recursive-call) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) nil (/textbook/chap6/selected-solutions.lisp::f4-b ((nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f4-c (nil nil nil nil (if) nil nil) ((t nil) nil nil (equal) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) ((nil t) nil (recursive-call) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) (nil (0) (zp recursive-call) nil nil nil nil) ((x) nil nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f6 (nil nil nil nil (if) nil nil) (nil (0) (zp recursive-call) nil nil nil nil) ((x) nil nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) (nil (0) (zp recursive-call) nil nil nil nil) ((x) nil (recursive-call) nil nil nil nil) (nil nil nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((x) (1) (recursive-call) nil nil nil nil) (nil nil (recursive-call) nil nil nil nil) (nil nil nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((x) (2) (recursive-call) nil nil nil nil) (nil nil (recursive-call) nil nil nil nil) (nil nil nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f (nil nil nil nil (if) nil nil) (nil (0) (integerp) nil (*) nil nil) ((x x) nil (recursive-call recursive-call) nil nil nil nil) (nil nil nil (+ -) nil nil nil) ((x x) (1 1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap6/selected-solutions.lisp::f10-induction (nil nil nil nil (if) nil nil) ((x) nil (integerp) nil (if) nil nil) ((x) nil (recursive-call) (<) (if) nil nil) ((x x) (0) (recursive-call) (+ <) nil nil nil) ((x x) (1 0) nil (-) nil nil nil) ((x) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)))
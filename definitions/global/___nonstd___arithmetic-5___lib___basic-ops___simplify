((/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::simplify-terms-such-as-ax+bx-rel-0-fn (nil nil nil nil (if) nil nil) ((nil) nil nil (eq let) nil nil nil) (((common-factors (common-factors (factors (arg1 sum)) (arg2 sum)))) nil (fn-symb quote) nil (if) nil nil) ((sum BINARY-+ common-factors nil) nil nil (let) nil nil nil) (nil nil ((common (make-product common-factors))) (list) nil nil nil) (nil nil (remainder) (cons cons) nil nil nil) ((common remainder) nil (quote quote) (remainder) nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::addend-val (nil nil nil nil nil nil (cond)) (nil nil ((variablep addend) (constant-p addend) (eq (ffn-symb addend) (quote UNARY--)) (and (eq (ffn-symb addend) (quote BINARY-*)) (constant-p (arg1 addend))) t) nil nil nil nil) (nil nil (recursive-call) (let let) (list list) nil nil) (((val (unquote addend)) (val (unquote (arg1 addend)))) (0 1 0 0 1 0) (arg1) nil (if if) nil nil) ((addend) nil (rationalp rationalp) nil (list list list list) nil nil) ((val val) (0 0 0 0 1 0 0 1 0 0) (abs abs) nil nil nil nil) ((val val) nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::addend-info-entry (nil nil nil nil (list) nil nil) ((x) nil (addend-pattern addend-val) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::addend-info-list (nil nil nil nil (if) nil nil) (nil nil (list) (eq cons) nil nil nil) (nil nil (fn-symb quote addend-info-entry recursive-call addend-info-entry) nil nil nil nil) ((x BINARY-+ x) nil (arg1 arg2) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::assoc-addend (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-addend-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::first-match-in-addend-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-addend (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-sums (negate-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-sums (negate-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-matching-addends (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (addend-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-addend-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (addend-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::negative-addend-p (nil nil nil (or) nil nil nil) (nil nil nil (and) (and) nil nil) (nil nil (rational-constant-p) (eq or eq <) nil nil nil) (nil (0) (fn-symb quote variablep not fn-symb quote arg1 unquote) nil nil nil nil) ((x UNARY-- x BINARY-* x) nil (arg1 arg1) (equal) nil nil nil) ((x x) nil (ffn-symb quote) nil nil nil nil) ((UNARY--) nil (arg1) nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-negative-addend1 (nil nil nil nil nil nil (cond)) (nil nil ((not (eq (fn-symb x) (quote BINARY-+))) (and (negative-addend-p (arg1 x)) (stable-under-rewriting-sums (negate-match (arg1 x)) mfc state)) (eq (fn-symb (arg2 x)) (quote BINARY-+)) (and (negative-addend-p (arg2 x)) (stable-under-rewriting-sums (negate-match (arg2 x)) mfc state)) t) nil nil nil nil) ((nil) nil (list list) nil (if recursive-call) nil nil) ((nil mfc state) nil (list arg2) (and cons cons) nil nil nil) ((x) nil (negative-addend-p quote negate-match quote negate-match) (cons) (stable-under-rewriting-sums) nil nil) ((x mfc state x x) nil (negate-match quote negate-match arg1 arg2) nil nil nil nil) ((x x x x x) nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-negative-addend (nil nil nil (let) nil nil nil) (((temp1 (find-negative-addend1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-negative-addend1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents2 (nil nil nil nil nil nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY--)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let) (recursive-call if) nil (cond)) ((mfc state nil (temp (find-divisive-factor-scatter-exponents2 (arg1 x) mfc state))) nil (arg1 list (eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (consp (cdr (arg1 x))) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) nil (stable-under-rewriting-products if) nil nil) ((x mfc state nil temp temp) nil (invert-match) (cons) (if if if if recursive-call) nil nil) ((x nil nil nil nil mfc state) nil (quote invert-match list list list list arg2) nil (stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products) nil nil) ((x x mfc state mfc state mfc state mfc state x) nil (invert-match invert-match invert-match invert-match) (cons cons cons cons) nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (let) (find-divisive-factor-scatter-exponents2) nil nil) (((temp (find-divisive-factor-scatter-exponents2 (arg1 x) mfc state)) x mfc state) nil nil nil (if) nil nil) ((temp temp) nil nil nil (recursive-call) nil nil) ((mfc state) nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-divisive-factor-scatter-exponents1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-divisive-factor-scatter-exponents1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents2 (nil nil nil nil nil nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY--)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let) (recursive-call if) nil (cond)) ((mfc state nil (temp (find-rational-divisive-factor-scatter-exponents2 (arg1 x) mfc state))) nil (arg1 list (eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (consp (cdr (arg1 x))) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) (and) (if) nil nil) ((x nil temp temp) nil nil (cons) (stable-under-rewriting-products if if if if recursive-call) (proveably-real/rational) nil) ((mfc state mfc state nil nil nil nil mfc state) nil (quote ` invert-match quote invert-match list list list list arg2) (and and and and) nil nil nil) ((x (x , x) x x x x) nil nil (cons cons cons cons) (stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products) (proveably-real/rational proveably-real/rational proveably-real/rational proveably-real/rational) nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (let) (find-rational-divisive-factor-scatter-exponents2) nil nil) (((temp (find-rational-divisive-factor-scatter-exponents2 (arg1 x) mfc state)) x mfc state) nil nil nil (if) nil nil) ((temp temp) nil nil nil (recursive-call) nil nil) ((mfc state) nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/nonstd/arithmetic-5/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-rational-divisive-factor-scatter-exponents1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-rational-divisive-factor-scatter-exponents1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
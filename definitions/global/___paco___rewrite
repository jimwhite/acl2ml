((/paco/rewrite.lisp::strip-branches (nil nil nil nil nil (cond) nil) (nil nil ((variablep term) (fquotep term) (eq (ffn-symb term) (quote IF)) t) nil nil nil nil) (nil nil nil (cons cond let* cons) nil nil nil) ((clauses clauses) nil ((equal term *t*) t (test (fargn term 1))) (revappend revappend) (recursive-call) nil nil) ((nil clauses clauses nil) nil (clauses) (cons cons fargn cons cons) nil nil nil) ((term clause clauses term test clause term clause) (3) nil (revappend) (recursive-call) nil nil) ((clause nil clauses) nil nil (fargn cons) nil nil nil)) (/paco/rewrite.lisp::clausify (nil nil nil nil (strip-branches) nil nil) ((nil nil) nil nil nil nil nil (normalize)) ((term t nil ens wrld) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::if-tautologyp (nil nil nil (equal) nil nil nil) ((*t*) nil nil nil nil nil (normalize)) ((term t nil ens wrld) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::smallest-term (nil nil nil nil (cond) nil nil) (nil nil ((endp terms) (term-order (car terms) term) t) nil nil nil nil) ((term) nil nil (recursive-call recursive-call) nil nil nil) ((term) nil (car cdr cdr) nil nil nil nil) ((terms terms terms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::find-smallest-equal-term (nil nil nil nil (cond) nil nil) (nil nil ((endp type-alist) (and (ts= (cdr (car type-alist)) *ts-t*) (nvariablep (car (car type-alist))) (eq (ffn-symb (car (car type-alist))) (quote EQUAL))) t) nil nil nil nil) (nil nil nil (smallest-term let) (recursive-call) nil nil) ((term eterms term eterms) nil ((arg1 (fargn (car (car type-alist)) 1)) cdr) nil nil nil (cond)) ((type-alist) nil (arg2 (equal term arg1) (equal term arg2) (member-equal arg1 eterms) (member-equal arg2 eterms) t) nil nil nil nil) (nil nil nil (fargn) (recursive-call recursive-call recursive-call recursive-call recursive-call) nil nil) ((term term term term term eterms) (2) (car cdr cdr cdr cdr cdr) (cons cons cons cons) nil nil nil)) (/paco/rewrite.lisp::rewrite-solidify (nil nil nil (cond) nil nil nil) (nil nil ((quotep term) t) nil nil nil nil) (nil nil nil (let) (cond) nil nil) (((ts (type-set term type-alist nil ens wrld *type-set-nnn*))) nil ((equal term *nil*) iff-flg t) nil nil nil (cond)) ((*nil* *t* term) nil ((ts= ts *ts-t*) (ts= ts *ts-nil*) (and iff-flg (not (ts-intersectp ts *ts-nil*))) (ts= ts *ts-zero*) t) nil nil nil nil) ((*t* *nil* *t* *0*) nil nil nil (find-smallest-equal-term) nil nil) ((term type-alist nil) nil nil nil nil nil nil)) (/paco/rewrite.lisp::loop-stopperp-rec (nil nil nil (cond) nil nil nil) (nil nil ((endp loop-stopper) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (nil nil ((pre (cdr (assoc-eq (car (car loop-stopper)) unify-subst)))) (cond) nil nil nil) (nil nil (post (equal pre post) t) nil nil nil nil) (nil nil (cdr) (recursive-call term-order) nil nil nil) ((unify-subst post pre) nil (cdr) (assoc-eq) nil nil nil)) (/paco/rewrite.lisp::loop-stopperp (nil nil nil (or) nil nil nil) (nil nil (null) (loop-stopperp-rec) nil nil nil) ((loop-stopper loop-stopper unify-subst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::member-equal-mod-alist (nil nil nil nil (cond) nil nil) (nil nil ((endp term2-lst) (equal-mod-alist term1 alist1 (car term2-lst)) t) nil nil nil nil) ((nil t) nil nil nil (recursive-call) nil nil) ((term1 alist1) nil (cdr) nil nil nil nil) ((term2-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::not-to-be-rewrittenp1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (equal fn (ffn-symb (car lst))) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((fn) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::not-to-be-rewrittenp (nil nil nil (cond) nil nil nil) (nil nil ((not-to-be-rewrittenp1 (ffn-symb term) terms-to-be-ignored-by-rewrite) t) nil nil nil nil) ((nil) nil nil nil (member-equal-mod-alist) nil nil) ((term alist terms-to-be-ignored-by-rewrite) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::ev-synp (nil nil nil (let*) nil nil nil) (((unify-subst1 (if mfc (cons (cons (quote mfc) mfc) unify-subst) unify-subst))) nil nil nil (eval) nil nil) ((unify-subst1 wrld) nil (cadr) nil nil nil nil) ((synp-term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::tautologyp (nil nil nil (let) nil nil nil) (((fns (quote (if iff not implies eq atom eql = /= null zerop synp plusp minusp listp prog2$ force case-split)))) nil nil nil (if) nil nil) (nil nil nil (ffnnamesp equal) (if-tautologyp) nil nil) ((fns term ens wrld *t*) nil nil nil (expand-some-non-rec-fns) nil nil) ((term wrld term t nil ens wrld t) nil (cdr) nil nil nil nil) ((fns) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::refinementp (nil nil nil nil (if) nil nil) ((iff-flg) nil nil (or eq) nil nil nil) ((equiv) nil (quote) (eq eq) nil nil nil) ((equiv equiv equal) nil (quote quote) nil nil nil nil) ((equal iff) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::being-openedp-rec (nil nil nil nil (cond) nil nil) (nil nil ((endp fnstack) (consp (car fnstack)) t) nil nil nil nil) ((nil) nil nil (or or) nil nil nil) (nil nil nil (eq recursive-call eq recursive-call) nil nil nil) ((fn fn fn fn) nil (caar cdr car cdr) nil nil nil nil) ((fnstack fnstack fnstack fnstack) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::recursive-fn-on-fnstackp (nil nil nil nil (cond) nil nil) (nil nil ((endp fnstack) (and (consp (car fnstack)) (not (eq (caar fnstack) :term))) t) nil nil nil nil) ((nil t) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((fnstack) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::some-fnstack-term-dumb-occur (nil nil nil nil (cond) nil nil) (nil nil ((endp fnstack) (and (consp (car fnstack)) (eq (caar fnstack) :term) (dumb-occur (cdar fnstack) term)) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((term) nil (cdr) nil nil nil nil) ((fnstack) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::occur-cnt (nil nil nil nil (occur-cnt-rec) nil nil) ((term1 term2) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::too-many-ifs1 (nil nil nil (cond) nil nil nil) (nil nil ((endp args) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((x (count-ifs (car args)))) nil nil (cond) nil nil nil) (nil nil ((int= x 0) t) nil nil nil nil) (nil nil nil (let) nil (recursive-call) nil) ((val lhs rhs (lhs (+ lhs (* x (occur-cnt (car args) val))))) nil (cdr) (cond) nil nil nil)) (/paco/rewrite.lisp::too-many-ifs (nil nil nil (let) nil nil nil) (((rhs (count-ifs-lst args))) nil nil (cond) nil nil nil) (nil nil ((int= rhs 0) t) nil nil nil nil) ((nil) nil nil nil nil (too-many-ifs1) nil) ((args val rhs) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::all-args-occur-in-top-clausep (nil nil nil (cond) nil nil nil) (nil nil ((endp args) t) nil nil nil nil) ((t) nil nil (and) nil nil nil) (nil nil nil (dumb-occur-lst recursive-call) nil nil nil) ((top-clause top-clause) nil (car cdr) nil nil nil nil) ((args args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::cons-count-ac (nil nil nil (cond) nil nil nil) (nil nil ((atom x) t) nil nil nil nil) ((i) nil nil (recursive-call) nil nil nil) (nil nil (cdr) (recursive-call) nil nil nil) ((x) nil (car 1+) nil nil nil nil) ((x i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::cons-count (nil nil nil (cons-count-ac) nil nil nil) ((x) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::controller-complexity1 (nil nil nil nil (cond) nil nil) (nil nil ((endp args) (eq (car controller-pocket) flg) t) nil nil nil nil) (nil (0) nil (+) (recursive-call) nil nil) ((flg) nil (max-form-count cdr cdr) nil (recursive-call) nil nil) ((flg args controller-pocket) nil (car cdr cdr) nil nil nil nil) ((args args controller-pocket) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::controller-complexity (nil nil nil nil (controller-complexity1) nil nil) ((flg) nil (fargs cdr) nil nil nil nil) ((term) nil nil (assoc-eq) nil nil nil) ((controller-alist) nil (ffn-symb) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::some-controller-pocket-simplerp (nil nil nil nil (cond) nil nil) (nil nil ((endp controller-alists) (< (controller-complexity t result (car controller-alists)) (controller-complexity t call (car controller-alists))) t) nil nil nil nil) ((nil t) nil nil nil (recursive-call) nil nil) ((call result) nil (cdr) nil nil nil nil) ((controller-alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::constant-controller-pocketp1 (nil nil nil nil (cond) nil nil) (nil nil ((endp args) (car controller-pocket) t) nil nil nil nil) ((t) nil nil (and recursive-call) nil nil nil) (nil nil (quotep cdr cdr) (recursive-call) nil nil nil) ((args controller-pocket) nil (car cdr cdr) nil nil nil nil) ((args args controller-pocket) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::constant-controller-pocketp (nil nil nil (constant-controller-pocketp1) nil nil nil) (nil nil (fargs cdr) nil nil nil nil) ((term) nil nil (assoc-eq) nil nil nil) ((controller-alist) nil (ffn-symb) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::some-controller-pocket-constant-and-non-controller-simplerp (nil nil nil nil (cond) nil nil) (nil nil ((endp controller-alists) (and (constant-controller-pocketp result (car controller-alists)) (< (controller-complexity nil result (car controller-alists)) (controller-complexity nil call (car controller-alists)))) t) nil nil nil nil) ((nil t) nil nil nil (recursive-call) nil nil) ((call result) nil (cdr) nil nil nil nil) ((controller-alists) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::free-p (nil nil nil (and) nil nil nil) (nil nil (consp) (eq) nil nil nil) ((x :free) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::expand-permission-p (nil nil nil nil (if) nil nil) ((nil) nil (endp) (or) nil nil nil) ((expand-lst) nil nil (let recursive-call) nil nil nil) (((x (car expand-lst)) term) nil (cdr) (or) nil nil nil) ((expand-lst) nil nil (and) (if) nil nil) (nil nil (flambda-applicationp free-p) (eq equal) nil (mv-let) nil) ((x :LAMBDAS term x flg x term) nil (flg declare) nil (one-way-unify1) nil nil)) (/paco/rewrite.lisp::plist-to-alist (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) (cons) nil nil nil) (nil nil (car cadr cddr) nil nil nil nil) ((lst lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/rewrite.lisp::add-rewrite-args (nil nil nil (cond) nil nil nil) (nil nil ((endp extra-formals) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (let) (recursive-call) nil nil) (((pair (assoc-eq (car keyword-extra-formals) alist)) alist) nil (cdr cdr) (cond) nil nil nil) ((extra-formals keyword-extra-formals) nil (pair t) nil nil nil nil) (nil nil (cdr car) nil nil nil nil)))
((/paco/utilities.lisp::rev (nil nil nil nil (if) nil nil) ((nil) nil (endp) (append) nil nil nil) ((x) nil (recursive-call list) nil nil nil nil) (nil nil (cdr car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::alistp (nil nil nil (cond) nil nil nil) (nil nil ((atom l) t) nil nil nil nil) (nil nil nil (eq and) nil nil nil) ((l nil) nil (consp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::symbol-alistp (nil nil nil (cond) nil nil nil) (nil nil ((atom x) t) nil nil nil nil) (nil nil nil (eq) (and) nil nil) ((x nil) nil (consp symbolp recursive-call) nil nil nil nil) (nil nil (car car cdr) nil nil nil nil) ((x x) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/paco/utilities.lisp::assoc-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (eq x (car (car alist))) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((alist x) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::assoc-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (equal x (car (car alist))) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((alist x) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::member-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (equal x (car lst)) t) nil nil nil nil) ((nil lst) nil nil (recursive-call) nil nil nil) ((x) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::keyword-value-listp (nil nil nil (cond) nil nil nil) (nil nil ((atom l) t) nil nil nil nil) (nil nil (null) nil (and) nil nil) ((l) nil (keywordp consp recursive-call) nil nil nil nil) (nil nil (car cdr cddr) nil nil nil nil) ((l l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::evens (nil nil nil (cond) nil nil nil) (nil nil ((endp l) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((l) nil (cddr) nil nil nil nil) ((l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::odds (nil nil (evens) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::symbol-listp (nil nil nil (cond) nil nil nil) (nil nil ((atom lst) t) nil nil nil nil) (nil nil nil (eq and) nil nil nil) ((lst nil) nil (symbolp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::fix (nil nil nil nil (if) nil nil) ((x) (0) (acl2-numberp) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::character-listp (nil nil nil (cond) nil nil nil) (nil nil ((atom l) t) nil nil nil nil) (nil nil nil (equal and) nil nil nil) ((l nil) nil (characterp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-character-list (nil nil nil nil (cond) nil nil) (nil nil ((atom x) (characterp (car x)) t) nil nil nil nil) ((nil) nil nil (cons cons) nil nil nil) (nil nil (car recursive-call code-char recursive-call) nil nil nil nil) ((x) (0) (cdr cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::member-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (eq x (car lst)) t) nil nil nil nil) ((nil lst) nil nil (recursive-call) nil nil nil) ((x) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::union-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp lst1) (member-eq (car lst1) lst2) t) nil nil nil nil) ((lst2) nil nil (recursive-call cons) nil nil nil) ((lst2) nil (cdr car) (recursive-call) nil nil nil) ((lst1 lst1 lst2) nil (cdr) nil nil nil nil) ((lst1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::add-to-set-eq (nil nil nil (cond) nil nil nil) (nil nil ((member-eq x lst) t) nil nil nil nil) ((lst) nil nil (cons) nil nil nil) ((x lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::subst-for-nth (nil nil nil (cond) nil nil nil) (nil nil ((zp n) t) nil nil nil nil) (nil nil nil (cons cons) nil nil nil) ((new) nil (cdr car) nil (recursive-call) nil nil) ((lst lst new) nil (1- cdr) nil nil nil nil) ((n lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::no-duplicatesp-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp l) (member-equal (car l) (cdr l)) t) nil nil nil nil) ((t nil) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::set-difference-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp l1) (member-eq (car l1) l2) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((l2) nil (cdr car) (recursive-call) nil nil nil) ((l1 l1 l2) nil (cdr) nil nil nil nil) ((l1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::subsetp-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (member-eq (car x) y) t) nil nil nil nil) ((t nil) nil nil (recursive-call) nil nil nil) ((y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::set-difference-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp l1) (member-equal (car l1) l2) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((l2) nil (cdr car) (recursive-call) nil nil nil) ((l1 l1 l2) nil (cdr) nil nil nil nil) ((l1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::intersectp-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (member-eq (car x) y) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::subsetp-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (member-equal (car x) y) t) nil nil nil nil) ((t nil) nil nil (recursive-call) nil nil nil) ((y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::add-to-set-equal (nil nil nil (cond) nil nil nil) (nil nil ((member-equal x l) t) nil nil nil nil) ((l) nil nil (cons) nil nil nil) ((x l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::union-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (member-equal (car x) y) t) nil nil nil nil) ((y) nil nil (recursive-call cons) nil nil nil) ((y) nil (cdr car) (recursive-call) nil nil nil) ((x x y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::intersection-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp l1) (member-eq (car l1) l2) t) nil nil nil nil) ((nil) nil nil (cons recursive-call) nil nil nil) ((l2) nil (car cdr) (recursive-call) nil nil nil) ((l1 l2 l1) nil (cdr) nil nil nil nil) ((l1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::delete1-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (eq x (car lst)) t) nil nil nil nil) ((nil) nil (cdr) (cons) nil nil nil) ((lst) nil (car) (recursive-call) nil nil nil) ((lst x) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::delete1-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (equal x (car lst)) t) nil nil nil nil) ((nil) nil (cdr) (cons) nil nil nil) ((lst) nil (car) (recursive-call) nil nil nil) ((lst x) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::delete-assoc-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (eq key (caar alist)) t) nil nil nil nil) ((nil) nil (cdr) (cons) nil nil nil) ((alist) nil (car) (recursive-call) nil nil nil) ((alist key) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::strip-cadrs (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (cadar recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::remove-duplicates-equal (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (member-equal (car x) (cdr x)) t) nil nil nil nil) ((nil) nil (recursive-call) (cons) nil nil nil) (nil nil (cdr car recursive-call) nil nil nil nil) ((x x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::all-but-last (nil nil nil nil (cond) nil nil) (nil nil ((endp l) (endp (cdr l)) t) nil nil nil nil) ((nil nil) nil nil (cons) nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((l) nil (cdr) nil nil nil nil) ((l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::last (nil nil nil nil (if) nil nil) ((l) nil (atom recursive-call) nil nil nil nil) (nil nil (cdr cdr) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::symbol-< (nil nil nil (let) nil nil nil) (nil nil ((x1 (symbol-name x))) (or) nil nil nil) (nil nil (y1) (string< and) nil nil nil) ((x1 y1) nil (symbol-name) (equal string<) nil nil nil) ((y x1 y1) nil (symbol-package-name symbol-package-name) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::alphorder (nil nil nil nil nil nil nil) (nil nil ((rationalp x) (rationalp y) (complex-rationalp x) (complex-rationalp y) (characterp x) (characterp y) (stringp x) (stringp y) t) nil nil nil nil) ((nil nil nil nil) nil nil (cond cond cond cond) (cond) nil nil) (nil nil ((rationalp y) t (complex-rationalp y) t (characterp y) t (stringp y) t (symbolp x) (symbolp y) t) nil nil nil nil) ((t t t t nil) nil nil (<= or <= and cond acl2::bad-atom<=) nil nil nil) ((x y t x y) nil (char-code char-code (symbolp y) t) (< and string<=) nil nil nil) ((x y x y t) nil (realpart realpart not) (= <=) nil nil nil)) (/paco/utilities.lisp::lexorder (nil nil nil nil nil (cond) nil) (nil nil ((atom x) (atom y) (equal (car x) (car y)) t) nil nil nil nil) ((nil) nil nil (cond recursive-call recursive-call) nil nil nil) (nil nil ((atom y) t cdr cdr car car) nil nil nil nil) ((t x y x y) nil nil (alphorder) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::kwote (nil nil nil (list) nil nil nil) ((x) nil (quote) nil nil nil nil) ((quote) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::enni (nil nil nil (cond) nil nil nil) (nil nil ((zp n) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (digit-to-char recursive-call) nil nil nil nil) (nil nil nil (mod floor) nil nil nil) ((n n) (10 10) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::enni-induct (nil nil nil nil (cond) nil nil) (nil nil ((zp i) (zp j) t) nil nil nil nil) ((nil nil) nil nil (recursive-call) nil nil nil) (nil nil nil (floor floor) nil nil nil) ((i j) (10 10) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::double-cdr-hint (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (endp y) t) nil nil nil nil) ((t t) nil nil (recursive-call) nil nil nil) (nil nil (cdr cdr) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::packn1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (append) nil nil nil) (nil nil (explode-atom recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::packn (nil nil nil (intern) nil nil nil) ((ACL2) nil nil (coerce) nil nil nil) (nil nil (packn1 quote) nil nil nil nil) ((lst string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::record-maker-function-name (nil nil nil (intern-in-package-of-symbol) nil nil nil) ((name) nil nil (coerce) nil nil nil) (nil nil (quote) nil (append) nil nil) ((string) nil nil (coerce coerce coerce) nil nil nil) ((Make   record) nil (quote symbol-name quote quote) nil nil nil nil) ((list name list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::record-accessor-function-name (nil nil nil (intern-in-package-of-symbol) nil nil nil) ((name) nil nil (coerce) nil nil nil) (nil nil (quote) nil nil (append) nil) ((string) nil nil (coerce coerce coerce coerce) nil nil nil) ((Access   record field ) nil (quote symbol-name quote quote symbol-name quote) nil nil nil nil) ((list name list list field list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::record-changer-function-name (nil nil nil (intern-in-package-of-symbol) nil nil nil) ((name) nil nil (coerce) nil nil nil) (nil nil (quote) nil (append) nil nil) ((string) nil nil (coerce coerce coerce) nil nil nil) ((Change   record fields) nil (quote symbol-name quote quote) nil nil nil nil) ((list name list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-car-cdrs1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((var) nil nil (list) nil nil nil) (nil nil (car) (recursive-call) nil nil nil) ((lst var) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-car-cdrs (nil nil nil (cond) nil nil nil) (nil nil ((atom field-layout) t) nil nil nil nil) (nil nil nil (cond append) nil nil nil) (nil nil ((null field-layout) t) (recursive-call recursive-call) nil nil nil) ((nil) nil (list car cdr) (cons cons) nil nil nil) ((field-layout car-cdr-lst field-layout car-cdr-lst) nil (quote quote) (make-record-car-cdrs1) nil nil nil) ((car-cdr-lst car cdr) nil (quote) nil nil nil nil)) (/paco/utilities.lisp::make-record-accessors (nil nil nil (cond) nil nil nil) (nil nil ((endp field-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil (recursive-call) (list) nil) ((name) nil (quote quote ` cdr cdr) (record-accessor-function-name) nil nil nil) ((defmacro name record field-lst car-cdrs) nil (car) nil (list) nil nil) ((field-lst) nil (quote list quote) nil nil nil nil)) (/paco/utilities.lisp::symbol-name-tree-occur (nil nil nil nil (cond) nil nil) (nil nil ((symbolp sym-tree) (atom sym-tree) t) nil nil nil nil) ((nil) nil nil (cond or) nil nil nil) (nil nil ((equal (symbol-name sym) (symbol-name sym-tree)) t) (recursive-call recursive-call) nil nil nil) ((sym-tree nil sym sym) nil (car cdr) nil nil nil nil) ((sym-tree sym-tree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::some-symbol-name-tree-occur (nil nil nil nil (cond) nil nil) (nil nil ((endp syms) (symbol-name-tree-occur (car syms) sym-tree) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((sym-tree) nil (cdr) nil nil nil nil) ((syms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-changer-cons (nil nil nil nil (cond) nil nil) (nil nil ((not (some-symbol-name-tree-occur fields field-layout)) (atom field-layout) t) nil nil nil nil) ((x field-layout) nil nil nil (list) nil nil) (nil nil (quote) nil (recursive-call recursive-call) nil nil) ((cons fields fields) nil (car cdr) (list list) nil nil nil) ((field-layout x field-layout x) nil (quote quote) nil nil nil nil) ((car cdr) nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-changer-let-bindings (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((var (symbol-name-tree-occur (car lst) field-layout))) nil nil (cons) nil nil nil) (nil nil nil (list recursive-call) nil nil nil) ((var field-layout) nil (cadr cddr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-changer-let (nil nil nil nil (list) nil nil) (nil nil (quote) (cons) (make-record-changer-cons) nil nil) ((let field-layout) nil (evens quote) (list make-record-changer-let-bindings) nil nil nil) ((rec field-layout lst lst record-changer-not-to-be-used-elsewhere) nil (quote) nil nil nil nil) ((record-changer-not-to-be-used-elsewhere) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-changer (nil nil nil nil nil (list) nil) (nil nil (quote record-changer-function-name quote) nil nil nil (list)) ((defmacro name) nil (&rest quote kwote kwote quote quote) nil nil nil nil) ((args make-record-changer-let name field-layout) nil (car cdr) nil nil nil nil) ((args args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-maker-cons (nil nil nil (cond) nil nil nil) (nil nil ((atom field-layout) t) nil nil nil nil) (nil nil nil (cond) (list) nil nil) (nil nil ((some-symbol-name-tree-occur fields field-layout) t quote) (recursive-call recursive-call) nil nil nil) ((field-layout nil cons fields fields) nil (car cdr) nil nil nil nil) ((field-layout field-layout) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-maker-let (nil nil nil nil (list) nil nil) (nil nil (quote) (make-record-changer-let-bindings make-record-maker-cons) nil nil nil) ((let field-layout lst field-layout) nil (evens) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-maker (nil nil nil nil nil (list) nil) (nil nil (quote record-maker-function-name quote) nil nil (list) nil) ((defmacro name) nil (&rest quote kwote kwote quote) nil nil nil nil) ((args make-record-maker-let name field-layout args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::make-record-field-lst (nil nil nil (cond) nil nil nil) (nil nil ((atom field-layout) t) nil nil nil nil) (nil nil nil (cond append) nil nil nil) (nil nil ((null field-layout) t recursive-call recursive-call) nil nil nil nil) ((nil) nil (list car cdr) nil nil nil nil) ((field-layout field-layout field-layout) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::record-macros (nil nil nil (cons) nil nil nil) (nil nil (quote) (append) nil nil nil) ((progn) nil nil (list) (make-record-accessors) nil nil) ((name) nil (make-record-field-lst) (make-record-car-cdrs make-record-changer make-record-maker) nil nil nil) ((field-layout field-layout nil name field-layout name field-layout) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::worldp (nil nil nil (cond) nil nil nil) (nil nil ((atom alist) t) nil nil nil nil) (nil nil nil (eq) nil nil (and)) ((alist nil) nil (consp symbolp consp symbolp recursive-call) nil nil nil nil) (nil nil (car car cdr cadr cdr) nil nil nil nil) ((alist alist) nil (car car car) nil nil nil nil) ((alist alist alist) nil nil nil nil nil nil)) (/paco/utilities.lisp::global-val (nil nil nil nil nil (getprop) nil) ((symb nil alist) nil (quote) nil nil nil nil) ((global-value) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::in-btreep (nil nil nil nil nil (cond) nil) (nil nil ((atom btree) (< n (car btree)) (> n (car btree)) t) nil nil nil nil) ((t) nil nil (equal recursive-call recursive-call) nil nil nil) ((n btree n n) nil (cadr cddr) nil nil nil nil) ((btree btree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::btree-contents (nil nil nil (cond) nil nil nil) (nil nil ((atom btree) t) nil nil nil nil) (nil nil nil (append) (if) nil nil) ((nil) nil (null list recursive-call) (cons) nil nil nil) ((btree btree) nil (cadr car recursive-call) nil nil nil nil) ((btree btree) nil (cddr) nil nil nil nil) ((btree) nil nil nil nil nil nil)) (/paco/utilities.lisp::merge-ascending (nil nil nil nil nil (cond) nil) (nil nil ((endp l1) (endp l2) (<= (car l1) (car l2)) t) nil nil nil nil) ((l2 l1) nil nil (cons cons) nil nil nil) (nil nil (car car) (recursive-call recursive-call) nil nil nil) ((l1 l2 l2 l1) nil (cdr cdr) nil nil nil nil) ((l1 l2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::merge-sort-ascending (nil nil nil (cond) nil nil nil) (nil nil ((endp (cdr l)) t) nil nil nil nil) ((l) nil nil (merge-ascending) nil nil nil) (nil nil (recursive-call recursive-call) nil nil nil nil) (nil nil (evens odds) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::find-pivot1 (nil nil nil (cond) nil nil nil) (nil nil ((endp (cdr x)) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (car) (recursive-call) nil nil nil) ((lst) nil (cdr cddr) nil nil nil nil) ((lst x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::find-pivot2 (nil nil nil (cond) nil nil nil) (nil nil ((endp (cdr x)) t) nil nil nil nil) ((lst) nil nil (recursive-call) nil nil nil) (nil nil (cdr cddr) nil nil nil nil) ((lst x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/utilities.lisp::find-pivot (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (endp (cdr lst)) t) nil nil nil nil) (nil nil nil (let) (mv mv) nil nil) ((nil nil nil nil nil) nil (car (lst1 (find-pivot1 lst lst))) nil (mv) nil nil) ((lst lst1) nil (lst2 car cdr) nil nil nil nil) ((lst2 lst2) nil nil (find-pivot2) nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/utilities.lisp::make-btree1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (endp (cdr lst)) t) nil nil nil nil) ((nil) nil (car) nil (mv-let) nil nil) ((lst) nil (find-pivot) (lst1 cons) nil nil nil) ((n lst2 lst n) nil nil (cons) nil nil nil) (nil nil (recursive-call recursive-call) nil nil nil nil) ((lst1 lst2) nil nil nil nil nil nil)) (/paco/utilities.lisp::make-btree (nil nil (make-btree1) nil nil nil nil) (nil nil (merge-sort-ascending) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
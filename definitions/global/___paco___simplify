((/paco/simplify.lisp::split-on-assumptions (nil nil nil (cond) nil nil nil) (nil nil ((endp assumptions) t) nil nil nil nil) ((ans) nil nil nil (recursive-call) nil nil) ((cl) nil (cdr) (conjoin-clause-to-clause-set) nil nil nil) ((assumptions ans) nil nil nil (add-literal) nil nil) ((cl nil) nil (car) nil nil nil nil) ((assumptions) nil nil nil nil nil nil)) (/paco/simplify.lisp::rewrite-clause-action (nil nil nil (cond) nil nil nil) (nil nil ((consp branches) t) nil nil nil nil) (nil nil (quote) (cond) nil nil nil) ((shown-true) nil ((null (cdr branches)) t) nil nil nil nil) (nil nil (quote) nil (cond) nil nil) ((change) nil ((null (car branches)) (and (null (cdr (car branches))) (equal lit (car (car branches)))) t) nil nil nil nil) (nil nil (quote quote quote) nil nil nil nil)) (/paco/simplify.lisp::rewrite-clause-type-alist (nil nil nil nil nil (type-alist-clause) nil) ((nil ens wrld) nil nil (append) nil nil nil) ((new-clause) nil (cdr) nil nil nil nil) ((tail) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::rewrite-atm (nil nil nil nil (mv-let) nil nil) (nil nil (knownp) nil (cond) (known-whether-nil) nil) ((nilp atm type-alist wrld) nil ((and knownp not-flg nilp) (and knownp (not not-flg) (not nilp)) t) nil (access) nil nil) ((rewrite-constant rcnst :ens *nil* *t*) nil nil nil nil nil nil) ((:type-alist type-alist :obj :iff-flg t :wrld wrld :fnstack nil :ancestors nil :rcnst rcnst :nnn *rewrite-nnn*) nil (quote) (rewrite) nil nil nil) ((atm nil) (10) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::dumb-occurs-in-some-other-lit (nil nil nil nil nil (cond) nil) (nil nil ((endp cl) (int= n i) (dumb-occur term (car cl)) t) nil nil nil nil) ((nil t) nil nil nil nil (recursive-call recursive-call) nil) ((term n term n) nil (cdr 1+ cdr 1+) nil nil nil nil) ((cl i cl i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::find-trivial-equivalence1 (nil nil nil nil nil nil (cond)) (nil nil ((endp tail) (member-equal (car tail) avoid-lst) (quotep (car tail)) (or (variablep (car tail)) (and (eq (ffn-symb (car tail)) (quote NOT)) (and (nvariablep (fargn (car tail) 1)) (not (fquotep (fargn (car tail) 1))) (eq (ffn-symb (fargn (car tail) 1)) (quote EQUAL))))) t) nil nil nil nil) (nil nil nil (let*) (if) nil (mv recursive-call recursive-call)) ((nil nil nil nil nil not-just-quotep-flg cl avoid-lst not-just-quotep-flg cl avoid-lst) nil (cdr 1+ cdr 1+) (equal (atm (if (variablep (car tail)) (fcons-term* (quote equal) (car tail) *nil*) (fargn (car tail) 1)))) nil nil (recursive-call mv)) ((tail i *nil* not-just-quotep-flg cl avoid-lst nil nil nil nil nil tail i) nil (car cdr 1+ lhs rhs (and (quotep lhs) (quotep rhs)) (and not-just-quotep-flg (variablep lhs) (not (dumb-occur lhs rhs))) (and not-just-quotep-flg (variablep rhs) (not (dumb-occur rhs lhs))) (and (quotep rhs) (dumb-occurs-in-some-other-lit lhs i cl 0)) (and (quotep lhs) (dumb-occurs-in-some-other-lit rhs i cl 0)) t) nil nil nil nil) ((tail tail i) nil nil (fargn fargn cond) (if) nil (mv mv mv recursive-call)) ((atm atm i rhs lhs i lhs rhs i rhs lhs not-just-quotep-flg cl avoid-lst) (1 2) ((variablep rhs) t quote car quote car quote car cdr 1+) (equal) nil nil (recursive-call mv))) (/paco/simplify.lisp::find-trivial-equivalence (nil nil nil nil nil nil (find-trivial-equivalence1)) ((not-just-quotep-flg cl cl avoid-lst) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::subst-equiv-and-maybe-delete-lit (nil nil nil nil nil (cond) nil) (nil nil ((endp cl) (int= n i) (dumb-occur old (car cl)) t) nil nil nil nil) ((nil) nil nil (let let) nil (mv-let) nil) (((cl1 (subst-equiv-and-maybe-delete-lit new old n (cdr cl) (1+ i) delete-flg ens wrld)) (cl1 (subst-equiv-and-maybe-delete-lit new old n (cdr cl) (1+ i) delete-flg ens wrld))) nil (hitp declare) (cond let) (add-literal) nil (subst-equiv-expr)) ((lit new old ens wrld (cl1 (subst-equiv-and-maybe-delete-lit new old n (cdr cl) (1+ i) delete-flg ens wrld)) cl1 nil) nil (delete-flg t car ignore car) nil (add-literal) nil nil) ((cl1 cl hitp lit cl1 nil cl) nil nil nil (add-literal) nil nil) ((cl1 nil) nil (car) nil nil nil nil)) (/paco/simplify.lisp::remove-trivial-equivalences1 (nil nil nil nil (if) nil nil) (nil nil (zp) (mv) (mv-let) nil nil) ((nnn hitp cl) nil nil (cond) (find-trivial-equivalence) (condition) nil) ((lit-position lhs rhs lit remove-flg cl avoid-lst) nil (lit-position t) nil nil nil nil) (nil nil nil (let mv) nil nil nil) (((new-cl (subst-equiv-and-maybe-delete-lit rhs lhs lit-position cl 0 (and remove-flg (eq condition (quote disposable))) ens wrld)) hitp cl) nil nil nil nil nil nil) ((new-cl remove-flg ens wrld t) nil nil (cons -) nil nil nil)) (/paco/simplify.lisp::remove-trivial-equivalences (nil nil nil nil nil nil nil) ((cl remove-flg ens wrld hitp avoid-lst) nil (len) nil nil nil nil) ((cl) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::some-member-subsumes (nil nil nil nil (cond) nil nil) (nil nil ((endp cl-set) (subsumes (car cl-set) cl nil) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((cl) nil (cdr) nil nil nil nil) ((cl-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::built-in-clausep2 (nil nil nil nil (cond) nil nil) (nil nil ((endp bic-lst) (and (enabled-numep (access built-in-clause (car bic-lst) :nume) ens) (subsetp-eq (access built-in-clause (car bic-lst) :all-fnnames) fns) (subsumes (access built-in-clause (car bic-lst) :clause) cl nil)) t) nil nil nil nil) ((nil) nil (<built-in-clausep2-id>) nil nil (recursive-call) nil) ((t cl ens fns) nil (cdr) nil nil nil nil) ((bic-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::built-in-clausep1 (nil nil nil nil (cond) nil nil) (nil nil ((endp bic-alist) (or (null (caar bic-alist)) (member-eq (caar bic-alist) fns)) t) nil nil nil nil) ((nil) nil nil (or) nil (recursive-call) nil) ((cl ens fns) nil (cdr) nil nil (built-in-clausep2 recursive-call) nil) ((cl ens fns cl ens fns bic-alist) nil (cdr cdr) nil nil nil nil) ((bic-alist) nil (car) nil nil nil nil) ((bic-alist) nil nil nil nil nil nil)) (/paco/simplify.lisp::trivial-clause-p (nil nil nil (or) nil nil nil) (nil nil nil (member-equal) (tautologyp) nil nil) ((*t* cl ens wrld) nil (disjoin) nil nil nil nil) ((cl) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::built-in-clausep (nil nil nil (cond) nil nil nil) (nil nil ((trivial-clause-p cl ens wrld) t) nil nil nil nil) ((t) nil nil nil nil (built-in-clausep1) nil) ((cl ens) nil (all-fnnames-lst) (global-val) nil nil nil) ((wrld cl) nil (quote) nil nil nil nil) ((built-in-clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::crunch-clause-segments1 (nil nil nil (cond) nil nil nil) (nil nil ((endp seg1) t) nil nil nil nil) ((cl) nil nil (recursive-call) nil nil nil) (nil nil (cdr) nil (add-literal) nil nil) ((seg1 cl nil) nil (car) nil nil nil nil) ((seg1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::crunch-clause-segments2 (nil nil nil nil (cond) nil nil) (nil nil ((endp cl) (and (consp (car cl)) (eq (ffn-symb (car cl)) (quote car)) (eq (fargn (car cl) 1) :crunch-clause-segments-marker)) t) nil nil nil nil) (nil nil nil (mv mv recursive-call) nil nil nil) ((seg1 nil seg1) nil (cdr cdr) (cons) nil nil nil) ((cl cl seg1) nil (car) nil nil nil nil) ((cl) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::crunch-clause-segments (nil nil nil (let*) nil nil nil) (nil nil ((marker (quote (car :crunch-clause-segments-marker)))) nil (mv-let) nil nil) (nil nil (cl hitp) (cond) nil nil nil) ((cl cl nil ens wrld nil nil) nil ((null hitp) t) (crunch-clause-segments1) nil nil nil) ((seg1) nil nil (cons mv) (mv-let) nil nil) ((marker seg2 seg1 seg2) nil (seg1) (crunch-clause-segments2 mv) nil nil nil) ((seg2 cl nil seg1 seg2) nil nil nil nil nil nil)) (/paco/simplify.lisp::simplify-clause1 (nil nil nil nil (mv-let) nil nil) (nil nil (hitp) (let) nil nil nil) ((current-clause top-clause t wrld nil nil (local-rcnst (change rewrite-constant rcnst :top-clause top-clause :current-clause current-clause))) nil nil nil (access) nil nil) ((rewrite-constant rcnst :ens current-clause nil wrld local-rcnst hitp nil) nil (len) nil nil nil nil) ((current-clause) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::some-element-dumb-occur-lst (nil nil nil nil (cond) nil nil) (nil nil ((endp lst1) (dumb-occur-lst (car lst1) lst2) t) nil nil nil nil) ((nil t) nil nil (recursive-call) nil nil nil) ((lst2) nil (cdr) nil nil nil nil) ((lst1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::settled-since-inductionp (nil nil nil nil nil (cond) nil) (nil nil ((endp hist) (eq (access history-entry (car hist) :processor) (quote settled-down-clause)) (eq (access history-entry (car hist) :processor) (quote induct-clause)) t) nil nil nil nil) ((nil t nil) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((hist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::simplify-clause (nil nil nil (cond) nil nil nil) (nil nil ((settled-since-inductionp hist) t) nil nil nil nil) (nil nil nil (cond let*) nil nil nil) (nil nil ((and (eq (quote settled-down-clause) (access history-entry (car hist) :processor)) (not (some-element-dumb-occur-lst (access prove-spec-var pspv :induction-hyp-terms) cl))) t (rcnst (access prove-spec-var pspv :rewrite-constant))) nil (mv-let) nil nil) (nil nil (local-rcnst changedp) (cond) (mv-let simplify-clause1) (mv) nil) ((nil nil nil clauses cl local-rcnst wrld) nil (quote changedp changedp t) (cond) (simplify-clause1) nil nil) ((miss clauses cl wrld rewrite-constant rcnst :terms-to-be-ignored-by-rewrite :expand-lst) nil (changedp t) (append append) (access) (mv mv) nil)) (/paco/simplify.lisp::hit-it-againp (nil nil nil nil nil (cond) nil) (nil nil ((endp hist) (eq (access history-entry (car hist) :processor) (quote induct-clause)) (eq (access history-entry (car hist) :processor) (quote settled-down-clause)) t) nil nil nil nil) ((nil t nil) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((hist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/simplify.lisp::settled-down-clause (nil nil nil (cond) nil nil nil) (nil nil ((hit-it-againp hist) t) nil nil nil nil) (nil nil nil nil nil (mv mv) nil) ((nil pspv nil nil nil) nil (quote list quote) nil nil nil nil) ((HIT clause MISS) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
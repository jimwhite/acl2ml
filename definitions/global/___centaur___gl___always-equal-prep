((/centaur/gl/always-equal-prep.lisp::acl2::always-equal (nil nil nil (equal) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::ctrex-for-always-equal (nil nil nil nil (if) nil nil) ((t) nil nil (and b*) nil nil nil) (nil nil (atom atom ((mv xa xd) (if (consp x) (mv (car x) (cdr x)) (mv x x)))) nil (if) nil nil) ((x y) nil ((mv ya yd)) (hqual cons cons) nil nil nil) ((xa ya nil nil) nil nil (recursive-call recursive-call) (if) nil nil) ((xd yd xa ya) nil (consp) (mv mv) nil nil nil) ((y y y) nil (car cdr) nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::ctrex-for-always-equal-under-hyp1 (nil nil nil nil nil nil nil) (nil nil ((hqual x y) (eq hyp nil) (atom hyp) (and (atom x) (atom y)) (eq (cdr hyp) nil) (eq (car hyp) nil) t) nil nil nil nil) ((nil nil) nil nil (ctrex-for-always-equal ctrex-for-always-equal let let let) nil nil nil) ((x y hyp nil (res (ctrex-for-always-equal-under-hyp1 (if (consp x) (car x) x) (if (consp y) (car y) y) (car hyp))) (res (ctrex-for-always-equal-under-hyp1 (if (consp x) (cdr x) x) (if (consp y) (cdr y) y) (cdr hyp)))) nil ((x1 (acl2::q-and hyp x))) (and and) (if) nil nil) ((res res nil) nil (y1) (cons cons hqual ctrex-for-always-equal) nil nil nil) ((res nil nil res x1 y1 x1 y1) nil nil (acl2::q-and) nil nil nil) ((hyp y) nil nil nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::ctrex-for-always-equal-under-hyp (nil nil nil nil nil nil nil) (nil nil ((hqual x y) (eq hyp nil) (atom hyp) (eq (cdr hyp) nil) (eq (car hyp) nil) t) nil nil nil nil) ((nil nil) nil nil (ctrex-for-always-equal let let let) nil nil nil) ((x y (res (ctrex-for-always-equal-under-hyp (if (consp x) (car x) x) (if (consp y) (car y) y) (car hyp))) (res (ctrex-for-always-equal-under-hyp (if (consp x) (cdr x) x) (if (consp y) (cdr y) y) (cdr hyp))) (car-result (ctrex-for-always-equal-under-hyp (if (consp x) (car x) x) (if (consp y) (car y) y) (car hyp)))) nil nil (and and) (if) nil nil) ((res res car-result) nil nil (cons cons cons let) nil nil nil) ((res nil nil res car-result nil (cdr-result (ctrex-for-always-equal-under-hyp1 (if (consp x) (cdr x) x) (if (consp y) (cdr y) y) (cdr hyp)))) nil nil (and) nil nil nil) ((cdr-result) nil nil (cons) nil nil nil)) (/centaur/gl/always-equal-prep.lisp::always-equal-uu (nil nil nil nil (if) nil nil) (nil nil nil (and mv b*) nil nil nil) ((t t) nil (atom atom ((mv xa xd) (if (consp x) (mv (car x) (cdr x)) (mv x x)))) nil (if) nil nil) ((x y) nil ((mv ya yd)) (hqual recursive-call mv) nil nil nil) ((xa ya xd yd nil) nil nil (ctrex-for-always-equal) (if) nil nil) ((xa ya) nil (consp) (mv mv) nil nil nil) ((y y y) nil (car cdr) nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::always-equal-ss-under-hyp (nil nil nil (b*) nil nil nil) (nil nil nil (((mv xa xd xend) (if (consp x) (if (consp (cdr x)) (mv (car x) (cdr x) nil) (mv (car x) x t)) (mv nil nil t)))) (if) nil nil) (nil nil ((mv ya yd yend) res) (eq mv) (if) nil nil) ((res nil nil res) nil nil (and mv) (if ctrex-for-always-equal-under-hyp recursive-call) nil nil) ((xa ya hyp xend yend t t xd yd hyp) nil (consp) nil (if mv) nil nil) ((y nil nil t) nil (consp) nil (mv mv) nil nil) ((nil y t) nil (cdr car cdr car) nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::always-equal-of-numbers (nil nil nil (b*) nil nil nil) ((t) nil nil nil nil nil nil) (nil nil ((mv brn brd bin bid) (unless (and (equal ard (quote (T))) (equal aid (quote (T))) (equal brd (quote (T))) (equal bid (quote (T))))) (mv requal rctrex) (unless requal) (mv iequal ictrex) (unless iequal)) nil nil nil nil) (nil nil (general-number-components) (prog2$ prog2$ prog2$) (always-equal-ss-under-hyp always-equal-ss-under-hyp) nil nil) ((b arn brn hyp ain bin hyp) nil nil (cw g-apply cw cw) (g-if g-if) nil nil) ((Bad denominators: ~x0~% reals, ctrex: ~x0~% rctrex nil imags, ctrex: ~x0~% rctrex nil) nil (quote mk-g-boolean mk-g-boolean) (list g-apply g-apply) nil (list) nil) ((equal a b rctrex ictrex) nil (quote quote) (equal equal equal equal list list) nil nil nil)) (/centaur/gl/always-equal-prep.lisp::always-equal-of-booleans (nil nil nil (let) nil nil nil) (nil nil ((av (general-boolean-value a))) (or) nil nil nil) (nil nil (bv) (hqual) (g-if) nil nil) ((av bv nil) nil (general-boolean-value mk-g-boolean) (g-apply) nil nil nil) ((b) nil (quote) (list) (ctrex-for-always-equal-under-hyp) nil nil) ((av bv hyp equal a b) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/gl/always-equal-prep.lisp::g-always-equal-core (nil nil nil (and) nil nil nil) (nil nil (mbt) nil (cond) nil nil) (nil nil ((and (general-concretep a) (general-concretep b)) (zp clk) t) (and) nil nil nil) (nil nil (gobjectp gobjectp) (hqual g-apply) (pattern-match) nil nil) ((a b a) nil (general-concrete-obj general-concrete-obj quote (g-ite test then else) &) (list) nil nil nil) ((a b equal a b) nil nil nil (g-if) nil (pattern-match)) ((test b) nil ((g-ite test then else) (g-var &) (g-apply fn args) &) nil nil (recursive-call recursive-call) nil)))
((/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bv-not (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n) nil (not) (recursive-call) nil nil nil) (nil nil (car 1- cdr) nil nil nil nil) ((x n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-bleq (nil nil nil nil (if) nil nil) ((t) nil (zp) (and) nil nil nil) ((n) nil nil (iff) (recursive-call) nil nil) (nil nil (car car 1- cdr cdr) nil nil nil nil) ((x y n x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::xor (nil nil nil nil (if) nil nil) ((p) nil nil nil (if if) nil nil) ((q nil t q t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::xor3 (nil nil nil (xor) nil nil nil) ((x) nil nil (xor) nil nil nil) ((y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::maj3 (nil nil nil nil (if) nil nil) ((x) nil nil (or and) nil nil nil) ((y z y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::v-adder (nil nil nil nil (if) nil nil) (nil nil (zp list) (cons) nil nil nil) ((n c) nil nil nil (xor3) (recursive-call) nil) ((c) nil (car car 1- cdr cdr) nil (maj3) nil nil) ((a b n c a b) nil (car car) nil nil nil nil) ((a b) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::nth-cdr (nil nil nil nil (if) nil nil) ((x) nil (zp) (recursive-call) nil nil nil) ((n) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::nth-sublist (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n) nil (car) (recursive-call) nil nil nil) ((lst) nil (1- cdr) nil nil nil nil) ((n lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::append-n (nil nil nil nil (if) nil nil) ((y) nil (zp) (cons) nil nil nil) ((n) nil (car) nil (recursive-call) nil nil) ((x y) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-nills (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n nil) nil (recursive-call) nil nil nil nil) (nil nil (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::rev-n (nil nil nil nil (if) nil nil) ((ans) nil (zp) nil (recursive-call) nil nil) ((n) nil (1- cdr) (cons) nil nil nil) ((n x ans) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::mux-n-help (nil nil nil nil (if) nil nil) (nil nil (zp car) nil (if) nil nil) ((n in) nil (car) nil (recursive-call recursive-call) nil nil) ((rsel in) nil (1- cdr 1- cdr) (nth-cdr) nil nil nil) ((n in rsel n rsel) nil nil (expt) nil nil nil) (nil (2) (1-) nil nil nil nil) ((n) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::mux-n (nil nil nil nil (mux-n-help) nil nil) ((n in) nil nil nil (rev-n) nil nil) ((n sel nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::mux-n-w-help (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n) nil (car) nil (recursive-call) nil nil) ((in w) nil (1-) (nth-cdr) nil nil nil) ((n w in) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::mux-n-w1 (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((nw) nil nil nil (mux-n) nil (recursive-call)) ((sn sel sn w sel) nil (1- cdr) nil (mux-n-w-help) nil nil) ((w in nw in) nil nil (expt) nil nil nil) ((sn) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::mux-n-w (nil nil nil nil nil nil (mux-n-w1)) ((w n w in sel) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::shift-mux-help (nil nil nil nil (if) nil nil) ((nil) nil (zp) nil (append-n) nil nil) ((n w reg) nil nil nil (recursive-call) nil nil) ((w) nil (1-) (cons) nil nil nil) ((n nil reg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::shifter (nil nil nil nil (if) nil nil) ((reg) nil (zp) nil nil (mux-n-w) nil) ((sn sn rn rshift) nil nil nil (shift-mux-help) nil nil) ((rn reg) nil nil (expt) nil nil nil) ((sn) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::increment (nil nil nil nil (if) nil nil) ((nil) nil (zp) nil (if) nil nil) ((n) nil (car) (cons cons) nil nil nil) ((x nil t) nil (cdr) (recursive-call) nil nil nil) ((x) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::next_digit_counter_state (nil nil nil nil (if) nil nil) (nil nil nil (list list) (n-bleq) nil nil) ((x t nil) (4) (quote quote) (increment) nil nil nil) ((x) (4) nil nil (t nil) nil nil) ((nil nil t nil nil nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::next_counter_state (nil nil nil (let*) nil nil nil) (nil nil nil ((curr_d_out (next_digit_counter_state (car x)))) (if) nil nil) ((nil) nil (curr_d_val curr_d_reset zp) nil (if) nil nil) ((n curr_d_reset) nil (car cadr) (cons cons) nil nil nil) ((curr_d_out curr_d_out curr_d_val curr_d_val) nil (cdr) (recursive-call) nil nil nil) ((x) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::valid_digit (nil nil nil (let) nil nil nil) (nil nil (not) ((a1 (cadr a))) nil nil nil) (nil nil (a2 a3) (and) nil nil nil) ((a3) nil (caddr cadddr) (or) nil nil nil) ((a a a2 a1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::valid_digits (nil nil nil nil (if) nil nil) (nil nil (zp not) (and) nil nil nil) ((n) nil (consp valid_digit) (recursive-call) nil nil nil) ((x) nil (car 1- cdr) nil nil nil nil) ((x n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-nth (nil nil nil nil (if) nil nil) (nil nil (zp car) (recursive-call) nil nil nil) ((n x) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bvp (nil nil nil nil (if) nil nil) (nil nil (zp not) nil (and) nil nil) ((n bv) nil (consp booleanp) (recursive-call) nil nil nil) ((bv) nil (car 1- cdr) nil nil nil nil) ((bv n bv) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bv-hyp (nil nil nil nil (if) nil nil) (nil nil (zp not) (recursive-call) nil nil nil) ((n bv) nil (1- cdr) nil nil nil nil) ((n bv) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::rev-n (nil nil nil nil (if) nil nil) ((ans) nil (zp) nil (recursive-call) nil nil) ((n) nil (1- cdr) (cons) nil nil nil) ((n x ans) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::add-pairlist (nil nil nil nil (if) nil nil) ((list) nil (endp) nil (recursive-call) nil nil) ((A) nil (cdr cdr) (cons) nil nil nil) ((A B list) nil nil (cons) nil nil nil) (nil nil (car car) nil nil nil nil) ((A B) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::highp (nil nil nil nil (if) nil nil) ((nil) nil (consp) nil (if) nil nil) ((x x t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::lowp (nil nil (not) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::xValp (nil nil (consp) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::xVal (nil nil nil (cons) nil nil nil) ((nil) nil (quote) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bbit-and (nil nil nil nil (if) nil nil) ((x nil) nil nil nil (if) nil nil) ((y t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::tbit-and (nil nil nil nil (cond) nil nil) (nil nil ((or (lowp x) (lowp y)) (or (xValp x) (xValp y)) t) nil nil nil nil) ((xval) nil (quote quote) nil nil nil nil) ((nil t) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::unary-and (nil nil (list) nil nil nil nil) (nil nil nil (unary-and-help) nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bbit-or (nil nil nil nil (if) nil nil) ((x t) nil nil nil (if) nil nil) ((y t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::tbit-or (nil nil nil nil (cond) nil nil) (nil nil ((or (highp x) (highp y)) (or (xValp x) (xValp y)) t) nil nil nil nil) ((xval) nil (quote quote) nil nil nil nil) ((t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::unary-or (nil nil (list) nil nil nil nil) (nil nil nil (unary-or-help) nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bbit-xor (nil nil nil nil (if) nil nil) ((x) nil nil nil (if if) nil nil) ((y nil t y t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::tbit-xor (nil nil nil nil nil (cond) nil) (nil nil ((and (lowp x) (lowp y)) (or (xValp x) (xValp y)) (or (lowp x) (lowp y)) t) nil nil nil nil) ((xval) nil (quote quote quote) nil nil nil nil) ((nil t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bbit-not (nil nil (not) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::tbit-not (nil nil nil nil (cond) nil nil) (nil nil ((lowp x) (xValp x) t) nil nil nil nil) ((xval) nil (quote quote) nil nil nil nil) ((t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bv-eq (nil nil nil (unary-and) nil nil nil) ((n) nil nil (bv-not) nil nil nil) ((n) nil nil nil (bv-xor) nil nil) ((n x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::append-n (nil nil nil nil (if) nil nil) ((y) nil (zp) (cons) nil nil nil) ((n) nil (car) nil (recursive-call) nil nil) ((x y) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::a-n (nil nil nil nil (append-n) nil nil) ((n A B) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::bit-2-bool (nil nil nil nil (if) nil nil) ((nil t) nil (zp) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::nth-sublist (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n) nil (car) (recursive-call) nil nil nil) ((lst) nil (1- cdr) nil nil nil nil) ((n lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::get-sublist-h (nil nil nil nil (if) nil nil) (nil nil (zp) (nth-sublist) (recursive-call) nil nil) ((lbit lst) nil (1+ cdr 1- 1-) nil nil nil nil) ((hbit lst lbit hbit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::np (nil nil nil nil (if) nil nil) ((t) nil (integerp) (<) nil nil nil) ((x x) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::nnfix (nil nil nil nil (if) nil nil) ((x) (-1) (np) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-nils (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n nil) nil (recursive-call) nil nil nil nil) (nil nil (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::nth-cdr (nil nil nil nil (if) nil nil) ((x) nil (zp) (recursive-call) nil nil nil) ((n) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::get-sublist (nil nil nil nil (if) nil nil) ((nil) nil nil (<=) (get-sublist-h) nil nil) ((lst lbit hbit) nil (nfix nnfix) nil nil nil nil) ((lbit hbit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::g (nil nil nil nil (get-sublist) nil nil) ((lst lbit hbit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::update-sublist-h (nil nil nil nil (if) nil nil) (nil nil (zp) (cons) (append-n) nil nil) ((lbit) nil (1+ car) (nth-cdr) (get-sublist) (recursive-call) nil) ((hbit val lbit hbit lst lst val) nil (1+ cdr 1- 1-) nil nil nil nil) ((hbit lst lbit hbit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::update-sublist (nil nil nil nil (if) nil nil) ((lst) nil nil (<=) nil (update-sublist-h) nil) ((lst lbit hbit val) nil (nfix nnfix) nil nil nil nil) ((lbit hbit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::us (nil nil nil nil nil (update-sublist) nil) ((lst lbit hbit val) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::true-bvp (nil nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::simple-mult1 (nil nil nil nil (if) nil nil) ((ans) nil (zp) nil nil nil (recursive-call)) ((n) nil (1- 1+ cdr) (cons) (if) nil nil) ((n sz a nil curr-b ans) nil (car) nil nil (v-adder) nil) ((a sz nil curr-b ans) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::simple-mult (nil nil nil nil nil nil (simple-mult1)) ((n n a b nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::sat-assert (nil nil nil (prog2$) nil nil nil) (nil nil nil (cond prog2$) nil nil nil) (nil nil ((not expr) t) (cond cond) nil nil nil) ((nil) nil (prop-name t pred t) nil (cw) nil nil) ((~s0 expression: ~x1~% test-string expr) (0) (cw cw) nil (er) nil nil) ((hard Assertion failed~%) nil (quote) (concat-str) nil (concat-str) nil) ((test-string :  ~% test-string ~% recursive-call) nil (symbol-name) nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::translate-list (nil nil nil (cond) nil nil nil) (nil nil ((endp expr-list) t) nil nil nil nil) (nil nil nil (mv) nil (mv-let) nil) ((ans state) nil (declare) nil (flg recursive-call) nil nil) ((trans-expr bindings state nil nil t state state) nil (car quote w cdr) (ignore cons) nil nil nil) ((expr-list recursive-call state flg bindings expr-list trans-expr ans) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::parse-hyp-list (nil nil nil (cond) nil nil nil) (nil nil ((endp expr-list) t) nil nil nil nil) ((ans) nil nil (let) nil nil nil) (((expr (car expr-list))) nil nil nil (cond) nil nil) (nil nil ((atom expr) (eq (quote and) (car expr)) t) nil nil nil nil) (nil nil nil (recursive-call recursive-call recursive-call) nil nil nil) ((ans) nil (cdr cdr) (cons append cons) nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::parse-property (nil nil nil nil (cond) nil nil) (nil nil ((atom expr) (eq (car expr) (quote implies)) t) nil nil nil nil) (nil nil nil (mv mv mv) nil nil nil) ((nil nil) nil (list list list) (parse-hyp-list) nil nil nil) ((expr nil expr) nil (list caddr) nil nil nil nil) ((expr) nil (cadr) nil nil nil nil) ((expr) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::parse-and-translate (nil nil nil nil (mv-let) nil nil) (nil nil (hyp-list parse-property) nil (mv-let) nil nil) ((conc-list property) nil (hyp-list) nil (translate-list mv-let) nil nil) ((state hyp-list nil state) nil (conc-list) nil (translate-list mv) nil nil) ((state conc-list nil state hyp-list conc-list state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::check-counter-example1 (nil nil nil nil (cond) nil nil) (nil nil ((and (endp hyp-list) (endp conc-list)) (endp hyp-list) t) nil nil nil nil) (nil nil nil (mv) (mv-let mv-let) nil nil) ((nil state) nil nil (erp cond erp cond) nil nil nil) ((eval-output state ce-alist nil Counter-example check run-ce state nil eval-output state ce-alist nil Counter-example check run-ce state nil) nil (car w erp t car w erp t) nil nil nil nil) ((conc-list state hyp-list state) nil nil (mv mv) (let let) nil nil) ((state (val (sat-assert (not (cdr eval-output)) Checking counter-example (car conc-list) name)) state (val (sat-assert (cdr eval-output) Checking counter-example (car hyp-list) name))) nil (declare declare) nil (er er) nil (recursive-call recursive-call))) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::check-counter-example (nil nil nil (cond) nil nil nil) (nil nil (no-ce-check t) nil nil nil nil) (nil nil nil (mv let*) nil nil nil) (($sat state) nil ((curr-flg (get-global (quote guard-checking-on) state))) nil nil (mv-let) nil) (nil nil (state declare) (erp sat-generate-satisfying-instance) nil (mv-let) nil) (($sat state $sat state) nil (ignore declare) (sat-si-input-alist) (put-global erp) (mv-let) nil) ((nil state erp ce-alist $sat state $sat state) nil (quote ignore erp declare) (let) nil nil (check-counter-example1))) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::check-invalid-hyp-list-inc (nil nil nil (cond) nil nil nil) (nil nil ((endp expr-list) t) nil nil nil nil) (nil nil nil (mv let*) nil nil nil) (($sat state (added-hyp-list (cons (car expr-list) added-hyp-list))) nil nil nil nil (mv-let) nil) (nil nil (declare) (erp) nil (sat-add-expr mv-let) nil) (($sat state nil $sat state) nil (car ignore declare) (sat-solve cond) (erp) nil nil) ((expr-list erp soln $sat state $sat state) nil (ignore (and partial-valid (equal soln (quote acl2::unsat))) t) nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::check-invalid-conc-list-inc (nil nil nil (cond) nil nil nil) (nil nil ((endp expr-list) t) nil nil nil nil) (nil nil nil (mv let*) nil nil nil) (($sat state (added-conc-list (cons (car expr-list) added-conc-list))) nil nil nil nil (mv-let) nil) (nil nil (declare) (erp) nil (sat-add-expr mv-let) nil) (($sat state t $sat state) nil (car ignore declare) (sat-solve cond) (erp) nil nil) ((expr-list erp soln $sat state $sat state) nil (ignore (and partial-valid (equal soln (quote acl2::unsat))) t) nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::thm-sat-valid-inc1 (nil nil nil nil nil (mv-let) nil) (nil nil (declare) (erp sat-new-problem) (mv-let) nil nil) (($sat state $sat state) nil (ignore) (hyp-list parse-and-translate let*) nil nil nil) ((erp conc-list state property state) nil ((last-conc (car conc-list))) nil (mv-let) nil nil) (nil nil (conc-list $sat) nil (mv-let) nil nil) ((state name hyp-list partial-valid no-ce-check nil nil $sat state) nil (cdr $sat) nil nil (mv-let) nil) ((conc-list state name conc-list partial-valid no-ce-check hyp-list nil $sat state) nil (declare) (erp) nil (sat-add-expr mv-let) nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::thm-sat-invalid-inc1 (nil nil nil nil nil (mv-let) nil) (nil nil (declare) (erp sat-new-problem) (mv-let) nil nil) (($sat state $sat state) nil (ignore) (hyp-list parse-and-translate) (mv-let) nil nil) ((erp conc-list state property state) nil ($sat) nil nil nil nil) ((state name hyp-list nil no-ce-check nil nil $sat state name conc-list nil no-ce-check hyp-list nil $sat state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::uf1-if-t (nil nil nil nil (if) nil nil) ((x nil) nil (uf1) nil nil nil nil) ((a) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-rev-append (nil nil nil nil (if) nil nil) ((y) nil nil (or) (recursive-call) nil nil) (nil nil (zp atom 1- cdr) (cons) nil nil nil) ((n x n x y) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-true-listp (nil nil nil nil (if) nil nil) (nil nil nil (or equal recursive-call) nil nil nil) ((x nil) nil (zp atom 1- cdr) nil nil nil nil) ((n x n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::n-boolean-listp (nil nil nil nil nil (cond) nil) (nil nil ((zp n) (atom x) (Booleanp (car x)) t) nil nil nil nil) ((nil nil) nil nil (equal n-Boolean-listp) nil nil nil) ((x nil) nil (1- cdr) nil nil nil nil) ((n x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat-tests/test-incremental.lisp::foo (nil nil nil (cons) nil nil nil) ((x) (4) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
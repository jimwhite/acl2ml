((/paco/elim-dest.lisp::strip-final-digits (nil nil (strip-final-digits1) nil nil nil nil) (nil nil (reverse) nil nil nil nil) (nil nil nil (coerce) nil nil nil) ((str) nil (quote) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::assoc-ts-subsetp (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (ts-subsetp ts (caar alist)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((alist ts) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::first-non-member-eq (nil nil nil nil (cond) nil nil) (nil nil ((endp lst1) (member-eq (car lst1) lst2) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((lst2 lst1) nil (cdr) nil nil nil nil) ((lst1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::generate-variable-root1 (nil nil nil (let*) nil nil nil) (nil nil nil ((ts (type-set term type-alist nil ens wrld *type-set-nnn*))) (cond) nil nil) (nil nil (family var var family t) nil nil nil nil) (nil nil (cdr) (first-non-member-eq mv mv mv) nil nil nil) ((family avoid-lst nil nil) (0) (symbol-name symbol-name abbreviate-hyphenated-string) (assoc-ts-subsetp) nil nil nil) ((ts *var-families-by-type* var) nil (car symbol-name) nil nil nil nil) ((family) nil nil nil nil (cond) nil)) (/paco/elim-dest.lisp::generate-variable-root (nil nil nil nil nil nil (cond)) (nil nil ((variablep term) (fquotep term) (eq (ffn-symb term) (quote CAR)) (eq (ffn-symb term) (quote CDR)) t) nil nil nil nil) (nil nil nil (mv) (mv-let mv-let mv-let) nil (generate-variable-root1)) ((CONST term avoid-lst type-alist ens wrld) (0) (str strip-final-digits str str) (mv mv mv) nil nil (recursive-call recursive-call)) ((n str n avoid-lst type-alist ens wrld str n avoid-lst type-alist ens wrld str) nil (symbol-name 1+) (fargn or fargn or) nil nil nil) ((term n term n term n) (1 0 1 0) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::find-pkg-witness (nil nil nil nil (or) nil nil) (nil nil (find-first-var find-first-fnsymb quote) nil nil nil nil) ((term term recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::generate-variable (nil nil nil nil (mv-let) nil nil) (nil nil (str) nil nil (genvar) (generate-variable-root)) ((n term avoid-lst type-alist ens wrld str n avoid-lst) nil (find-pkg-witness) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::generate-variable-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp term-lst) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((var (generate-variable (car term-lst) avoid-lst type-alist ens wrld))) nil nil (cons) nil nil nil) ((var) nil nil nil nil nil (recursive-call)) ((type-alist ens wrld) nil (cdr) (cons) nil nil nil) ((term-lst var avoid-lst) nil nil nil nil nil nil)) (/paco/elim-dest.lisp::occurs-nowhere-else (nil nil nil nil nil (cond) nil) (nil nil ((endp args) (int= c i) (dumb-occur var (car args)) t) nil nil nil nil) ((t nil) nil nil nil nil (recursive-call recursive-call) nil) ((var c var c) nil (cdr 1+ cdr 1+) nil nil nil nil) ((args i args i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::first-nomination (nil nil nil (cons) nil nil nil) ((nominations) nil nil (cons) nil nil nil) ((term) nil nil (cons) nil nil nil) ((term votes) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::second-nomination (nil nil nil nil (cond) nil nil) (nil nil ((endp nominations) (equal term (car (car nominations))) t) nil nil nil nil) ((nil) nil nil (cons cons) nil nil nil) (nil nil (cdr car) (cons) (recursive-call) nil nil) ((term nominations nominations term votes) nil (cdr) (union-equal) nil nil nil) ((votes nominations) nil (cdr) nil nil nil nil) (nil nil (car) nil nil nil nil)) (/paco/elim-dest.lisp::some-hyp-probably-nilp (nil nil nil (cond) nil nil nil) (nil nil ((endp hyps) t) nil nil nil nil) ((nil) nil nil nil (mv-let) nil nil) (nil nil (knownp) (cond) nil (known-whether-nil) nil) ((nilp type-alist ens wrld) nil (car (and knownp nilp) t) nil nil nil nil) ((hyps t) nil nil nil nil (recursive-call) nil) ((type-alist ens wrld) nil (cdr) nil nil nil nil)) (/paco/elim-dest.lisp::nominate-destructor-candidate (nil nil nil (cond) nil nil nil) (nil nil ((flambda-applicationp term) t) nil nil nil nil) ((nominations) nil nil (let) nil nil nil) (((rule (getprop (ffn-symb term) (quote eliminate-destructors-rule) nil wrld))) nil nil (cond) nil nil nil) (nil nil ((or (null rule) (not (enabled-numep (access elim-rule rule :nume) ens))) t) nil nil nil nil) ((nominations) nil nil (let) nil nil nil) (((crucial-arg (nth (access elim-rule rule :crucial-position) (fargs term)))) nil nil (cond) nil nil nil)) (/paco/elim-dest.lisp::sum-level-nos (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) (nil (0) nil (+) nil nil nil) (nil nil nil (recursive-call) (if) nil nil) ((wrld) nil (flambda-applicationp cdr) (max-level-no or) nil nil nil) ((wrld lst) (0) (car lambda-body) nil nil (getprop) nil) ((lst nil wrld) nil (ffn-symb ffn-symb quote) nil nil nil nil)) (/paco/elim-dest.lisp::pick-highest-sum-level-nos (nil nil nil (cond) nil nil nil) (nil nil ((endp nominations) t) nil nil nil nil) ((dterm) nil nil (let) nil nil nil) (((score (sum-level-nos (cdr (car nominations)) wrld))) nil nil (cond) nil nil nil) (nil nil ((> score max-score) t) nil nil nil nil) (nil nil nil nil nil (recursive-call recursive-call) nil) ((wrld score wrld dterm max-score) nil (cdr caar cdr) nil nil nil nil)) (/paco/elim-dest.lisp::select-instantiated-elim-rule (nil nil nil (let) nil nil nil) (((nominations (nominate-destructor-candidates-lst clause eliminables type-alist ens wrld nil))) nil nil (cond) nil nil nil) (nil nil ((endp nominations) t) nil nil nil nil) ((nil) nil nil (let*) nil nil nil) (nil nil nil ((dterm (pick-highest-sum-level-nos nominations wrld nil -1))) nil nil nil) ((elim-rule rule :hyps :lhs :rhs :destructor-term :destructor-terms) nil (rule alist) (sublis-var-lst sublis-var sublis-var sublis-var sublis-var-lst) nil nil nil) ((alist alist alist alist alist) nil nil (pairlis) (access access access access access) (getprop) nil)) (/paco/elim-dest.lisp::convert-type-set-to-term-lst (nil nil nil nil (cond) nil nil) (nil nil ((endp rules) (and (enabled-numep (access type-set-inverter-rule (car rules) :nume) ens) (ts= (access type-set-inverter-rule (car rules) :ts) (ts-intersection (access type-set-inverter-rule (car rules) :ts) ts))) t) nil nil nil nil) (nil nil (reverse <convert-type-set-to-term-lst-id>) nil nil (recursive-call) nil) ((lst ts ens lst) nil (cdr) nil nil (recursive-call) nil) ((ens rules) nil (cdr) (ts-intersection add-to-set-equal) nil nil nil) ((ts rules lst) nil (ts-complement conjoin) nil nil nil nil) (nil nil nil nil (access access) nil nil)) (/paco/elim-dest.lisp::convert-type-set-to-term (nil nil nil nil nil (cond) nil) (nil nil ((ts= ts *ts-unknown*) (and (ts= ts *ts-t*) (ts-booleanp x nil ens w)) (ts-complementp ts) t) nil nil nil nil) ((*t* x) nil nil nil (subst-var subst-var) nil nil) ((x x) nil (quote conjoin quote disjoin) nil nil nil nil) ((x x) nil (dumb-negate-lit-lst) nil nil (convert-type-set-to-term-lst) nil) ((ts ens nil) nil nil (global-val) nil (convert-type-set-to-term-lst) nil) ((ens nil w) nil (ts-complement quote) (global-val) nil nil nil)) (/paco/elim-dest.lisp::type-restriction-segment (nil nil nil (cond) nil nil nil) (nil nil ((endp terms) t) nil nil nil nil) ((nil) nil nil (let*) nil nil nil) (nil nil nil nil ((ts (type-set (car terms) type-alist nil ens wrld *type-set-nnn*)) cond) nil nil) (nil nil (generalized-term clauses lits (null clauses) (and (endp (cdr clauses)) (not (endp (car clauses)))) t) nil nil nil nil) ((lits) nil nil (add-to-set-equal disjoin-clauses) (clausify) (convert-type-set-to-term) (recursive-call)) ((ts ens wrld ens wrld type-alist ens wrld *nil* lits lits) nil (car dumb-negate-lit cdr cdr car) nil nil nil nil)) (/paco/elim-dest.lisp::apply-generalize-rule (nil nil nil (cond) nil nil nil) (nil nil ((not (enabled-numep (access generalize-rule gen-rule :nume) ens)) t) nil nil nil nil) (nil nil nil (mv) (mv-let) nil nil) ((nil nil) nil (ans) (subterm-one-way-unify) (cond) nil nil) ((unify-subst term) nil ((null ans) (free-varsp (access generalize-rule gen-rule :formula) unify-subst) t) nil (access) nil nil) ((generalize-rule gen-rule :formula) nil nil (mv mv let) nil nil nil) ((nil nil nil nil (inst-formula (sublis-var unify-subst (access generalize-rule gen-rule :formula)))) nil nil (cond) nil nil nil)) (/paco/elim-dest.lisp::generalize-rule-segment1 (nil nil nil (cond) nil nil nil) (nil nil ((endp generalize-rules) t) nil nil nil nil) ((nil) nil nil nil (mv-let) nil nil) (nil nil (ans) (let) (apply-generalize-rule) nil nil) ((formula term ens (formulas (generalize-rule-segment1 (cdr generalize-rules) term ens))) nil (car) (cond) nil nil nil) ((generalize-rules) nil (ans t) nil nil nil nil) ((formulas) nil nil nil (add-literal) nil nil)) (/paco/elim-dest.lisp::generalize-rule-segment (nil nil nil (cond) nil nil nil) (nil nil ((endp terms) t) nil nil nil nil) ((nil) nil nil (disjoin-clauses) nil nil nil) (nil nil nil nil (generalize-rule-segment1 recursive-call) nil nil) ((ens ens wrld) nil (car cdr) (global-val) nil nil nil) ((wrld terms terms) nil (quote) nil nil nil nil) ((generalize-rules) nil nil nil nil nil nil)) (/paco/elim-dest.lisp::generalize1 (nil nil nil (disjoin-clauses) nil nil nil) (nil nil nil (sublis-expr-lst) nil nil (type-restriction-segment)) ((terms vars type-alist ens wrld) nil nil (pairlis disjoin-clauses) nil nil nil) ((terms vars cl) nil nil nil (generalize-rule-segment) nil nil) ((terms ens wrld) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/elim-dest.lisp::apply-instantiated-elim-rule (nil nil (<apply-instantiated-elim-rule-id>) nil nil nil nil) (nil nil nil (let*) nil nil nil) (nil nil nil nil (mv-let) nil ((hyps (access elim-rule rule :hyps)))) (nil nil (lhs rhs dests negated-hyps cl-with-hyps contradictionp) (cond) nil (type-alist-clause) nil) ((type-alist negated-hyps type-alist ens wrld) nil (dumb-negate-lit-lst contradictionp t) (disjoin-clauses) (access access access) nil nil) ((elim-rule rule :lhs elim-rule rule :rhs elim-rule rule :destructor-terms hyps negated-hyps cl) nil nil (mv let*) nil nil nil) ((cl) nil (list) (mv) nil nil ((elim-vars (generate-variable-lst dests (all-vars1-lst cl-with-hyps avoid-vars) type-alist ens wrld))))) (/paco/elim-dest.lisp::eliminate-destructors-clause1 (nil nil nil (cond) nil nil nil) (nil nil ((zp nnn) t) nil nil nil nil) (nil nil nil (mv) (mv-let) nil nil) ((nil) nil (list contradictionp) (cond) nil (type-alist-clause) nil) ((cl type-alist cl nil ens wrld) nil (contradictionp t) nil nil nil nil) (nil nil nil (mv let) nil nil nil) ((nil (rule (select-instantiated-elim-rule cl type-alist eliminables ens wrld))) nil (list) (cond) nil nil nil)) (/paco/elim-dest.lisp::owned-vars (nil nil nil nil (cond) nil nil) (nil nil ((endp history) (eq mine-flg (eq (access history-entry (car history) :processor) process)) t) nil nil nil nil) ((nil) nil nil (union-eq) (recursive-call) nil nil) ((process mine-flg) nil (cdr cdr) nil (recursive-call) nil nil) ((process mine-flg history) nil (cdr) (assoc-eq) nil nil nil) ((:VARIABLES history) nil nil nil (access) nil nil) ((history-entry :alist) nil (car) nil nil nil nil)) (/paco/elim-dest.lisp::eliminate-destructors-clause (nil nil nil nil (mv-let) nil nil) (nil nil (clauses) (cond) nil nil nil) ((elim-vars cl wrld t *eliminate-destructors-nnn*) nil (elim-vars t) (set-difference-eq) (owned-vars access) nil nil) ((nil hist rewrite-constant :ens) nil (quote) (all-vars1-lst) (owned-vars access) (mv mv) nil) ((cl nil t hist recursive-call prove-spec-var pspv :rewrite-constant clauses pspv nil nil nil) nil (quote quote list quote) nil nil nil nil) ((recursive-call hit miss) nil nil (cons) nil nil nil) ((:VARIABLES elim-vars) nil nil nil nil nil nil)))
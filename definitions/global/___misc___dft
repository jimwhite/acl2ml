((/misc/dft.lisp::dterm-sublis-subst-to-alist (nil nil nil (cond) nil nil nil) (nil nil ((null subst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (cons recursive-call) nil nil nil) ((alist) nil (caar cdr) (dterm-sublis) nil nil nil) ((subst alist subst) nil (cadr) nil nil nil nil) (nil nil (car) nil nil nil nil)) (/misc/dft.lisp::dterm-sublis-subst (nil nil nil (let) nil nil nil) (((alist2 (dterm-sublis-subst-to-alist alist subst))) nil nil (pairlis$) nil nil nil) (nil nil (strip-cars) (pairlis$) nil nil nil) ((alist2 nil) nil (strip-cdrs) nil nil nil nil) ((alist2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::assoc-keys-other-than (nil nil nil nil (cond) nil nil) (nil nil ((null alist) (member-eq (caar alist) lst) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((lst) nil (cdr caar) (recursive-call) nil nil nil) ((alist alist lst) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::dterm-sublis-into-lmi (nil nil nil nil (cond) nil nil) (nil nil ((atom lmi) (eq (car lmi) :instance) t) nil nil nil nil) ((lmi lmi) nil nil nil (list*) nil nil) ((:instance) nil nil (recursive-call dterm-sublis-subst) nil nil nil) ((alist alist) nil (cadr cddr) nil nil nil nil) ((lmi lmi) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::dterm-sublis-into-use-hint (nil nil nil (cond) nil nil nil) (nil nil ((null lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (dterm-sublis-into-lmi recursive-call) nil nil nil) ((alist alist) nil (car cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::convert-keyword-alist-to-alist (nil nil nil (cond) nil nil nil) (nil nil ((atom keyword-alist) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (cons recursive-call) nil nil nil) ((bindings) nil (car cddr) (cond) nil nil nil) ((keyword-alist keyword-alist) nil ((eq (car keyword-alist) :use) t) nil nil nil nil) (nil nil (cadr) (cond) nil nil nil)) (/misc/dft.lisp::negate-dterm (nil nil nil nil nil (cond) nil) (nil nil ((equal dterm t) (equal dterm nil) (and (consp dterm) (eq (car dterm) (quote not))) t) nil nil nil nil) ((nil t) nil (cadr) (list) nil nil nil) ((dterm dterm) nil (quote) nil nil nil nil) ((not) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::conjoin-dterms (nil nil nil nil nil nil (cond)) (nil nil ((equal dterm1 nil) (equal dterm2 nil) (equal dterm1 t) (equal dterm2 t) t) nil nil nil nil) ((nil nil dterm2 dterm1) nil nil (let) nil nil nil) (nil nil ((lst1 (case-match dterm1 (((quote and) . terms) terms) (& (list dterm1))))) (cons) nil nil nil) (nil nil (lst2 quote) (append) nil nil nil) ((and lst1 lst2) nil nil nil (case-match) nil nil) ((dterm2) nil (((quote and) . terms) &) nil nil nil nil)) (/misc/dft.lisp::implicate-dterms (nil nil nil (cond) nil nil nil) (nil nil ((eq dhyp t) t) nil nil nil nil) ((dconcl) nil nil nil (case-match) nil nil) ((dconcl) nil (((quote implies) hyps concl) &) nil nil nil nil) (nil nil nil nil (list list) nil nil) ((concl dhyp dconcl) nil (quote quote) (conjoin-dterms) nil nil nil) ((implies hyps dhyp implies) nil nil nil nil nil nil)) (/misc/dft.lisp::dterm-hyp (nil nil nil nil (case-match) nil nil) ((dterm) nil (((quote implies) hyp &) &) nil nil nil nil) ((hyp t) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::dterm-concl (nil nil nil nil (case-match) nil nil) ((dterm) nil (((quote implies) & concl) &) nil nil nil nil) ((concl dterm) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::apply-proof-step (nil nil nil (let) nil nil nil) (nil nil ((dhyp2 (dterm-hyp dterm))) nil (case-match) nil nil) ((dhyp1) nil (dconcl ((quote equal) lhs rhs) &) nil nil nil nil) (nil nil (dterm-concl) (let implicate-dterms) nil nil nil) ((dterm (dconcl2 (dterm-sublis (list (cons lhs rhs)) dconcl)) dconcl) nil nil (cond conjoin-dterms) nil nil nil) ((dhyp2 dhyp1) nil ((equal dconcl2 dconcl) t) nil nil nil nil) (nil nil nil (implicate-dterms implicate-dterms) nil nil nil)) (/misc/dft.lisp::pairlis1 (nil nil nil (cond) nil nil nil) (nil nil ((null lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (cons recursive-call) nil nil nil) ((x1 x1) nil (car cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/dft.lisp::generalization-phrasep (nil nil nil nil nil nil (cond)) (nil nil ((atom phrase) (keywordp (car phrase)) (eq (car phrase) (quote and)) (and (consp (cdr phrase)) (eq (cadr phrase) (quote to)) (consp (cddr phrase)) (symbolp (caddr phrase)) (not (member-eq (caddr phrase) all-vars))) t) nil nil nil nil) (nil nil nil (let*) (mv mv mv) nil (recursive-call)) ((nil nil nil all-vars bindings new-hyps alist nil nil) nil (reverse ` cdr `) (dterm-sublis-lst) ((expr (dterm-sublis bindings (car phrase)))) nil (recursive-call)) ((alist alist phrase bindings phrase1) nil (reverse var hyp phrase1) (cons cons) (if) (er er) nil) ((new-hyps soft It is illegal to put a hint inside a generalization step.  The ~
              usual intent is to aid the proof of a restriction on some ~
              variable, as in (GENERALIZE expr TO var WHERE (p var) ~p0...).  ~
              The proper way to achieve this is to OBSERVE that expr has the ~
              desired property before its generalization to var, as in ~
              (OBSERVE (p expr) ~p0 ...) (GENERALIZE expr TO ar). var all-vars hyp new-hyps alist soft Illegal GENERALIZATION step.  We expected to see repetitions ~
                of the phrases `expr TO var' or `expr TO var WHERE ~
                restriction', possibly separated by `and', where var is a ~
                variable not previously involved in the problem; ~p0 cannot be ~
                parsed that way.) nil (quote quote caddr quote quote) (cons cons) (if if) nil nil) ((deft phrase nil hyp hyp new-hyps var expr deft) nil (, cdr cdddr ,) (dterm-sublis) (and) nil nil)) (/misc/dft.lisp::delete-null-cdrs (nil nil nil nil (cond) nil nil) (nil nil ((atom alist) (null (cdar alist)) t) nil nil nil nil) ((nil) nil (recursive-call) (cons) nil nil nil) (nil nil (cdr car recursive-call) nil nil nil nil) ((alist alist) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
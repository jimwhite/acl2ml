((/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-constant-addend (nil nil nil nil nil (cond) nil) (nil nil ((and (eq (fn-symb lhs) (quote BINARY-+)) (eq (fn-symb rhs) (quote BINARY-+)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb rhs) (quote BINARY-+)) (numeric-constant-p lhs) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb lhs) (quote BINARY-+)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p rhs)) t) nil nil nil nil) ((nil) nil nil (let let let) nil nil nil) (nil nil ((c (unquote (arg1 lhs))) (c (unquote lhs)) (c (unquote (arg1 lhs)))) nil nil (cond cond cond) nil) (nil nil (d (eql c 0) (eql d 0) (< c d) t d (eql c 0) (eql d 0) (< c d) t d (eql c 0) (eql d 0) (< c d) t) nil nil nil nil) (nil nil (unquote ` ` ` ` unquote ` ` ` ` unquote ` ` ` `) nil nil nil nil) (((c , (kwote (- d))) (c , (kwote (- c))) (c , (kwote (- c))) (c , (kwote (- d))) (c , (kwote (- d))) (c , (kwote (- c))) (c , (kwote (- c))) (c , (kwote (- d))) rhs (c , (kwote (- d))) (c , (kwote (- c))) (c , (kwote (- c))) (c , (kwote (- d)))) nil (arg1 arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-constant-factor-equal (nil nil nil nil nil nil nil) (nil nil ((and (eq (fn-symb lhs) (quote BINARY-*)) (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p lhs) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb lhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p rhs)) (and (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p (arg1 rhs)) (not (eq (fn-symb (arg2 rhs)) (quote BINARY-*))) (eq (fn-symb lhs) (quote BINARY-+))) (and (eq (fn-symb lhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (not (eq (fn-symb (arg2 lhs)) (quote BINARY-*))) (eq (fn-symb rhs) (quote BINARY-+))) (and (eq (fn-symb rhs) (quote BINARY-+)) (eq (fn-symb lhs) (quote BINARY-+))) t) nil nil nil nil) ((nil nil) nil (` `) (let let let) nil nil nil) (((c , (kwote (/ (unquote (arg1 lhs))))) (c , (kwote (/ (unquote (arg1 rhs)))))) nil ((c (unquote (arg1 lhs))) (c (unquote lhs)) (c (unquote (arg1 lhs)))) nil nil (cond cond cond) nil) (nil nil (d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t) nil nil nil nil) (nil nil (unquote ` ` ` ` unquote ` ` ` ` unquote ` ` ` `) nil nil nil nil) (((c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) rhs (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d)))) nil (arg1 arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-rational-constant-factor-< (nil nil nil nil nil nil nil) (nil nil ((and (eq (fn-symb lhs) (quote BINARY-*)) (eq (fn-symb rhs) (quote BINARY-*)) (rational-constant-p (arg1 lhs)) (rational-constant-p (arg1 rhs))) (and (eq (fn-symb rhs) (quote BINARY-*)) (rational-constant-p lhs) (rational-constant-p (arg1 rhs))) (and (eq (fn-symb lhs) (quote BINARY-*)) (rational-constant-p (arg1 lhs)) (rational-constant-p rhs)) (and (eq (fn-symb rhs) (quote BINARY-*)) (rational-constant-p (arg1 rhs)) (not (eq (fn-symb (arg2 rhs)) (quote BINARY-*))) (eq (fn-symb lhs) (quote BINARY-+))) (and (eq (fn-symb lhs) (quote BINARY-*)) (rational-constant-p (arg1 lhs)) (not (eq (fn-symb (arg2 lhs)) (quote BINARY-*))) (eq (fn-symb rhs) (quote BINARY-+))) (and (eq (fn-symb rhs) (quote BINARY-+)) (eq (fn-symb lhs) (quote BINARY-+))) t) nil nil nil nil) ((nil nil nil nil) nil nil (let let let) nil nil nil) (nil nil ((c (unquote (arg1 lhs))) (c (unquote lhs)) (c (unquote (arg1 lhs)))) nil nil (cond cond cond) nil) (nil nil (d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t) nil nil nil nil) (nil nil (unquote ` ` ` ` unquote ` ` ` ` unquote ` ` ` `) nil nil nil nil) (((c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) rhs (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d)))) nil (arg1 arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-constant-factor-< (nil nil nil nil nil nil nil) (nil nil ((and (eq (fn-symb lhs) (quote BINARY-*)) (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p lhs) (numeric-constant-p (arg1 rhs))) (and (eq (fn-symb lhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (numeric-constant-p rhs)) (and (eq (fn-symb rhs) (quote BINARY-*)) (numeric-constant-p (arg1 rhs)) (not (eq (fn-symb (arg2 rhs)) (quote BINARY-*))) (eq (fn-symb lhs) (quote BINARY-+))) (and (eq (fn-symb lhs) (quote BINARY-*)) (numeric-constant-p (arg1 lhs)) (not (eq (fn-symb (arg2 lhs)) (quote BINARY-*))) (eq (fn-symb rhs) (quote BINARY-+))) (and (eq (fn-symb rhs) (quote BINARY-+)) (eq (fn-symb lhs) (quote BINARY-+))) t) nil nil nil nil) ((nil nil nil nil) nil nil (let let let) nil nil nil) (nil nil ((c (unquote (arg1 lhs))) (c (unquote lhs)) (c (unquote (arg1 lhs)))) nil nil (cond cond cond) nil) (nil nil (d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t d (or (eql c 0) (eql (abs c) 1)) (or (eql d 0) (eql (abs d) 1)) (< c d) t) nil nil nil nil) (nil nil (unquote ` ` ` ` unquote ` ` ` ` unquote ` ` ` `) nil nil nil nil) (((c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d))) rhs (c , (kwote (/ d))) (c , (kwote (/ c))) (c , (kwote (/ c))) (c , (kwote (/ d)))) nil (arg1 arg1) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::product (nil nil nil nil (cond) nil nil) (nil nil ((atom factors) (atom (cdr factors)) t) nil nil nil nil) ((nil) nil (car `) nil nil nil nil) ((factors) nil nil (BINARY-*) nil nil nil) (nil nil (, ,) nil nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((factors) nil (cdr) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-rational-factor-and-remainder-1 (nil nil nil nil nil nil (cond)) (nil nil ((not (eq (fn-symb x) (quote BINARY-*))) (proveably-real/rational (quote x) (` ((x , (arg1 x)))) mfc state) (eq (fn-symb (arg2 x)) (quote BINARY-*)) (proveably-real/rational (quote x) (` ((x , (arg2 x)))) mfc state) t) nil nil nil nil) ((nil nil) nil (` `) nil nil (recursive-call) nil) ((mfc state) nil ((y , (arg1 x)) arg2 (y , (arg2 x))) (cons) nil nil nil) ((x rem) nil (arg1) (z z) nil nil nil) ((, x ,) nil (product product) nil nil nil nil) (nil nil (reverse reverse) nil nil nil nil)) (/arithmetic-5/lib/basic-ops/simple-equalities-and-inequalities.lisp::find-rational-factor-and-remainder (nil nil nil nil nil (find-rational-factor-and-remainder-1) nil) ((x nil mfc state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
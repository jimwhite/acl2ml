((/cutil/defmapappend.lisp::defmapappend-fn (nil nil nil (b*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (mksym-package-symbol x a n y acc (unless (and (symbol-listp formals) (no-duplicatesp formals))) (unless (member x formals)) (unless (and (not (member a formals)) (not (member n formals)) (not (member y formals)) (not (member acc formals)))) (unless (and (consp transform) (symbolp (car transform)))) exec-fn transform-fn transform-args (unless (and (subsetp-equal transform-args formals) (subsetp-equal formals transform-args))) (unless (booleanp verify-guards)) (unless (booleanp transform-true-list-p)) (unless (symbolp transform-exec)) (unless (member mode (quote (:logic :program)))) short long def (when (eq mode :program)) events) nil nil nil nil) ((name ,) nil (car cdr ` ` ` , ,@ ,@ ,@) (intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol mksym or or) (er if) (er er er er er er er er) nil) ((X name A name N name Y name ACC name hard The formals must be a list of unique symbols, but the ~
            formals are ~x0. formals hard The formals must contain X, but are ~x0.~% formals hard As a special restriction, formals may not mention a, n, ~
            or y, but the formals are ~x0. formals hard The transform must be a function applied to the formals, ~
             but is ~x0. transform name transform transform hard The transform's formals do not agree with the defmapappend ~
             function's formals. hard :verify-guards must be a boolean, but is ~x0. verify-guards hard :transform-true-list-p must be a boolean, but is ~x0. transform-true-list-p hard :transform-exec must be a symbol, but is ~x0. transform-exec hard :mode must be :logic or :program, but is ~x0. mode short long name events) nil (quote quote quote quote quote quote quote quote quote quote (defund (, exec-fn) ((,@ formals) (, acc)) (declare (xargs :guard (, guard) :verify-guards nil)) (if (consp (, x)) ((, exec-fn) (,@ (subst (` (cdr (, x))) x formals)) (, (if transform-exec (` ((, transform-exec) (,@ (subst (` (car (, x))) x transform-args)) (, acc))) (` ((, (if transform-true-list-p (quote revappend) (quote revappend-without-guard))) ((, transform-fn) , (subst (` (car (, x))) x transform-args)) (, acc)))))) (, acc))) not `) (and and and and and) nil nil nil) ((defmapappend defmapappend defmapappend defmapappend -exec defmapappend defmapappend defmapappend defmapappend defmapappend parents parents program , rest parents short long rest) nil (, ,@ ,@ ,@ ,@ ,@ local ,@ ` ` `) nil ((encapsulate nil , events)) (str::cat defund defthm defthm defthm defthm defthm) nil) ((@(call  ) applies @(see  ) to every member of the list @('x'),  and appends together all the resulting lists. <p>This is an ordinary @(see defmapappend).</p> @(def  ) (,@ formals) name def def :hints (Goal :in-theory (enable (, name))) :hints (Goal :in-theory (enable (, name))) :hints (Goal :in-theory (enable (, exec-fn))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) , rest) nil (symbol-name symbol-name symbol-name , declare , , , , , :parents :short :long local) (and and and implies equal equal equal equal) (if) (mbe defthm) nil)))
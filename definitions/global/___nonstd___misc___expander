((/nonstd/misc/expander.lisp::silly-rec-fn-for-rewrite* (nil nil nil nil (if) nil nil) ((x) nil (consp recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::pop-clauses (nil nil nil nil nil (mv-let) nil) (nil nil (declare) (pop-clause1 cond) nil nil (signal)) ((pool-lst cl-set hint-settings pop-history new-pool pool nil) nil ((or (eq signal (quote win)) (eq signal (quote lose))) t) nil (ignore) nil nil) ((pool-lst hint-settings pop-history) nil nil (mv) (mv-let) nil nil) ((signal cl-set) nil (signal recursive-call) (cond) nil nil nil) ((rest-clauses new-pool) nil ((eq signal (quote win)) t) nil nil nil nil) (nil nil nil (mv mv) nil nil nil)) (/nonstd/misc/expander.lisp::prove-loop1-clauses (nil nil nil nil nil (sl-let) nil) (nil nil (declare) (cond) (erp) nil nil) ((pspv jppl-flg state pool-lst clauses pspv hints ens wrld ctx state) (0) (ignore erp t) (initial-step-limit) nil nil nil) ((wrld state jppl-flg) nil nil nil (mv-let) nil nil) ((step-limit t nil nil nil nil state) nil (signal pop-clauses) (cond) nil nil nil) ((new-clauses) nil ((eq signal (quote lose)) t) nil (access) nil nil) ((prove-spec-var pspv :pool) nil nil nil (mv-let) nil nil)) (/nonstd/misc/expander.lisp::prove-loop-clauses (nil nil nil (pprogn) nil nil nil) (nil nil nil (increment-timer) (sl-let) nil nil) ((state) nil (quote) (pprogn) nil nil (erp)) ((other-time ttree new-clauses pairs new-pspv state nil clauses pspv hints ens wrld ctx state) nil nil (increment-timer cond) nil nil nil) ((state) nil (quote erp t) nil nil nil nil) ((prove-time) nil nil nil nil nil nil) ((step-limit erp nil nil nil nil state step-limit nil ttree new-clauses pairs new-pspv state) nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::chk-for-hidden-expander-function1 (nil nil nil (let) nil nil nil) (((term (car (last cl)))) nil nil nil (case-match) nil nil) ((term) nil (((quote hide) ((quote hidden-expander-function) &)) t) nil nil nil nil) ((term) nil nil nil nil (er) nil) ((hard Expected clause to end with hidden call of ~
                      HIDDEN-EXPANDER-FUNCTION, but instead clause is ~p0. cl) nil (quote) nil nil nil nil) ((recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::chk-for-hidden-expander-function (nil nil nil (cond) nil nil nil) (nil nil ((null clauses) t) nil nil nil nil) ((nil) nil nil (and) nil nil nil) (nil nil (chk-for-hidden-expander-function1 recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((clauses clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::untranslate-clause-lst (nil nil nil (cond) nil nil nil) (nil nil ((null cl-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (prettyify-clause1 recursive-call) nil nil nil) ((wrld wrld) nil (car cdr) nil nil nil nil) ((cl-lst cl-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::hide-special-hyps (nil nil nil (cond) nil nil nil) (nil nil ((null lst) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((hyp (car lst))) nil nil (let) nil nil nil) (((new-hyp (case-match hyp (((quote equal) x y) (let ((x1 (if (variablep x) (list (quote hide) x) x)) (y1 (if (variablep y) (list (quote hide) y) y))) (list (quote equal) x1 y1))) (((quote synp) . x) (list (quote hide) (cons (quote synp) x))) (& hyp)))) nil nil (cons) nil nil nil) ((new-hyp) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil)) (/nonstd/misc/expander.lisp::fix-special-hyps (nil nil nil (cond) nil nil nil) (nil nil ((null lst) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((hyp (car lst))) nil nil (let) nil nil nil) (((new-hyp (case-match hyp (((quote not) ((quote equal) ((quote hide) x) ((quote hide) y))) (list (quote not) (list (quote equal) x y))) (((quote not) ((quote equal) ((quote hide) x) y)) (list (quote not) (list (quote equal) x y))) (((quote not) ((quote equal) y ((quote hide) x))) (list (quote not) (list (quote equal) y x))) (((quote not) ((quote hide) ((quote synp) . x))) (list (quote not) (cons (quote synp) x))) (& hyp)))) nil nil (cons) nil nil nil) ((new-hyp) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil)) (/nonstd/misc/expander.lisp::remove-hidden-terms (nil nil nil (cond) nil nil nil) (nil nil ((null cl-set) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (fix-special-hyps recursive-call) nil nil nil nil) (nil nil (cdr) (butlast) nil nil nil) ((cl-set) (1) (car) nil nil nil nil) ((cl-set) nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::add-key-val-pair-to-key-val-alist (nil nil nil nil (cond) nil nil) (nil nil ((null alist) (equal key (caar alist)) t) nil nil nil nil) (nil nil (list) (cons cons) nil nil nil) (nil nil (cdr car) nil (list) (list* recursive-call) nil) ((key key1 val key key1 val alist alist key key1 val) nil (cdar cdr) nil nil nil nil) ((alist alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::remove-hidden-expander-term-from-cl (nil nil nil (cond) nil nil nil) (nil nil ((endp cl) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (((term (car cl))) nil nil nil (case-match) nil nil) ((term) nil (((quote HIDE) ((quote HIDDEN-EXPANDER-FUNCTION) &)) &) nil nil nil nil) (nil nil (cdr) (cons) nil nil nil) ((cl) nil (car recursive-call) nil nil nil nil)) (/nonstd/misc/expander.lisp::remove-hidden-expander-term-from-cl-list (nil nil nil (cond) nil nil nil) (nil nil ((endp cl-list) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (remove-hidden-expander-term-from-cl recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((cl-list cl-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::get-assns (nil nil nil (cond) nil nil nil) (nil nil (remove-hidden t) nil nil nil nil) (nil nil (remove-hidden-expander-term-from-cl-list strip-cdrs) nil nil nil nil) (nil nil (strip-cdrs) (tagged-objects) nil nil nil) ((:bye ttree) nil nil (tagged-objects) nil nil nil) ((:bye ttree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::tool1-fn1 (nil nil nil (er-let*) nil nil nil) (nil nil nil nil (sl-let) nil nil) (nil nil (thints thyps0 thyps vars tconc tterm) (prog2$) nil nil (erp)) ((ttree clauses pairs new-pspv state tterm thints ens wrld ctx state) nil (value value value chk-for-hidden-expander-function) nil (if cond) nil (translate-hints)) ((hints ctx wrld state translate-flg t t t ctx wrld state ens wrld :displayed-goal :otf-flg t clauses) nil (quote value hide-special-hyps erp prove-assumptions t) (all-vars1-lst list implicate) (untranslate) nil nil) ((tool1 hyps t t t ctx wrld state hyps thyps0 thyps nil tconc tterm t wrld) nil (quote conjoin) (list er-let* let) (mv) nil nil) ((hide thyps erp nil state (thints (if (eq prove-assumptions t) (value thints) (translate-hints (quote tool1) *bash-skip-forcing-round-hints* ctx wrld state))) (runes (all-runes-in-ttree ttree nil))) nil (quote) (cons state-global-let* pprogn) nil nil nil)) (/nonstd/misc/expander.lisp::tool1-fn (nil nil nil (state-global-let*) nil nil nil) (nil nil ((ld-skip-proofsp nil)) (with-ctx-summarized) nil nil nil) ((( TOOL1 ...)) nil (inhibit-output-lst) (let) nil nil nil) (nil nil ((wrld (w state))) nil (if) nil nil) ((inhibit-output hyps ctx ens wrld state hints prove-assumptions inhibit-output translate-flg print-flg) nil (@ ens) nil (if) nil nil) ((*valid-output-names-except-error* inhibit-output-lst) nil (ens) (eq union-eq) nil nil nil) ((inhibit-output :prove state) nil (quote @) nil nil nil nil)) (/nonstd/misc/expander.lisp::tool1-fn0 (nil nil nil (state-global-let*) nil nil nil) (nil nil ((ld-skip-proofsp nil)) nil nil nil nil) ((hyps ctx ens wrld state hints prove-assumptions inhibit-output translate-flg print-flg) nil (inhibit-output-lst) nil nil nil nil) (nil nil nil nil (if) nil nil) ((inhibit-output) nil (@) nil (if) nil nil) ((*valid-output-names-except-error* inhibit-output-lst) nil nil (eq union-eq) nil nil nil) ((inhibit-output :prove) nil (quote @) nil nil nil nil)) (/nonstd/misc/expander.lisp::expander-repeat-limit (nil nil nil nil (if) nil nil) (nil (3) nil (f-boundp-global f-get-global) nil nil nil) ((state state) nil (quote quote) nil nil nil nil) ((recursive-call recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::tool2-fn1 (nil nil nil (let*) nil nil nil) (((saved-pspv (make-pspv ens wrld :displayed-goal term :user-supplied-term term :orig-hints thints))) nil nil (er-let*) nil nil nil) (nil nil ((thyps (if translate-flg (translate-term-lst hyps t t t ctx wrld state) (value hyps)))) nil (mv-let) nil nil) (nil nil (tterm) (erp cond) nil nil nil) ((pair state *initial-clause-id* nil saved-pspv ctx thints wrld nil state) nil (erp t) nil (if add-literal) nil nil) ((translate-flg tterm t) nil (value dumb-negate-lit-lst silent-error) (let) nil nil nil) ((term t t t ctx wrld state term thyps state) nil ((hint-settings (car pair))) nil (mv-let) nil nil)) (/nonstd/misc/expander.lisp::tool2-fn0 (nil nil nil (state-global-let*) nil nil nil) (((inhibit-output-lst (if inhibit-output (if (eq inhibit-output :prove) (union-eq (quote (proof-tree prove)) (@ inhibit-output-lst)) *valid-output-names-except-error*) (@ inhibit-output-lst)))) nil nil (prog2$) nil nil nil) (nil nil (initialize-brr-stack) (er-let*) nil nil nil) ((state (thints (translate-hints (quote tool2) hints ctx wrld state))) nil nil nil nil nil nil) ((term hyps equiv ctx ens wrld state thints prove-assumptions inhibit-output translate-flg print-flg must-rewrite-flg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::tool2-fn (nil nil nil (let) nil nil nil) (nil nil nil ((ctx (quote TOOL2))) nil nil nil) ((term hyps equiv ctx ens wrld state hints prove-assumptions inhibit-output translate-flg print-flg t) nil (wrld ens) nil nil nil nil) (nil nil (w ens) nil nil nil nil) ((state state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::tool2-fn-lst (nil nil nil (cond) nil nil nil) (nil nil ((null hyps-lst) t) nil nil nil nil) (nil nil (value) nil (mv-let) nil nil) ((nil) nil nil (erp cond) nil nil nil) ((x state term equiv state hints prove-assumptions inhibit-output nil print-flg) nil (car erp t) nil nil nil nil) ((hyps-lst) nil nil (er-let*) nil nil nil) ((term runes assns equiv state hints prove-assumptions inhibit-output print-flg (rst (tool2-fn-lst term runes (cdr hyps-lst) assns equiv state hints prove-assumptions inhibit-output print-flg))) nil (cdr value) nil nil nil nil)) (/nonstd/misc/expander.lisp::simplify-hyps (nil nil nil (cond) nil nil nil) (nil nil ((null remaining-hyps) t) nil nil nil nil) (nil nil (value) (er-let*) nil nil nil) (((x (tool2-fn (car remaining-hyps) (revappend rewritten-previous-hyps-rev (cdr remaining-hyps)) equiv state hints prove-assumptions inhibit-output nil print-flg))) nil nil nil (list*) nil nil) ((runes assns equiv state hints prove-assumptions inhibit-output print-flg) nil (list cdr) (cons union-equal union-equal) nil nil nil) ((remaining-hyps rewritten-previous-hyps-rev runes assns) nil (reverse cadr car cddr) nil nil nil nil) ((rewritten-previous-hyps-rev x x x) nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::tool-fn (nil nil nil (er-let*) nil nil nil) (((runes-hyps-assns (cond ((eq simplify-hyps-p :no-split) (simplify-hyps hyps nil nil nil equiv state hints prove-assumptions inhibit-output print-flg)) ((eq simplify-hyps-p t) (tool1-fn hyps state hints prove-assumptions inhibit-output nil print-flg)) (simplify-hyps-p (value (er hard (quote tool-fn) Bad :simplify-hyps-p argument (should be ~v0): ~x1 (list t nil :no-split) simplify-hyps-p))) (t (value (list* nil (list hyps) nil)))))) nil nil (cond) nil nil nil) (nil nil ((null (cdr runes-hyps-assns)) t) nil nil nil nil) (nil nil nil (pprogn) nil nil (er)) ((soft ctx It does not make sense to simplify the term ~p0, because the ~
                  hypothesis list ~p1 is contradictory.) nil nil (cond er-let*) (untranslate untranslate-lst) nil nil) ((term nil hyps t (x (tool2-fn-lst term (car runes-hyps-assns) (cadr runes-hyps-assns) (cddr runes-hyps-assns) equiv state hints prove-assumptions inhibit-output print-flg))) nil (w w print-flg t) nil (cond) nil nil) ((state state state) nil ((not (= (length x) (length (cadr runes-hyps-assns)))) x t) nil nil nil (fms))) (/nonstd/misc/expander.lisp::adjust-hints-with-runes1 (nil nil nil nil (cond) nil nil) (nil nil ((null hint) (eq (car hint) :in-theory) t) nil nil nil nil) (nil nil nil (list) (list* list*) nil nil) ((:in-theory :in-theory) nil (cddr car cadr) (recursive-call) (list list) nil nil) ((*adjust-hints-exec-theory* *adjust-hints-exec-theory* hint hint hint runes) nil (quote quote ` cddr) (list) nil nil nil) ((union-theories runes union-theories hint) nil (quote) (intersection-theories) nil nil nil) ((quote) nil (quote ,) nil nil nil nil)) (/nonstd/misc/expander.lisp::adjust-hints-with-runes (nil nil nil (cond) nil nil nil) (nil nil ((null hints) t) nil nil nil nil) (nil nil nil (cons) (if) nil nil) ((top-goal-seen-p nil) nil (`) (cons) (recursive-call) nil nil) (((Goal :in-theory (union-theories (, *adjust-hints-exec-theory*) (quote (, runes)))) runes) nil (caar cdr) (adjust-hints-with-runes1 or) nil nil nil) ((hints runes hints top-goal-seen-p) nil (cdar) (equal) nil nil nil) ((hints Goal) nil (caar) nil nil nil nil)) (/nonstd/misc/expander.lisp::defthm-?-fn-forms1-lst (nil nil nil (cond) nil nil nil) (nil nil ((null x) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (nil nil nil (cons) ((runes (set-difference-equal (car (car x)) *fake-runes*))) nil nil) (nil nil (hyps rhs assumptions `) nil nil nil nil) ((name equiv lhs hints wrld) nil (cadr caddr cdddr 1+ cdr) nil nil (defthm) nil) ((:hints index x) nil (car car car , , ,) nil nil nil nil)) (/nonstd/misc/expander.lisp::defthm?-fn-forms (nil nil nil (with-ctx-summarized) nil nil nil) (nil nil nil (cons er-let*) nil nil nil) ((name (tform (translate form t t t ctx wrld state))) nil (quote) (let*) nil nil nil) ((defthm?) nil nil ((x (unprettyify tform)) cond) nil nil nil) (nil nil (hyps concl (and (null (cdr x)) (not (variablep concl)) (not (fquotep concl)) (variablep (fargn concl 2))) t) nil nil nil nil) (nil nil (car cdr) (cond) nil nil nil) ((soft ctx The form supplied to DEFTHM? must be of the form ~p0 or ~p1,~
               where var is a variable.  But ~p2 is not of this form. form) nil (car car (equivalence-relationp (ffn-symb concl) wrld) t quote quote) nil nil nil nil)) (/nonstd/misc/expander.lisp::defthm?-fn (nil nil nil (state-global-let*) nil nil nil) (((inhibit-output-lst (if (boundp-global (quote defthm?-inhibit-output-lst) state) (f-get-global (quote defthm?-inhibit-output-lst) state) (@ inhibit-output-lst)))) nil nil (er-let*) nil nil nil) (((forms (defthm?-fn-forms name term simplify-hyps-p hints prove-assumptions nil print-flg wrld state))) nil nil (er-progn) nil nil nil) (nil nil (value) nil nil (encapsulate-fn) nil) ((nil state nil) nil nil (cons) (list*) nil nil) ((forms nil forms) nil (quote quote) nil nil nil nil) ((logic encapsulate) nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::symsim-fn (nil nil nil (er-let*) nil nil nil) (nil nil nil ((tterm (translate term t t t (quote top-level) wrld state)) pprogn) nil nil nil) (nil nil (thyps tuples-lst value) nil (if) nil nil) ((print-flg state tuples-lst) nil nil nil nil nil (symsim-fn-print-lst)) ((hyps t t t wrld state tterm thyps simplify-hyps-p state hints prove-assumptions inhibit-output print-flg tuples-lst wrld state) (1) (quote quote length) (cons) nil nil nil) ((top-level equal term tuples-lst) nil (quote) nil nil nil nil) ((recursive-call) nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::normalize-no-ttree (nil nil nil nil nil (mv-let) nil) ((x) nil (x declare) nil nil nil nil) ((ttree term iff-flg type-alist ens wrld nil) nil (ignore) nil nil nil nil) ((ttree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::simp-hyps-aux (nil nil nil (cond) nil nil nil) (nil nil ((null hyps-remaining) t) nil nil nil nil) (nil nil (value) (let*) nil nil nil) (nil nil (reverse) ((hyp0 (car hyps-remaining))) (mv-let) nil nil) ((hyps-res) nil (hyp other-hyps) (erp let*) nil nil nil) ((x state hyp other-hyps ctx ens wrld state hints nil inhibit-output nil print-flg nil) nil (quote) (remove1-equal) (if) nil (normalize-no-ttree)) ((hyp0 t nil ens wrld hyp0 hyps-init iff simplified-to-nil?) nil (simplified-to-t? simplified-to-nil? simplified? always-simp? nhyps-init nhyps-res value) nil nil nil nil)) (/nonstd/misc/expander.lisp::simp-hyps0 (nil nil nil (let) nil nil nil) (((nd-hyps (remove-duplicates hyps))) nil nil (er-let*) nil nil nil) (((t-nd-hyps (simp-hyps-aux nd-hyps nd-hyps nil ctx ens wrld state hints inhibit-output print-flg :t))) nil nil nil (if) nil nil) (nil nil (value) (equal) nil nil nil) ((simp-flg :t t-nd-hyps t-nd-hyps t-nd-hyps nil ctx ens wrld state hints inhibit-output print-flg simp-flg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/expander.lisp::simp-hyps (nil nil nil nil nil nil nil) ((hyps state hints inhibit-output print-flg simp-flg) nil (quote ens w) nil nil nil nil) ((SIMP-HYPS state state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
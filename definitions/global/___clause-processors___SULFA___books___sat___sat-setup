((/clause-processors/SULFA/books/sat/sat-setup.lisp::valid-varp (nil nil nil (and) nil nil nil) (nil nil (integerp) (<) nil nil nil) ((var var) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::zero-sat-input-channel (nil nil nil (let) nil nil nil) (((channel (sat-input-channel $sat))) nil nil (cond) nil nil nil) (nil nil (channel t) nil nil nil nil) (nil nil nil (let* mv) nil nil nil) (($sat state) nil ((state (close-output-channel (sat-input-channel $sat) state))) (mv) nil nil nil) (($sat state) nil ($sat) nil nil nil nil) (nil nil nil (update-sat-input-channel) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::zero-sat-stobj (nil nil nil (let*) nil nil nil) (nil nil nil (zero-sat-input-channel) nil nil nil) (($sat state) nil ($sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat) nil nil nil nil) (nil nil nil (update-num-i-vars resize-car-var resize-cdr-var resize-cons-var update-stack-number update-traversal-number resize-stack-num resize-traversal-num resize-relevant-ivar resize-todo-struct update-num-f-vars resize-relevant-fvar resize-eq-nil-var resize-consp-var resize-eq-const-struct-var resize-eq-alist-var resize-ce-val resize-ce-i-var-val update-unused-num update-var-stack update-top-var-stack update-completed-var-list update-top-completed-var-list update-input-alist update-num-f-clauses update-num-f-clauses-pre-explore resize-top-var-eql resize-pos-var resize-neg-var update-num-cete update-un-fn-list update-problem-stack-depth update-explore-var-list update-curr-ord-entry-list update-saved-ord-entry-list update-exploration-val-list update-un-fn-world) nil nil nil) (($sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat nil $sat nil $sat nil $sat nil $sat nil $sat $sat $sat $sat $sat $sat $sat nil $sat $sat nil $sat nil $sat nil $sat nil $sat nil $sat) (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::zero-ce-vals (nil nil nil (let*) nil nil nil) (($sat) nil nil (($sat (resize-ce-val 0 $sat))) nil nil nil) (nil nil ($sat $sat) nil nil nil nil) (nil nil nil (resize-ce-i-var-val update-unused-num) nil nil nil) (($sat $sat) (0 0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::zero-sat-stobj! (nil nil nil nil (mv-let) nil nil) (nil nil ($sat) (zero-sat-stobj let*) nil nil nil) ((state $sat state) nil nil (($sat (zero-ce-vals $sat)) mv) nil nil nil) (($sat state) nil ($sat $sat) nil nil nil nil) (nil nil nil (update-props-world update-NLA-table) nil nil nil) ((nil $sat nil $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::construct-sat-stobj (nil nil nil (let*) nil nil nil) (($sat) nil nil nil nil nil nil) (nil nil ($sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat) nil nil nil nil) (nil nil nil (resize-car-var resize-cdr-var resize-cons-var resize-stack-num resize-traversal-num resize-eq-const-struct-var resize-eq-alist-var resize-relevant-ivar resize-todo-struct resize-relevant-fvar resize-eq-nil-var resize-consp-var resize-top-var-eql resize-pos-var resize-neg-var) nil nil nil) (($sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat $sat) nil (1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+ 1+) nil nil nil nil) ((*max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars* *max-vars*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::top-varp (nil nil nil (equal) nil nil nil) (nil (1) nil (top-var-eqli) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::construct-ce-vals (nil nil nil (let*) nil nil nil) (($sat) nil (($sat (resize-ce-val *max-vars* $sat))) nil nil nil nil) (nil nil ($sat) nil nil nil nil) (nil nil nil (resize-ce-i-var-val) nil nil nil) ((*max-vars* $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::fn-formals (nil nil nil (cond) nil nil nil) (nil nil ((consp fn) t) nil nil nil nil) (nil nil (cadr) (let) nil nil nil) ((fn (formals (getprop fn (quote acl2::formals) (quote not-found) (quote acl2::current-acl2-world) (w state)))) nil nil nil (if) nil nil) ((formals) nil (not) nil nil (er) nil) ((hard Unable to get formals of function ~x0 ~% fn) nil (quote) (equal) nil nil nil) ((formals recursive-call) nil (quote) nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::fn-body! (nil nil nil (cond) nil nil nil) (nil nil ((consp fn) t) nil nil nil nil) (nil nil (caddr) nil nil nil (getprop)) ((fn fn nil) nil (quote quote w) nil nil nil nil) ((acl2::unnormalized-body acl2::current-acl2-world state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::fn-body (nil nil nil (let) nil nil nil) (((body (fn-body! fn state))) nil nil nil (if) nil nil) ((body body) nil nil nil nil nil (er)) ((hard Unable to get body of function ~x0, returned ~x1 ~% fn body) nil (quote) nil nil nil nil) ((recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::concat-macro (nil nil nil nil (if) nil nil) ((nil) nil (consp) nil (if) nil nil) ((lst) nil (consp car) (cons) nil nil nil) ((lst) nil (cdr quote) (cons) nil nil nil) ((lst concatenate) nil (quote) (cons) nil nil nil) (nil nil (quote car) (cons) nil nil nil) ((string lst) nil (recursive-call quote) nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::get-unused-number (nil nil nil (let*) nil nil nil) (nil nil ((n (unused-num $sat))) (mv) nil nil nil) ((n $sat) nil ($sat) nil nil nil nil) (nil nil nil (update-unused-num) nil nil nil) (($sat) nil (1+) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::num-to-str (nil nil nil (coerce) nil nil nil) (nil nil (quote) nil (explode-nonnegative-integer) nil nil) ((n nil string) (10) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::add-input-alist-entry (nil nil nil (update-input-alist) nil nil nil) (($sat) nil nil (cons) nil nil nil) (nil nil (input-alist) (cons) nil nil nil) ((input-var i0 $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::constp (nil nil nil nil (if) nil nil) ((nil) nil (atom quotep) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::++i-var (nil nil nil (let*) nil nil nil) (nil nil nil ((i-var (num-i-vars $sat)) mv) nil nil nil) ((i-var $sat) nil (i-var $sat) nil nil nil nil) (nil nil (1+) (update-num-i-vars) nil nil nil) ((i-var i-var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::++f-var (nil nil nil (let*) nil nil nil) (nil nil nil (mv) ((f-var (num-f-vars $sat))) nil nil) ((f-var $sat) nil (f-var $sat $sat) nil nil nil nil) (nil nil (1+) (update-num-f-vars) (update-relevant-fvari) nil nil) ((f-var f-var $sat f-var $sat) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::irrelevant-ivarp (nil nil nil (equal) nil nil nil) (nil (0) nil (relevant-ivari) nil nil nil) ((i-var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::relevant-f-varp (nil nil nil (equal) nil nil nil) (nil (1) nil (relevant-fvari) nil nil nil) ((f-var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::mark-ivar-relevant (nil nil nil (cond) nil nil nil) (nil nil ((equal (relevant-ivari var $sat) 1) t) nil nil nil nil) (($sat) nil nil (let*) nil nil nil) (nil nil (($sat (update-relevant-ivari var 1 $sat))) (cond) nil nil nil) (nil nil (parent (not (valid-varp parent)) t) nil nil nil nil) (($sat) nil nil (cons-vari recursive-call) nil nil nil) ((var $sat parent $sat) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::mark-fvar-irrelevant (nil nil nil nil (if) nil nil) (($sat) nil (valid-varp) nil (update-relevant-fvari) nil nil) ((f-var f-var $sat) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::mark-alist-irrelevant (nil nil nil (cond) nil nil nil) (nil nil ((endp alist) t) nil nil nil nil) (($sat) nil nil nil (update-relevant-fvari) nil nil) (($sat) (0) (cdr) nil nil nil nil) (nil nil (car) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::mark-ivar-irrelevant (nil nil nil (let*) nil nil nil) (nil nil nil nil (if) nil nil) (($sat) nil ($sat $sat eq-const-struct $sat $sat $sat car-var cdr-var $sat) (and recursive-call) nil nil nil) ((cdr-var $sat) nil (valid-varp) (mark-fvar-irrelevant mark-fvar-irrelevant eq-const-struct-vari mark-fvar-irrelevant mark-alist-irrelevant mark-alist-irrelevant car-vari cdr-vari equal) (if) nil nil) (($sat $sat var $sat $sat $sat $sat var $sat var $sat $sat cdr-var) (1) (car cdr) (eq-nil-vari consp-vari eq-alist-vari and recursive-call relevant-ivari) nil nil nil) ((var $sat var $sat eq-const-struct var $sat eq-const-struct car-var $sat cdr-var $sat) nil (valid-varp) (equal) nil nil nil) ((car-var) (1) nil (relevant-ivari) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::eq-t-vari (nil nil (car) nil nil nil nil) (nil nil nil (eq-const-struct-vari) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::valid-Booleanp (nil nil nil (or) nil nil nil) (nil nil (valid-varp valid-varp) nil nil nil nil) (nil nil nil (eq-nil-vari eq-t-vari) nil nil nil) ((var $sat var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::insert-after-relevant-vars (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (relevant-f-varp (cdr (car alist)) $sat) t) nil nil nil nil) (nil nil nil (revappend revappend) nil nil (recursive-call)) ((front-ans key val $sat front-ans) nil (list cdr) (cons cons) nil nil nil) ((alist front-ans alist) nil (car) (cons cons) nil nil nil) ((key val alist key val) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::add-alist-entry (nil nil nil nil (cond) nil nil) (nil nil ((not (valid-varp f-var)) (relevant-f-varp f-var $sat) t) nil nil nil nil) ((alist) nil nil (cons) nil nil (insert-after-relevant-vars)) ((alist key f-var alist nil $sat) nil nil (cons) nil nil nil) ((key f-var) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::non-nil-atoms-alist-vari (nil nil nil (let*) nil nil nil) (nil nil nil ((eq-const-struct (eq-const-struct-vari var $sat))) nil (add-alist-entry) nil) ((t eq-t eq-const-alist $sat) nil (eq-t eq-const-alist) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((eq-const-struct eq-const-struct) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::atoms-alist-vari (nil nil nil (let*) nil nil nil) (nil nil ((eq-nil (eq-nil-vari var $sat))) nil nil (add-alist-entry) nil) ((nil eq-nil non-nil-atoms $sat) nil (non-nil-atoms) nil nil nil nil) (nil nil nil (non-nil-atoms-alist-vari) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::pop-eq-atom-entry (nil nil nil (let*) nil nil nil) (nil nil nil nil ((eq-nil (eq-nil-vari var $sat))) (cond) nil) (nil nil (eq-const-struct eq-t eq-const-alist (valid-varp eq-nil) (valid-varp eq-t) (endp eq-const-alist) t) nil nil nil nil) (nil nil (car cdr) (eq-const-struct-vari let let* let*) (mv) nil nil) ((var $sat eq-const-struct eq-const-struct ($sat (update-eq-nil-vari var 0 $sat)) $sat) (0 0) ((eq-const-struct (cons 0 eq-const-alist))) nil (mv mv (a (caar eq-const-alist)) mv) nil nil) ((nil eq-nil $sat t eq-t $sat a eq-var-a $sat) nil ($sat eq-var-a eq-const-struct $sat) nil nil nil nil) (nil nil (cdar) (cons) (update-eq-const-struct-vari update-eq-const-struct-vari) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::pop-eq-alist-entry (nil nil nil (let*) nil nil nil) (((eq-alist (eq-alist-vari var $sat))) nil nil (cond) nil nil nil) (nil nil ((endp eq-alist) t) nil nil nil nil) (nil nil nil (let*) (mv) nil nil) (($sat) (0 0) nil ((y (caar eq-alist))) (mv) nil nil) ((y eq-var-y $sat) nil (eq-var-y $sat) nil nil nil nil) (nil nil (cdar) nil (update-eq-alist-vari) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::unravel-atoms-alist (nil nil nil nil nil (cond) nil) (nil nil ((endp atoms-alist) (eq nil (caar atoms-alist)) (eq t (caar atoms-alist)) t) nil nil nil nil) (nil nil nil nil (mv mv-let) (mv-let mv-let) nil) ((nil) (0 0) (recursive-call declare recursive-call declare recursive-call) (eq-nil eq-nil eq-nil) (mv mv mv) nil nil) ((eq-t non-nil-atoms eq-t non-nil-atoms eq-t non-nil-atoms eq-nil non-nil-atoms eq-t non-nil-atoms eq-nil eq-t) nil (cdr ignore cdar cdr ignore cdar cdr) (cons) nil nil nil) ((atoms-alist eq-nil atoms-alist atoms-alist eq-t atoms-alist atoms-alist non-nil-atoms) nil (car) nil nil nil nil) ((atoms-alist) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::update-atoms-alist-vari (nil nil nil nil (mv-let) nil nil) (nil nil (unravel-atoms-alist) (eq-nil let*) nil nil nil) ((eq-t non-nil-atoms atoms-alist) nil (($sat (update-eq-nil-vari var eq-nil $sat))) nil (update-eq-const-struct-vari) nil nil) ((var eq-const-struct $sat) nil (eq-const-struct) nil nil nil nil) (nil nil nil (cons) nil nil nil) ((eq-t non-nil-atoms) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::create-eq-nil-var (nil nil nil (let) nil nil nil) (((eq-nil-var (eq-nil-vari var $sat))) nil nil nil (if) nil nil) (nil nil (valid-varp) (mv) (mv-let) nil nil) ((eq-nil-var eq-nil-var $sat) nil (eq-nil-var ++f-var) (let*) nil nil nil) (($sat $sat) nil (($sat (update-eq-nil-vari var eq-nil-var $sat))) (mv) nil nil nil) ((eq-nil-var $sat) nil ($sat) nil nil nil nil) (nil nil nil (mark-ivar-relevant) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::lookup-atom-var (nil nil nil nil (cond) nil nil) (nil nil ((eq a nil) (eq a t) t) nil nil nil nil) (nil nil nil (eq-nil-vari eq-t-vari let*) nil nil nil) ((var $sat var $sat) nil nil ((eq-const-struct (eq-const-struct-vari var $sat))) (if) nil nil) ((eq-const-entry) (0) (eq-const-alist eq-const-entry cdr) nil nil nil nil) ((eq-const-entry) nil (cdr) (assoc-equal) nil nil nil) ((eq-const-struct a eq-const-alist) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::create-atom-var (nil nil nil nil (cond) nil nil) (nil nil ((eq a nil) (eq a t) t) nil nil nil nil) (nil nil nil (create-eq-nil-var let let*) nil nil nil) ((var $sat (eq-const-struct (eq-const-struct-vari var $sat))) nil nil ((eq-const-struct (eq-const-struct-vari var $sat))) (if if) nil nil) ((eq-const-entry) nil (valid-varp eq-const-alist eq-const-entry) (mv mv) (mv-let mv-let) nil nil) (($sat $sat) nil (car car eq-t-var ++f-var cdr cdr eq-a-var ++f-var) (let* assoc-equal let*) nil nil nil) ((eq-const-struct eq-const-struct $sat $sat eq-const-struct a eq-const-alist eq-const-entry $sat $sat) nil (($sat (update-eq-const-struct-vari var (cons eq-t-var (cdr eq-const-struct)) $sat))) (mv (eq-const-alist (cons (cons a eq-a-var) eq-const-alist)) mv) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::create-consp-var (nil nil nil (let) nil nil nil) (((consp-var (consp-vari var $sat))) nil nil nil (if) nil nil) (nil nil (valid-varp) (mv) (mv-let) nil nil) ((consp-var consp-var $sat) nil (consp-var ++f-var) (let*) nil nil nil) (($sat $sat) nil (($sat (update-consp-vari var consp-var $sat))) (mv) nil nil nil) ((consp-var $sat) nil ($sat) nil nil nil nil) (nil nil nil (mark-ivar-relevant) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::rev-append (nil nil nil nil (if) nil nil) ((y) nil (endp) (recursive-call) nil nil nil) ((x) nil (cdr) (cons) nil nil nil) ((x y) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::remove-alist-entry (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (equal (caar alist) key) t) nil nil nil nil) ((ans) nil nil (rev-append) (recursive-call) nil nil) ((ans key) nil (cdr cdr) (cons) nil nil nil) ((alist alist ans) nil (car) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::delete-first-equality (nil nil nil nil (update-eq-alist-vari) nil nil) ((i0 $sat) nil (cdr) nil nil nil nil) (nil nil nil (eq-alist-vari) nil nil nil) ((i0 $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::contains-non-const-eqp (nil nil (not) nil nil nil nil) (nil nil nil (eq) nil nil nil) ((nil) nil nil (eq-alist-vari) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::get-car-var (nil nil nil (let) nil nil nil) (((car-var (car-vari var $sat))) nil nil nil (if) nil nil) (nil nil (valid-varp) (mv) (mv-let) nil nil) ((car-var car-var $sat) nil (car-var ++i-var) (let*) nil nil nil) (($sat $sat) nil (($sat (update-car-vari var car-var $sat))) (mv) nil nil nil) ((car-var $sat) nil ($sat) nil nil nil nil) (nil nil nil nil (update-cons-vari) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::get-cdr-var (nil nil nil (let) nil nil nil) (((cdr-var (cdr-vari var $sat))) nil nil nil (if) nil nil) (nil nil (valid-varp) (mv) (mv-let) nil nil) ((cdr-var cdr-var $sat) nil (cdr-var ++i-var) (let*) nil nil nil) (($sat $sat) nil (($sat (update-cdr-vari var cdr-var $sat))) (mv) nil nil nil) ((cdr-var $sat) nil ($sat) nil nil nil nil) (nil nil nil nil (update-cons-vari) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::pop-traversal-var (nil nil nil (let) nil nil nil) (((var-stack (var-stack $sat))) nil nil (cond) nil nil nil) (nil nil ((endp var-stack) t) nil nil nil nil) (nil nil nil (let let*) nil nil nil) (((top-var-stack (top-var-stack $sat))) nil nil (cond) (mv) nil nil) ((nil var $sat) nil ((endp top-var-stack) t var $sat traversal-number $sat $sat $sat) nil nil nil nil) (nil nil (car 1+) (let* update-traversal-number update-completed-var-list) (mv update-stack-numi update-traversal-numi) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::push-defined-traversal-var (nil nil nil (let*) nil nil nil) (nil nil nil (update-var-stack) ((stack-number (1+ (stack-number $sat)))) nil nil) ((var-stack $sat) nil ($sat $sat var-stack) nil nil nil nil) (nil nil nil (update-stack-number cons) (update-stack-numi) nil nil) ((stack-number $sat var stack-number $sat var) nil (var-stack) nil nil nil nil) (($sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::push-top-traversal-var (nil nil nil (let*) nil nil nil) (nil nil nil (update-top-var-stack) nil ((stack-number (1+ (stack-number $sat)))) nil) ((top-var-stack $sat) nil ($sat $sat $sat top-var-stack) nil nil nil nil) (nil nil nil (update-stack-number cons) (update-top-var-eqli update-stack-numi) nil nil) ((var $sat stack-number $sat var stack-number $sat var) (1) (top-var-stack) nil nil nil nil) (($sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::logical-car (nil nil nil nil (if) nil nil) ((nil) nil (consp car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::logical-cdr (nil nil nil nil (if) nil nil) ((nil) nil (consp cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::constrained-fnp (nil nil nil (cond) nil nil nil) (nil nil ((consp fn) t) nil nil nil nil) ((nil) nil nil nil nil nil (getprop)) ((fn nil) nil (quote quote w) nil nil nil nil) ((acl2::constrainedp acl2::current-acl2-world state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::uninterpreted-fnp (nil nil nil nil (cond) nil nil) (nil nil ((consp fn) (getprop fn (quote uninterpreted-functionp) nil (quote props-world) (props-world $sat)) t) nil nil nil nil) ((nil t) nil nil (and) nil nil nil) (nil nil nil (eq) nil nil (getprop)) ((fn nil nil) nil (quote quote w) nil nil nil (getprop)) ((acl2::constrainedp acl2::current-acl2-world state fn t) nil (quote quote w) nil nil nil nil) ((acl2::constraint-lst acl2::current-acl2-world state) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::set-un-fn-mark (nil nil nil (update-props-world) nil nil nil) (($sat) nil nil nil nil (putprop) nil) ((fn val) nil (quote props-world) nil nil nil nil) ((uninterpreted-functionp $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::on-stackp (nil nil (not) nil nil nil nil) (nil nil nil (equal) nil nil nil) (nil (0) nil (stack-numi) nil nil nil) ((ivar $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::traversed-prior-top (nil nil nil nil nil nil (cond)) (nil nil ((top-varp i0 $sat) (top-varp i1 $sat) (on-stackp i0 $sat) (on-stackp i1 $sat) t) nil nil nil nil) ((t t) nil nil (cond cond <) nil nil nil) (nil nil ((top-varp i1 $sat) t (on-stackp i1 $sat) t) (traversal-numi traversal-numi) nil nil nil) ((nil nil i0 $sat i1 $sat) nil nil (< <) nil nil nil) ((i1 i0) nil nil (stack-numi stack-numi) nil nil nil) ((i1 $sat i0 $sat) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::get-cons-structure (nil nil nil (let) nil nil nil) (((cons-var (cons-vari i0 $sat))) nil nil nil (cond) nil nil) (nil nil ((not (valid-varp cons-var)) (equal i0 (car-vari cons-var $sat)) t) nil nil nil nil) (nil nil nil (mv) (recursive-call recursive-call) nil nil) ((i0 acc cons-var $sat cons-var $sat) nil nil (cons cons) nil nil nil) ((acc acc) nil (quote quote) nil nil nil nil) ((car cdr) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::traversed-prior-cons (nil nil nil nil (cond) nil nil) (nil nil ((or (endp i0-car-cdr-list) (endp i1-car-cdr-list)) (eq (car i0-car-cdr-list) (car i1-car-cdr-list)) t) nil nil nil nil) (nil nil nil (mv recursive-call mv) nil nil nil) ((t nil) nil (endp cdr cdr) (eq) nil nil nil) ((i1-car-cdr-list i0-car-cdr-list i1-car-cdr-list) nil (car quote) nil nil nil nil) ((i0-car-cdr-list cdr) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::traversed-prior (nil nil nil nil (mv-let) nil nil) (nil nil (i0-top) nil (get-cons-structure mv-let) nil nil) ((i0-car-cdr-list i0 nil $sat) nil (i1-top) (cond) (get-cons-structure) nil nil) ((i1-car-cdr-list i1 nil $sat) nil ((equal i0-top i1-top) t) nil nil nil nil) (nil nil nil (traversed-prior-cons mv) nil nil nil) ((i0-car-cdr-list i1-car-cdr-list nil) nil nil nil (traversed-prior-top) nil nil) ((i0-top i1-top $sat) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::lookup-eq-var (nil nil nil (cond) nil nil nil) (nil nil ((equal i0 i1) t) nil nil nil nil) ((*f-true*) nil nil nil (mv-let) nil nil) (nil nil (subsetp) nil (traversed-prior cond) nil nil) ((i0-pt-i1 i0 i1 $sat) nil (subsetp i0-pt-i1 t) nil nil nil nil) (nil nil nil (let* let*) (if) nil nil) ((i0-pt-i1) nil ((eq-alist (eq-alist-vari i0 $sat)) (eq-alist (eq-alist-vari i1 $sat))) (eq-nil-vari eq-nil-vari) (if if) nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::create-eq-var1 (nil nil nil (let*) nil nil nil) (nil nil ((eq-alist (eq-alist-vari i0 $sat))) (cond) nil nil nil) (nil nil (eq-entry eq-entry t) nil nil nil nil) (nil nil nil (assoc-equal mv) (mv-let) nil nil) ((i1 eq-alist $sat) nil (cdr f-var ++f-var) (let*) nil nil nil) ((eq-entry $sat $sat) nil (($sat (update-eq-alist-vari i0 (cons (cons i1 f-var) (eq-alist-vari i0 $sat)) $sat))) (mv) nil nil nil) ((f-var $sat) nil ($sat) nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::create-eq-var (nil nil nil (cond) nil nil nil) (nil nil ((equal i0 i1) t) nil nil nil nil) (nil nil nil (mv) (mv-let) nil nil) ((*f-true* $sat) nil (subsetp) nil (traversed-prior cond) nil nil) ((i0-pt-i1 i0 i1 $sat) nil (subsetp i0-pt-i1 t) nil nil nil nil) (nil nil nil nil (if create-eq-var1 create-eq-var1) nil nil) ((i0-pt-i1 i0 i1 $sat i1 i0 $sat) nil nil (create-eq-nil-var create-eq-nil-var) nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::quote-list (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) (nil nil nil (revappend recursive-call) nil nil nil) ((acc nil) nil (cdr) (cons) nil nil nil) ((x acc) nil (`) nil nil nil nil) (nil nil (quote) nil nil nil nil) (nil nil (,) nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::ce-val-unknownp (nil nil nil (or) nil nil nil) (nil nil nil (equal eq) nil nil nil) ((val val) nil (quote quote) nil nil nil nil) ((sat::unknown) nil (quote) nil nil nil nil) ((sat::unknown) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::ce-val-unknown-listp (nil nil nil nil (cond) nil nil) (nil nil ((endp val-list) (ce-val-unknownp (car val-list)) t) nil nil nil nil) ((nil t) nil (recursive-call) nil nil nil nil) (nil nil (cdr) nil nil nil nil) ((val-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::ce-val-consp (nil nil nil (cond) nil nil nil) (nil nil ((ce-val-unknownp x) t) nil nil nil nil) (nil nil (quote consp) nil nil nil nil) ((sat::unknown x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::ce-val-cons (nil nil nil (cond) nil nil nil) (nil nil ((or (ce-val-unknownp x) (ce-val-unknownp y)) t) nil nil nil nil) (nil nil (quote) (cons) nil nil nil) ((sat::unknown x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::ce-val-equal (nil nil nil (cond) nil nil nil) (nil nil ((or (ce-val-unknownp x) (ce-val-unknownp y)) t) nil nil nil nil) (nil nil (quote) (equal) nil nil nil) ((sat::unknown x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/sat-setup.lisp::print-msg (nil nil nil nil (if) nil nil) ((nil) nil nil (>) nil (fmt-to-comment-window) nil) ((verbosity nil) (0) (verbosity car cdr) nil nil nil nil) (($sat msg msg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/models/jvm/m5/partial.lisp::halfa (nil nil nil nil (if) nil nil) ((a) nil (zp) (recursive-call) nil nil nil) ((n) nil (int-fix) (-) nil nil nil) ((n) (2) nil (+) nil nil nil) ((a) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::half-assertion (nil nil nil (let) nil nil nil) (nil nil nil ((n (nth 0 (locals (top-frame th s)))) and) nil nil nil) (nil nil (a stack) (equal) nil nil (case)) ((*half-prog*) nil (stack program pc 0 2 18 otherwise) (nth) nil nil nil) ((nil) (1) (locals) (top-frame top-frame top-frame and) (and) nil (and)) ((th s th s th s) nil (intp intp intp evenp) (top-frame equal <= <= iff equal) (if) nil nil) ((th s n n0 n0 n0 n0 n0 n n0) (0 0) (not evenp evenp top) (and equal halfa) nil nil nil)) (/models/jvm/m5/partial.lisp::mono-threadedp (nil nil nil nil (if) nil nil) ((t) nil (endp) (and) nil nil nil) ((sched) nil nil (equal recursive-call) nil nil nil) ((th th) nil (car cdr) nil nil nil nil) ((sched sched) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::suma (nil nil nil nil (if) nil nil) ((a) nil (zp) (recursive-call) nil nil nil) ((n) nil (int-fix) (-) nil nil nil) ((n) (1) nil (+) nil nil nil) ((n a) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::sum-assertion (nil nil nil (let) nil nil nil) (nil nil nil ((n (nth 0 (locals (top-frame th s)))) and) nil nil nil) (nil nil (a stack) (equal) nil nil (case)) ((*sum-prog*) nil (stack program pc 0 2 18 otherwise) (nth) nil nil nil) ((nil) (1) (locals) (top-frame top-frame top-frame equal) (and) nil (and)) ((th s th s th s) nil (intp intp intp top) (top-frame equal <= <= <= equal suma) nil nil nil) ((th s n n0 n0 n0 n0 n n n n0 stack n0) (0 0 0) nil (suma suma) nil nil nil)) (/models/jvm/m5/partial.lisp::fact-caller-framesp (nil nil nil nil (cond) nil nil) (nil nil ((zp k) (and (equal (pc (top cs)) 11) (equal (program (top cs)) (cdddr *fact-def*)) (equal (sync-flg (top cs)) (quote UNLOCKED)) (intp (nth 0 (locals (top cs)))) (equal (+ n0 (- k)) (- (nth 0 (locals (top cs))) 1)) (equal (nth 0 (locals (top cs))) (top (stack (top cs))))) t) nil nil nil nil) ((t nil) nil nil nil (recursive-call) nil nil) ((n0) nil (pop) (-) nil nil nil) ((cs k) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::stack-product (nil nil nil (cond) nil nil nil) (nil nil ((zp k) t) nil nil nil nil) (nil (1) nil (*) nil nil nil) (nil nil nil (recursive-call) (+) nil nil) ((n0 n0) (1) (-) (-) nil nil nil) ((k k) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::sdepth (nil nil nil nil (if) nil nil) (nil (0) (endp) (+) nil nil nil) ((stk) (1) (recursive-call) nil nil nil nil) (nil nil (pop) nil nil nil nil) ((stk) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/models/jvm/m5/partial.lisp::fact-assertion (nil nil nil (cond) nil nil nil) (nil nil ((< (sdepth (call-stack th s)) d0) t) nil nil nil nil) (nil nil nil (equal let) nil nil nil) (((n (nth 0 (locals (top-frame th s))))) nil (top int-fix) nil nil nil nil) (nil nil (stack factorial intp intp) (equal equal equal <= <= equal equal) (fact-caller-framesp) (case) nil) ((n0 *fact-def* n0 n n n n0 n0) (0) (program cdddr sync-flg quote sdepth pop int-fix int-fix pc 0 (12 14) otherwise) (top-frame + -) (lookup-method) nil nil) ((th s *fact-def* fact Demo UNLOCKED d0 n0 n t nil) nil (class-table factorial) (top-frame top-frame call-stack - call-stack * top-frame equal) nil nil nil)) (/models/jvm/m5/partial.lisp::run-to-return (nil nil nil nil (cond) nil nil) (nil nil ((endp sched) (<= d0 (sdepth (call-stack th s))) t) nil nil nil nil) ((s s) nil nil nil nil (recursive-call) nil) ((th d0) nil (cdr) (step) nil nil nil) ((sched s) nil (car) nil nil nil nil) ((sched) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/coi/adviser/adviser-definitions.lisp::rewriting-goal-lit (nil nil (null) nil nil nil nil) (nil nil (mfc-ancestors) nil nil nil nil) ((mfc) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::rewriting-conc-lit (nil nil nil (let) nil nil nil) (((clause (mfc-clause mfc))) nil nil (member-equal) nil nil nil) ((term) nil (last) nil nil nil nil) ((clause) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::aux-symbols (nil nil nil nil (if) nil nil) ((acc) nil (zp) (recursive-call) nil nil nil) ((n) nil (1-) (cons) nil nil nil) ((n acc) nil nil (intern-in-package-of-symbol) nil nil nil) (nil nil (quote) nil (concatenate) nil nil) ((X defthm) nil (quote) (coerce) nil nil nil) ((string) nil (quote) (explode-atom) nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-term-syntax-ok-p1 (nil nil nil nil (if) nil nil) (nil nil (atom null) nil nil (and) nil) ((x x) nil (true-listp symbolp recursive-call) (equal) nil nil nil) (nil (1) (car len first cdr) nil nil nil nil) ((x x) nil (car car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-term-syntax-ok-p (nil nil nil nil nil (and) nil) (nil nil (true-listp) (equal equal let) nil nil nil) ((term) (3) (len first quote (hypothesis (second term))) nil nil nil nil) ((term term implies) nil (conclusion true-listp symbolp true-listp consp) (equal cond) nil nil nil) ((hypothesis conclusion conclusion) (1) (third len first (eq (car conclusion) (quote not)) t) nil nil nil nil) ((term hypothesis hypothesis) nil nil (let) (and) nil nil) (((conclusion (cadr conclusion))) nil (symbolp pick-a-point-term-syntax-ok-p1) (<=) (and) nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-rule-classes-syntax-ok-p (nil nil nil nil nil nil (and)) (nil nil (true-listp symbolp) (= eq eq) nil nil nil) ((x :pick-a-point :driver) (3) (length first second third) nil nil nil nil) ((x x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-rule-syntax-check (nil nil nil nil nil (cond) nil) (nil nil ((not (symbolp name)) (not (pick-a-point-term-syntax-ok-p term)) (not (pick-a-point-rule-classes-syntax-ok-p rule-classes)) t) nil nil nil nil) ((t) nil nil (cw cw cw) nil nil nil) ((~%Rule name must be a symbol, but it is ~x0.~% name ~%Term must be of the form:~%~%   ~
               (implies (hyps) ~%          ~
                        (conclusion (arg1) (arg2) ... (argN)))~%~%~
              Or else of the form:~%~%   ~
               (implies (hyps) ~%          ~
                        (not (conclusion (arg1) (arg2) ... (argN))))~%~%~
              But instead, the term is:~%~%   ~x0~% term ~%:pick-a-point rules must have :rule-classes ~
              of the form:~%~%   ~
               (:rule-classes :driver <thm>)~%~%
              Where <thm> is the name of some generic theorem of the same ~
              form.  But, the rule classes here are of the form: ~%~%   ~x0~% rule-classes) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-rule-parser (nil nil nil (let*) nil nil nil) (nil nil nil nil nil ((hypothesis (second term))) nil) (nil nil (conclusion negatedp function args) (cons cons cons cons cons cons cons cons) nil nil nil) ((:class :pick-a-point :name name :negatedp negatedp :function function :trigger :driver :hyps :args) nil (third third first) (pairlis$) (if if if) (symbol-fns::join-symbols) nil) ((term t nil negatedp negatedp function ADVISER- -TRIGGER rule-classes hypothesis args) nil (first first rest rest symbol-name symbols) (eq) nil nil nil) ((conclusion conclusion function) nil (car quote cadr cadr len) nil nil nil nil) ((conclusion not conclusion conclusion args) nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-rule-installer (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil ((name (cdr (assoc :name parsed-rule)))) nil) (nil nil (function trigger args negatedp) nil nil (encapsulate) nil) ((nil) nil (cdr cdr cdr cdr) nil (table) (defund defthm) nil) ((:hints (Goal :in-theory (union-theories (theory (quote minimal-theory)) (quote ((:definition (, trigger)))))) adviser-table :pick-a-point-rules) nil (, , declare (, function) ,) (assoc assoc assoc assoc implies let) nil nil nil) ((:function parsed-rule :trigger parsed-rule :args parsed-rule :negatedp parsed-rule trigger name (rules (pick-a-point-rules world))) nil (strip-cars ,@ ACL2::rebalance-symbol-btree) (xargs and equal) nil nil nil) ((args :verify-guards nil) nil (strip-cars syntaxp syntaxp (, function) (, trigger)) nil (ACL2::symbol-btree-update) nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-rule-defadvice (nil nil nil nil (if) nil nil) ((nil) nil (pick-a-point-rule-installer) nil (pick-a-point-rule-syntax-check) nil nil) ((name term rule-classes) nil nil nil (pick-a-point-rule-parser) nil nil) ((name term rule-classes) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-trigger-harvester (nil nil nil nil (if) nil nil) (nil nil (endp) (mv let*) nil nil nil) ((clause acc-lit acc-rule) nil ((literal (car clause))) (let) nil nil nil) (((match (and (symbolp matchsym) (ACL2::symbol-btree-lookup matchsym rules)))) nil (matchsym) nil nil (recursive-call) nil) ((rules) nil (cdr) nil (if if if) nil nil) ((nil clause match acc-lit match acc-rule) nil (consp) (cons cons) (if) nil nil) ((literal literal acc-lit match acc-rule) nil (caadr car) nil (and) nil nil)) (/coi/adviser/adviser-definitions.lisp::negate-literals (nil nil nil nil (if) nil nil) ((nil) nil (endp) nil (if) nil nil) ((literals) nil nil (equal cons cons) nil nil nil) (nil nil (caar quote second recursive-call recursive-call) (list) nil nil nil) ((literals not) nil (car cdr quote car cdr) nil nil nil nil) ((literals literals not literals literals) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::andify-literals (nil nil nil nil (if) nil nil) ((t) nil (endp) nil (if) nil nil) ((literals) nil (endp car) (cons) nil nil nil) ((literals literals) nil (cdr quote) nil nil nil nil) ((literals and) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::make-functional-instance-pairs (nil nil nil nil (if) nil nil) ((nil) nil (endp) (cons) nil nil nil) ((arg-names) nil (`) (recursive-call) nil nil nil) (nil nil ((, (car arg-names)) cdr cdr) nil nil nil nil) ((arg-names actuals) nil nil (lambda) nil nil nil) ((nil) nil (,) nil nil nil nil) (nil nil (car) nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::build-hint (nil nil nil (let) nil nil nil) (nil nil (`) nil ((driver (cdr (assoc :driver rule)))) nil nil) (nil nil (hyps-name arg-names actuals) nil (:functional-instance) nil nil) (nil nil (cdr strip-cars , (, hyps-name) ,@) nil (if) nil nil) ((driver) nil (strip-cdrs rest rest) (assoc equal lambda make-functional-instance-pairs) nil nil nil) ((:hyps rule literal nil arg-names actuals) nil (cdr car quote cadr ,) nil nil nil nil) ((literal not literal hyps) nil nil (assoc) nil nil nil)) (/coi/adviser/adviser-definitions.lisp::build-hints (nil nil nil nil (if) nil nil) ((acc) nil (endp) nil nil (recursive-call) nil) ((literals hyps) nil (cdr cdr) (cons) nil nil nil) ((literals rules acc) nil nil nil (build-hint) nil nil) ((hyps) nil (car car) nil nil nil nil) ((literals rules) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::get-thms (nil nil nil nil (if) nil nil) ((nil) nil (endp) (cons) nil nil nil) ((rules) nil (cdr recursive-call) nil nil nil nil) (nil nil (cdr) (assoc) nil nil nil) ((:driver rules) nil (car) nil nil nil nil) ((rules) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::get-names (nil nil nil nil (if) nil nil) ((nil) nil (endp) (cons) nil nil nil) ((rules) nil (cdr recursive-call) nil nil nil nil) (nil nil (cdr) (assoc) nil nil nil) ((:name rules) nil (car) nil nil nil nil) ((rules) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::build-expand-hint (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((literals (lit (first literals))) nil nil nil (if) nil nil) (nil nil nil (equal cons cons) nil nil nil) ((lit) nil (car quote cadr recursive-call recursive-call) nil nil nil nil) ((lit not lit) nil (rest rest) nil nil nil nil) ((literals literals) nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::pick-a-point-suggester (nil nil nil (let) nil nil nil) (((rules (pick-a-point-rules world))) nil nil nil (if) nil nil) ((nil) nil (null) nil (mv-let) nil nil) ((rules) nil (literals) nil (if) (pick-a-point-trigger-harvester) nil) ((rules clause rules nil nil nil) nil (null) (let*) nil nil nil) ((literals) nil nil ((others (set-difference-equal clause literals)) prog2$) nil nil nil) ((hints) nil (hyps hints) nil nil (cw) nil)) (/coi/adviser/adviser-definitions.lisp::adviser-default-hint (nil nil nil nil (if) nil nil) ((nil) nil (not) (or) nil nil nil) ((stable nil) nil nil nil (pick-a-point-suggester) nil nil) ((id clause world) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::all-not-integerp (nil nil nil nil (if) nil nil) ((t) nil (consp) nil (if) nil nil) ((x nil) nil (integerp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/adviser/adviser-definitions.lisp::some-integerp (nil nil nil nil (if) nil nil) ((nil) nil (consp) nil (if) nil nil) ((x t) nil (integerp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/cutil/defprojection.lisp::variable-or-constant-listp (nil nil nil nil (if) nil nil) ((t) nil (atom) (and) nil nil nil) ((x) nil (recursive-call) nil nil nil (or)) (nil nil (symbolp quotep acl2-numberp stringp characterp cdr) nil nil nil nil) ((x) nil (car car car car car) nil nil nil nil) ((x x x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/cutil/defprojection.lisp::collect-vars (nil nil nil nil (if) nil nil) ((nil) nil (atom) nil (if) nil nil) ((x) nil (recursive-call) (and cons) nil nil nil) (nil nil (symbolp not car recursive-call cdr) nil nil nil nil) ((x x) nil (car keywordp cdr) nil nil nil nil) ((x x) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/cutil/defprojection.lisp::defprojection-fn (nil nil nil (b*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (mksym-package-symbol x a n y acc (unless (and (symbol-listp formals) (no-duplicatesp formals))) (unless (member x formals)) (unless (and (not (member a formals)) (not (member n formals)) (not (member y formals)) (not (member acc formals)))) (unless (and (consp element) (symbolp (car element)))) list-fn list-args elem-fn elem-args exec-fn elem-syms (unless (variable-or-constant-listp elem-args)) (unless (and (no-duplicatesp elem-syms) (subsetp elem-syms formals) (subsetp formals elem-syms))) (unless (or (eq mode :logic) (eq mode :program))) (unless (booleanp verify-guards)) (unless (booleanp nil-preservingp)) (unless (booleanp already-definedp)) (unless (booleanp optimize)) (unless (symbolp result-type)) short long def ndef opt (when (eq mode :program)) events) nil nil nil nil) ((name name formals ,) nil (car cdr collect-vars ` ` ` , ,@ ,@ ,@) (intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol mksym or or) (if if if) (er er er er er er er er er er er) (er)) ((X name A name N name Y name ACC name hard The formals must be a list of unique symbols, but the ~
            formals are ~x0. formals hard The formals must contain X, but are ~x0.~% formals hard As a special restriction, formals may not mention a, n, ~
            or y, but the formals are ~x0. formals hard The element transformation should be a function/macro call, ~
             but is ~x0. element element element list-fn elem-args hard? The element's arguments must be a function applied to the ~
             formals or constants, but are: ~x0. elem-args hard The variables in the :element do not agree with the formals:~% ~
              - formals: ~x0~% ~
              - element vars: ~x1~% formals elem-syms hard :mode must be one of :logic or :program, but is ~x0. mode hard :verify-guards must be a boolean, but is ~x0. verify-guards hard :nil-preservingp must be a boolean, but is ~x0. nil-preservingp hard :already-definedp must be a boolean, but is ~x0. already-definedp hard :optimize must be a boolean, but is ~x0. optimize hard :result-type must be a symbol, but is ~x0. result-type short long already-definedp nil nil name events) nil (quote quote quote quote quote quote quote quote quote quote quote quote quote ` ` not `) (and and or and and and) (defun) nil nil) ((defprojection defprojection defprojection defprojection -exec defprojection defprojection defprojection defprojection defprojection defprojection defprojection defprojection parents parents (,@ list-args) already-definedp (progn (make-event (if (acl2::global-val (quote acl2::include-book-path) (w state)) (value (quote (value-triple :invisible))) (value (quote (value-triple (cw ~|~%Optimizing definition of ~s0:~%  ~p1~%~% (quote (, list-fn)) (quote (, ndef)))))))) (defttag cutil-optimize) (progn! (set-raw-mode t) (when (boundp (quote ACL2::*never-profile-ht*)) (setf (gethash (quote (, exec-fn)) ACL2::*never-profile-ht*) t)) (, ndef)) (defttag nil)) program , opt parents short long rest) nil (str::cat (defun (, exec-fn) ((,@ list-args) (, acc)) (declare (xargs :guard (, (if (equal guard t) (` (true-listp (, acc))) (` (and (true-listp (, acc)) (, guard))))) :mode (, mode) :normalize nil :verify-guards nil)) (if (consp (, x)) ((, exec-fn) (,@ (subst (` (cdr (, x))) x list-args)) (cons ((, elem-fn) (,@ (subst (` (car (, x))) x elem-args))) (, acc))) (, acc))) , nreverse not , ,@ ,@ ,@ ,@ ,@ ,@ ,@ ,@ local ,@ ,@ ,@ ,@ ` ` `) (defthm defthm defthm) ((encapsulate nil , events)) (defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm) nil) ((@(call  ) maps  @(see  ) across a list. <p>This is an ordinary @(see defprojection).</p> list-fn optimize name def opt rest def :hints (Goal :in-theory (enable (, list-fn))) :hints (Goal :in-theory (enable (, list-fn))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :in-theory (enable nthcdr) :induct (nthcdr (, n) (, x))) :hints (Goal :induct (len (, x))) :hints (Goal :in-theory (enable subsetp-equal) :induct (len (, x))) , rest) nil (symbol-name symbol-name in-theory , , , , , , , , , , , , , , , :parents :short :long local) ((, exec-fn) and and and implies equal equal equal equal equal equal iff equal equal equal equal equal implies implies and) (if if if if) (defun) nil)))
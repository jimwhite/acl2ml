((/paco/type-set.lisp::def-basic-type-sets1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (recursive-call) (list) nil nil) (nil nil (quote car cdr) (list +) nil nil nil) ((defconst lst lst i) (1) (quote) (expt) nil nil nil) ((the-type-set i) (2) nil nil nil nil nil)) (/paco/type-set.lisp::list-of-the-type-set (nil nil nil (cond) nil nil nil) (nil nil ((consp x) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) (list) nil nil nil) (nil nil (quote car cdr) nil nil nil nil) ((the-type-set x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::ts-union-fn (nil nil nil (list) nil nil nil) (nil nil (quote) nil (cond) nil nil) ((the-type-set) nil ((null x) (null (cdr x)) t) nil nil nil nil) (nil nil (quote car) (xxxjoin) nil nil nil) ((*ts-empty* x) nil (quote list-of-the-type-set) nil nil nil nil) ((logior x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::ts-builder-macro1 (nil nil nil nil (cond) nil nil) (nil nil ((endp case-lst) (or (eq (caar case-lst) t) (eq (caar case-lst) (quote otherwise))) t) nil nil nil nil) ((nil) nil nil (sublis cons) nil nil nil) (nil nil (quote) (sublis) (list recursive-call) nil nil) (((cond ((ts-intersectp x (ts-complement (ts-union . seen))) ts2) (t *ts-empty*)) x) nil (quote cdr) (cons cons cons cons) (list) nil nil) ((x seen case-lst seen) nil (quote quote quote cadr caar) (cons cons cons cond) nil nil nil) ((x seen ts2 x case-lst) nil (car quote quote caar quote cadr (ts-intersectp x ts1) t) nil nil nil nil)) (/paco/type-set.lisp::ts-builder-macro (nil nil nil (cons) nil nil nil) (nil nil (quote) nil (ts-builder-macro1) nil nil) ((ts-union x case-lst nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-binary-+-alist-entry (nil nil nil nil nil nil nil) ((ts1) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational*) nil nil nil nil) ((ts2) nil nil nil nil nil nil) ((ts2 ts2 ts2 ts2 ts2) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational*) nil nil nil nil) ((ts1 *ts-positive-integer* *ts-integer* *ts-positive-ratio* *ts-ratio* *ts-complex-rational* ts1 *ts-integer* *ts-negative-integer* *ts-ratio* *ts-negative-ratio* *ts-complex-rational* ts1 *ts-positive-ratio* *ts-ratio* *ts-positive-rational* *ts-rational* *ts-complex-rational* ts1 *ts-ratio* *ts-negative-ratio* *ts-rational* *ts-negative-rational* *ts-complex-rational* ts1 *ts-complex-rational* *ts-complex-rational* *ts-complex-rational* *ts-complex-rational* *ts-rational-acl2-number*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-binary-*-alist-entry (nil nil nil nil nil nil nil) ((ts1) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational*) nil nil nil nil) ((*ts-zero*) nil nil nil nil nil nil) ((ts2 ts2 ts2 ts2 ts2) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-complex-rational*) nil nil nil nil) ((*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-rational* *ts-negative-rational* *ts-complex-rational* *ts-zero* *ts-negative-integer* *ts-positive-integer* *ts-negative-rational* *ts-positive-rational* *ts-complex-rational* *ts-zero* *ts-positive-rational* *ts-negative-rational* *ts-positive-rational* *ts-negative-rational* *ts-complex-rational* *ts-zero* *ts-negative-rational* *ts-positive-rational* *ts-negative-rational* *ts-positive-rational* *ts-complex-rational* *ts-zero* *ts-complex-rational* *ts-complex-rational* *ts-complex-rational* *ts-complex-rational*) nil nil (ts-intersection) nil nil nil) ((*ts-rational-acl2-number*) nil (ts-complement) nil nil nil nil) ((*ts-zero*) nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-<-alist-entry (nil nil nil nil nil nil nil) ((ts1) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio*) nil nil nil nil) (nil nil nil nil nil nil nil) ((ts2 ts2 ts2 ts2 ts2) nil (*ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio* *ts-zero* *ts-positive-integer* *ts-negative-integer* *ts-positive-ratio* *ts-negative-ratio*) nil nil nil nil) ((*ts-nil* *ts-t* *ts-nil* *ts-t* *ts-nil* *ts-nil* *ts-boolean* *ts-nil* *ts-boolean* *ts-nil* *ts-t* *ts-t* *ts-boolean* *ts-t* *ts-boolean* *ts-nil* *ts-boolean* *ts-nil* *ts-boolean* *ts-nil* *ts-t* *ts-t* *ts-boolean* *ts-t* *ts-boolean*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::numeric-type-set (nil nil nil (let) nil nil nil) (((numeric-subtype (ts-intersection ts *ts-acl2-number*))) nil nil nil (if) nil nil) ((ts) nil nil (ts= ts-union) nil nil nil) ((numeric-subtype ts numeric-subtype *ts-zero*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::rational-type-set (nil nil nil (let) nil nil nil) (((rational-subtype (ts-intersection ts *ts-rational*))) nil nil nil (if) nil nil) ((ts) nil nil (ts= ts-union) nil nil nil) ((rational-subtype ts rational-subtype *ts-zero*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-binary-+ (nil nil nil (let) nil nil nil) (nil nil ((arg1 (fargn term 1))) nil nil nil nil) (nil nil (arg2 (or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) (and (equal arg2 (quote (quote -1))) (ts-subsetp ts1 *ts-positive-integer*)) (and (equal arg1 (quote (quote -1))) (ts-subsetp ts2 *ts-positive-integer*)) (and (equal arg2 (quote (quote 1))) (ts-subsetp ts1 *ts-negative-integer*)) (and (equal arg1 (quote (quote 1))) (ts-subsetp ts2 *ts-negative-integer*)) t) nil nil nil nil) ((*ts-empty* *ts-non-negative-integer* *ts-non-negative-integer* *ts-non-positive-integer* *ts-non-positive-integer*) nil nil (fargn type-set-binary-+-alist-entry) nil nil nil) ((term) (2) (numeric-type-set numeric-type-set) nil nil nil nil) ((ts1 ts2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-binary-* (nil nil nil (cond) nil nil nil) (nil nil ((or (ts= ts1 *ts-empty*) (ts= ts2 *ts-empty*)) t) nil nil nil nil) ((*ts-empty*) nil nil (type-set-binary-*-alist-entry) nil nil nil) (nil nil (numeric-type-set numeric-type-set) nil nil nil nil) ((ts1 ts2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-not (nil nil nil nil (cond) nil nil) (nil nil ((ts= ts *ts-nil*) (ts-subsetp *ts-nil* ts) t) nil nil nil nil) ((*ts-t* *ts-boolean* *ts-nil*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-< (nil nil nil (let*) nil nil nil) (nil nil ((nts1 (numeric-type-set ts1))) nil nil (cond) nil) (nil nil (nts2 (and (equal arg2 *1*) (ts-subsetp nts1 *ts-integer*)) (and (quotep arg1) (eql (cadr arg1) -1) (ts-subsetp nts2 *ts-integer*)) (or (ts-intersectp ts1 *ts-complex-rational*) (ts-intersectp ts2 *ts-complex-rational*)) t) nil nil nil nil) ((*ts-boolean*) nil (numeric-type-set type-set-not type-set-not) (type-set-<-alist-entry) nil nil nil) ((ts2 nts1 nts2) nil nil nil nil (recursive-call recursive-call) nil) ((*0* arg1 *ts-zero* ts1 arg2 *0* ts2 *ts-zero*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-unary-- (nil nil nil (let) nil nil nil) (((ts1 (numeric-type-set ts))) nil nil (cond) nil nil nil) (nil nil ((ts= ts1 *ts-acl2-number*) t) nil nil nil nil) ((*ts-acl2-number*) nil nil nil nil nil (ts-builder)) ((ts1) nil (*ts-zero* *ts-positive-integer* *ts-positive-ratio* *ts-negative-integer*) nil nil nil nil) ((*ts-zero* *ts-negative-integer* *ts-negative-ratio* *ts-positive-integer*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-unary-/ (nil nil nil (let*) nil nil nil) (((ts1 (numeric-type-set ts))) nil nil nil nil nil (ts-builder)) ((ts1) nil (*ts-zero* *ts-positive-rational* *ts-negative-rational* *ts-complex-rational*) nil nil nil nil) ((*ts-zero* *ts-positive-rational* *ts-negative-rational* *ts-complex-rational*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-numerator (nil nil nil (let*) nil nil nil) (((ts1 (rational-type-set ts))) nil nil nil nil (ts-builder) nil) ((ts1) nil (*ts-zero* *ts-positive-rational* *ts-negative-rational*) nil nil nil nil) ((*ts-zero* *ts-positive-integer* *ts-negative-integer*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-realpart (nil nil nil (cond) nil nil nil) (nil nil ((ts-intersectp ts *ts-complex-rational*) t) nil nil nil nil) ((*ts-rational*) nil (numeric-type-set) nil nil nil nil) ((ts) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-imagpart (nil nil nil nil (cond) nil nil) (nil nil ((ts-subsetp ts *ts-complex-rational*) (ts-intersectp ts *ts-complex-rational*) t) nil nil nil nil) ((*ts-rational* *ts-zero*) nil nil (ts-union) nil nil nil) ((*ts-positive-rational* *ts-negative-rational*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-complex (nil nil nil (let) nil nil nil) (nil nil ((ts1 (rational-type-set ts1))) nil nil (cond) nil) (nil nil (ts2 (ts= ts2 *ts-zero*) (ts= (ts-intersection ts2 *ts-zero*) *ts-empty*) (ts= ts1 *ts-rational*) t) nil nil nil nil) ((ts1 *ts-complex-rational* *ts-acl2-number*) nil (rational-type-set) (ts-union) nil nil nil) ((ts2 ts1 *ts-complex-rational*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::most-recent-enabled-recog-tuple (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (and (eq fn (access recognizer-tuple (car alist) :fn)) (enabled-numep (access recognizer-tuple (car alist) :nume) ens)) t) nil nil nil nil) ((nil) nil (car) nil (recursive-call) nil nil) ((alist fn ens) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-recognizer (nil nil nil nil (ts-builder) nil nil) ((arg-ts) nil ((access recognizer-tuple recog-tuple :true-ts) (access recognizer-tuple recog-tuple :false-ts)) nil nil nil nil) ((*ts-t* *ts-nil*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-car (nil nil nil (cond) nil nil nil) (nil nil ((ts-intersectp ts *ts-cons*) t) nil nil nil nil) ((*ts-unknown* *ts-nil*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-cdr (nil nil nil nil nil (ts-builder) nil) ((ts) nil (*ts-proper-cons* *ts-improper-cons* otherwise) nil nil nil nil) ((*ts-true-list* *ts-nil*) nil (ts-complement) nil nil nil nil) ((*ts-true-list*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-coerce (nil nil nil nil nil (cond) nil) (nil nil ((equal (fargn term 2) (quote (quote list))) (quotep (fargn term 2)) (not (ts-intersectp *ts-non-t-non-nil-symbol* ts2)) t) nil nil nil nil) ((*ts-string* *ts-string*) nil nil (cond ts-union) nil nil nil) ((*ts-true-list* *ts-string*) nil ((ts-intersectp *ts-string* ts1) t) nil nil nil nil) ((*ts-true-list* *ts-nil*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-intern-in-package-of-symbol (nil nil nil nil (cond) nil nil) (nil nil ((not (ts-intersectp ts1 *ts-string*)) (not (ts-intersectp ts2 *ts-symbol*)) t) nil nil nil nil) ((*ts-nil* *ts-nil* *ts-symbol*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-length (nil nil nil nil nil (ts-builder) nil) ((ts) nil (*ts-string* *ts-cons* otherwise) nil nil nil nil) ((*ts-non-negative-integer* *ts-positive-integer* *ts-zero*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-cons (nil nil nil nil (ts-builder) nil nil) ((ts2) nil (*ts-true-list* otherwise) nil nil nil nil) ((*ts-proper-cons* *ts-improper-cons*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-equal (nil nil nil nil (cond) nil nil) (nil nil ((member ts1 *singleton-type-sets*) (ts-intersectp ts1 ts2) t) nil nil nil nil) ((*ts-boolean* *ts-nil*) nil nil nil (cond) nil nil) (nil nil ((ts= ts1 ts2) (ts-intersectp ts1 ts2) t) nil nil nil nil) ((*ts-t* *ts-boolean* *ts-nil*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-quote (nil nil nil nil (cond) nil nil) (nil nil ((atom evg) (true-listp evg) t) nil nil nil nil) ((*ts-proper-cons* *ts-improper-cons*) nil nil nil nil nil (cond)) (nil nil ((rationalp evg) (complex-rationalp evg) (symbolp evg) (stringp evg) t) nil nil nil nil) ((*ts-complex-rational* *ts-string* *ts-character*) nil nil nil (cond cond) nil nil) (nil nil ((integerp evg) (> evg 0) t (eq evg t) (eq evg nil) t) nil nil nil nil) ((*ts-positive-ratio* *ts-negative-ratio* *ts-t* *ts-nil* *ts-non-t-non-nil-symbol*) nil nil nil (cond) nil nil)) (/paco/type-set.lisp::type-set-char-code (nil nil nil (cond) nil nil nil) (nil nil ((not (ts-intersectp ts *ts-character*)) t) nil nil nil nil) ((*ts-zero* *ts-non-negative-integer*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::mv-atf (nil nil nil nil (if) nil nil) ((not-flg) nil nil nil nil (mv mv) nil) ((mbf mbt fta tta mbt mbf tta fta) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::non-cons-cdr (nil nil nil nil nil (cond) nil) (nil nil ((variablep term) (fquotep term) (eq (ffn-symb term) (quote cons)) t) nil nil nil nil) ((term term term) nil (recursive-call) nil nil nil nil) (nil nil nil (fargn) nil nil nil) ((term) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::extend-type-alist (nil nil nil nil nil (cond) nil) (nil nil ((ts= ts *ts-unknown*) (variablep term) (fquotep term) t) nil nil nil nil) ((type-alist type-alist) nil nil (cons cons) nil nil nil) ((type-alist type-alist) nil nil (cons cons) nil nil nil) ((term ts term ts) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::zip-variable-type-alist (nil nil nil (cond) nil nil nil) (nil nil ((endp var-lst) t) nil nil nil nil) ((nil) nil nil nil (extend-type-alist) nil nil) (nil nil (car car) (recursive-call) nil nil nil) ((var-lst ts-lst) nil (cdr cdr) nil nil nil nil) ((var-lst ts-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::assoc-equal-equality (nil nil nil nil (cond) nil nil) (nil nil ((endp type-alist) (and (nvariablep (caar type-alist)) (not (fquotep (caar type-alist))) (eq (ffn-symb (caar type-alist)) (quote EQUAL)) (or (and (equal lhs (fargn (caar type-alist) 1)) (equal rhs (fargn (caar type-alist) 2))) (and (equal rhs (fargn (caar type-alist) 1)) (equal lhs (fargn (caar type-alist) 2))))) t) nil nil nil nil) ((nil) nil (car) nil (recursive-call) nil nil) ((type-alist lhs rhs) nil (cdr) nil nil nil nil) ((type-alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::look-in-type-alist (nil nil nil nil nil (cond) nil) (nil nil ((variablep term) (quotep term) (eq (ffn-symb term) (quote EQUAL)) t) nil nil nil nil) ((nil) nil (cdr cdr cdr) nil nil nil nil) (nil nil nil (assoc-equal assoc-equal) (assoc-equal-equality) nil nil) ((term type-alist type-alist term type-alist) nil nil (fargn fargn) nil nil nil) ((term term) (1 2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::push-ancestor (nil nil nil (let*) nil nil nil) (nil nil ((alit lit)) nil (mv-let) nil nil) (nil nil (alit-atm fn-cnt-alit-atm fn-count) (cons) nil nil nil) ((p-fn-cnt-alit-atm alit-atm ancestors) nil nil nil nil (mv-let list) nil) ((atm alit alit-atm fn-cnt-alit-atm p-fn-cnt-alit-atm) nil (not-flg strip-not declare) nil nil nil nil) ((atm alit) nil (ignore) nil nil nil nil) ((not-flg) nil nil nil nil nil nil)) (/paco/type-set.lisp::ancestors-check1 (nil nil nil (cond) nil nil nil) (nil nil ((endp ancestors) t) nil nil nil nil) (nil nil nil (mv let) nil nil nil) ((nil nil) nil nil nil ((alit (car (car ancestors)))) (cond) nil) (nil nil (alit-atm fn-cnt-alit-atm p-fn-cnt-alit-atm (equal alit lit) (equal lit-atm alit-atm) (and (or (> fn-cnt fn-cnt-alit-atm) (and (eql fn-cnt fn-cnt-alit-atm) (>= p-fn-cnt p-fn-cnt-alit-atm))) (worse-than-or-equal lit-atm alit-atm)) t) nil nil nil nil) (nil nil (cadr caddr cadddr) (mv mv mv) nil nil (recursive-call)) ((t t t nil t nil lit-atm lit fn-cnt p-fn-cnt) nil (car car car cdr) nil nil nil nil)) (/paco/type-set.lisp::ancestors-check (nil nil nil nil nil (mv-let) nil) (nil nil (not-flg strip-not declare) nil (mv-let) nil nil) ((lit-atm lit) nil (ignore fn-cnt fn-count) nil nil nil (ancestors-check1)) ((not-flg p-fn-cnt lit-atm lit-atm lit fn-cnt p-fn-cnt ancestors) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::search-type-alist (nil nil nil nil (cond) nil nil) (nil nil ((endp type-alist) (ts-subsetp (cdr (car type-alist)) typ) t) nil nil nil nil) (nil nil nil (mv) (mv-let) (recursive-call) nil) ((nil unify-subst term typ unify-subst) nil (ans cdr) (cond) (one-way-unify1) nil nil) ((unify-subst term unify-subst type-alist) nil (car ans t) nil nil nil nil) (nil nil (car) (mv) nil (recursive-call) nil) ((type-alist t unify-subst term typ unify-subst) nil (cdr) nil nil nil nil)) (/paco/type-set.lisp::term-and-typ-to-lookup (nil nil nil nil (mv-let) nil nil) (nil nil (not-flg strip-not) (let*) nil nil nil) ((term hyp) nil nil ((recog-tuple (and (nvariablep term) (not (fquotep term)) (not (flambda-applicationp term)) (assoc-eq (ffn-symb term) (global-val (quote recognizer-alist) wrld)))) mv) nil nil nil) ((term typ) nil (typ term) nil nil nil nil) (nil nil nil nil (if if) nil nil) ((term) nil nil (and and fargn) (if if) nil nil) ((recog-tuple not-flg not-flg *ts-nil* *ts-non-nil* recog-tuple term) (1) nil nil (access access access access) nil nil)) (/paco/type-set.lisp::lookup-hyp (nil nil nil nil (mv-let) nil nil) (nil nil (term) (term-and-typ-to-lookup) nil (search-type-alist) nil) ((typ hyp wrld term typ type-alist unify-subst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::assume-true-false-< (nil nil nil nil nil nil nil) (nil nil ((and (not not-flg) (ts-subsetp ts1 (ts-union *ts-non-negative-rational* (ts-complement *ts-acl2-number*))) (ts-intersectp ts2 (ts-complement (ts-union *ts-positive-rational* *ts-complex-rational*)))) (and (not not-flg) (ts-subsetp ts2 (ts-union *ts-non-positive-rational* (ts-complement *ts-acl2-number*))) (ts-intersectp ts1 (ts-complement (ts-union *ts-negative-rational* *ts-complex-rational*)))) (and not-flg (ts-subsetp ts1 *ts-negative-rational*) (ts-intersectp ts2 (ts-complement (ts-union *ts-complex-rational* *ts-negative-rational*)))) (and not-flg (ts-subsetp ts1 (ts-union *ts-non-positive-rational* (ts-complement *ts-acl2-number*))) (ts-intersectp ts2 *ts-positive-rational*)) (and not-flg (ts-subsetp ts2 *ts-positive-rational*) (ts-intersectp ts1 (ts-complement (ts-union *ts-complex-rational* *ts-positive-rational*)))) (and not-flg (ts-subsetp ts2 (ts-complement (ts-union *ts-complex-rational* *ts-negative-rational*))) (ts-intersectp ts1 *ts-negative-rational*)) t) nil nil nil nil) ((type-alist) nil nil nil (extend-type-alist extend-type-alist extend-type-alist extend-type-alist extend-type-alist extend-type-alist) nil nil) ((arg2 type-alist arg1 type-alist arg2 type-alist arg2 type-alist arg1 type-alist arg1 type-alist) nil nil (ts-intersection ts-intersection ts-intersection ts-intersection ts-intersection ts-intersection) nil nil nil) ((ts2 ts1 ts2 ts2 ts1 ts1) nil (ts-complement ts-complement) (ts-union ts-union ts-union ts-union) nil nil nil) ((*ts-positive-rational* *ts-complex-rational* *ts-negative-rational* *ts-complex-rational* *ts-complex-rational* *ts-negative-rational* *ts-positive-rational* *ts-complex-rational* *ts-positive-rational* *ts-negative-rational*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::mv-atf-2 (nil nil nil (let) nil nil nil) (nil nil nil ((tta0 (extend-type-alist new-term *ts-t* true-type-alist)) cond) nil nil nil) (nil nil (fta0 same-parity (equal new-term (cond (same-parity x) (t (dumb-negate-lit x)))) t) nil nil nil nil) (nil nil nil (eq let) (extend-type-alist) nil (mv-atf)) ((new-term *ts-nil* false-type-alist not-flg xnot-flg not-flg nil nil tta0 fta0) nil ((tta1 (extend-type-alist x (if same-parity *ts-t* *ts-nil*) tta0))) nil nil nil (mv-atf)) ((not-flg nil nil tta1 fta1) nil (fta1) nil nil nil nil) (nil nil nil nil (extend-type-alist) nil nil)) (/paco/type-set.lisp::lex4 (nil nil nil (cons) nil nil nil) ((l) nil nil (cons) nil nil nil) ((k) nil nil (cons) nil nil nil) ((j) nil nil (+) nil nil nil) ((i) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-set-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil nil nil nil) ((type-alist ancestors ens w nnn type-alist ancestors ens w nnn) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::type-alist-clause (nil nil nil (cond) nil nil nil) (nil nil ((endp cl) t) nil nil nil nil) (nil nil nil (mv) nil (mv-let) nil) ((nil type-alist) nil (declare) nil (mbt cond) nil nil) ((mbf tta fta type-alist nil ens wrld *type-set-nnn*) nil (car ignore mbt mbf t) nil nil nil nil) ((cl tta) nil nil (mv) nil (recursive-call recursive-call) nil) ((t nil type-alist ens wrld fta ens wrld) nil (cdr cdr) nil nil nil nil)) (/paco/type-set.lisp::known-whether-nil (nil nil nil (cond) nil nil nil) (nil nil ((quotep x) t) nil nil nil nil) (nil nil nil (mv let) nil nil nil) ((t (ts (type-set x type-alist nil ens wrld *type-set-nnn*))) nil nil (equal) (cond) nil nil) ((x *nil*) nil ((ts= ts *ts-nil*) (ts-intersectp ts *ts-nil*) t) nil nil nil nil) (nil nil nil (mv mv mv) nil nil nil) ((t t nil nil t nil) nil nil nil nil nil nil)) (/paco/type-set.lisp::ts-booleanp (nil nil nil (ts-subsetp) nil nil nil) ((*ts-boolean*) nil nil nil nil nil nil) ((term type-alist nil ens wrld *type-set-nnn*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::weak-cons-occur (nil nil nil nil nil (cond) nil) (nil nil ((variablep y) (fquotep y) (eq (ffn-symb y) (quote cons)) t) nil nil nil nil) ((nil) nil nil (eq or equal) nil nil nil) ((x y x y) nil nil (recursive-call recursive-call) nil nil nil) ((x x) nil nil (fargn fargn) nil nil nil) ((y y) (1 2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::equal-x-cons-x-yp (nil nil nil nil nil nil (cond)) (nil nil ((variablep lhs) (fquotep lhs) (eq (ffn-symb lhs) (quote cons)) (consityp rhs) t) nil nil nil nil) ((nil nil) nil nil (cond or) nil (cond) nil) (nil nil ((consityp rhs) t (variablep rhs) (fquotep rhs) (eq (ffn-symb rhs) (quote cons)) t) (weak-cons-occur weak-cons-occur) nil nil nil) ((nil nil nil lhs lhs) nil nil (or or or fargn fargn) nil nil nil) ((rhs rhs) (1 2) nil (weak-cons-occur weak-cons-occur weak-cons-occur weak-cons-occur weak-cons-occur weak-cons-occur) nil nil nil) ((lhs lhs rhs rhs rhs rhs) nil nil (fargn fargn fargn fargn fargn fargn) nil nil nil)) (/paco/type-set.lisp::not-ident (nil nil nil (cond) nil nil nil) (nil nil ((and (quotep term1) (quotep term2)) t) nil nil nil nil) (nil nil (not) (let) nil nil nil) (nil nil ((ts1 (type-set term1 type-alist nil ens wrld *type-set-nnn*))) (equal) (cond) nil nil) ((term1 term2) nil (ts2 (not (ts-intersectp ts1 ts2)) (equal-x-cons-x-yp term1 term2) t) nil nil nil nil) ((t t nil) nil nil nil nil nil nil) ((term2 type-alist nil ens wrld *type-set-nnn*) nil nil nil nil nil nil)) (/paco/type-set.lisp::first-if (nil nil nil nil (cond) nil nil) (nil nil ((endp args) (and (nvariablep (car args)) (not (quotep (car args))) (eq (ffn-symb (car args)) (quote if))) t) nil nil nil nil) (nil nil nil (mv mv recursive-call) nil nil nil) ((nil nil i) nil (car cdr 1+) nil nil nil nil) ((args args i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::reduce-with-type-set (nil nil nil (let) nil nil nil) (((ts (type-set term type-alist nil ens wrld *type-set-nnn*))) nil nil nil nil nil (cond)) (nil nil ((ts-intersectp ts *ts-nil*) iff-flg (ts= ts *ts-t*) (ts= ts *ts-zero*) t) nil nil nil nil) ((*t* *t* *0* term) nil nil (cond) nil nil nil) (nil nil ((ts= ts *ts-nil*) t) nil nil nil nil) ((*nil* term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::cons-term-if (nil nil nil nil nil nil nil) (nil nil ((equal t1 *t*) (equal t1 *nil*) (equal t2 t3) (and (equal t1 t2) (equal t3 *nil*)) (and (equal t2 *t*) (equal t3 *nil*)) t) nil nil nil nil) ((t2 t3 t2 t1) nil nil nil (cond) (fcons-term*) nil) ((t1 t2 t3) nil (iff-flg (ts-booleanp t1 type-alist ens wrld) t quote) nil nil nil nil) ((t1 t1 if) nil nil nil nil (fcons-term*) nil) ((t1 t2 t3) nil (quote) nil nil nil nil) ((if) nil nil nil nil nil nil)) (/paco/type-set.lisp::cons-term-equal (nil nil nil nil (cond) nil nil) (nil nil ((equal t1 t2) (and (quotep t1) (quotep t2)) t) nil nil nil nil) ((*t* *nil*) nil nil nil (fcons-term*) nil nil) ((t1 t2) nil (quote) nil nil nil nil) ((equal) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/type-set.lisp::reduce (nil nil nil nil nil nil (cond)) (nil nil ((variablep term) (fquotep term) (eq (ffn-symb term) (quote IF)) (or iff-flg (eq (ffn-symb term) (quote NOT)) (<reduce-id> (most-recent-enabled-recog-tuple (ffn-symb term) (global-val (quote recognizer-alist) wrld) ens)) (eq (ffn-symb term) (quote EQUAL)) (eq (ffn-symb term) (quote <))) t) nil nil nil nil) (nil nil nil nil (if if) (mv-let) (reduce-with-type-set reduce-with-type-set)) ((term iff-flg type-alist ens wrld iff-flg term recursivep term term iff-flg type-alist ens wrld) nil (declare) (let) (if mbt cond) nil nil) ((*nil* *t* (t1 (fargn term 1)) mbf tta fta term type-alist nil ens wrld *type-set-nnn*) nil (mbt mbf t) (equal ignore) (mv-let) nil nil) ((term *nil* tta fta *t* *nil* term) nil nil nil (mbt cond) nil nil) ((mbf tta fta t1 type-alist nil ens wrld *type-set-nnn*) nil (mbt mbf t) nil nil nil nil)) (/paco/type-set.lisp::dcons-term (nil nil nil (cond) nil nil nil) (nil nil ((and (eq fn (quote IF)) (not (and (nvariablep (car args)) (not (fquotep (car args))) (eq (ffn-symb (car args)) (quote IF))))) t) nil nil nil nil) (nil nil nil nil (mv-let) nil nil) ((nil type-alist ens wrld) nil (car cadr caddr n) (first-if cond) nil nil nil) ((args args args if-expr args) (0) ((null n) t) nil nil nil nil) (nil nil nil (let) (cond) nil nil) (((t1 (fargn if-expr 1))) nil ((equal fn (quote EQUAL)) (equal fn (quote IF)) t) nil (mv-let) nil nil)) (/paco/type-set.lisp::normalize (nil nil nil nil nil nil nil) ((iff-flg type-alist ens wrld t) nil nil nil nil nil (distribute-ifs)) ((term iff-flg type-alist ens wrld) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/clause-processors/SULFA/books/sat/check-output.lisp::lookup-un-fn-vals (nil nil nil nil nil nil (getprop)) ((fn not-found-val) nil (quote quote un-fn-world) nil nil nil nil) ((un-fn-vals un-fn-world $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::set-un-fn-vals (nil nil nil (update-un-fn-world) nil nil nil) (($sat) nil nil nil nil (putprop) nil) ((fn val) nil (quote un-fn-world) nil nil nil nil) ((un-fn-vals $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::unsatp (nil nil nil (and) nil nil nil) (nil nil (consp) (equal) nil nil nil) ((sat-output) nil (symbol-name symbol-name) nil nil nil nil) (nil nil (car quote) nil nil nil nil) ((sat-output unsat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::sat-inst-list (nil nil nil nil (if) nil nil) (nil nil (not cdr) nil (er) nil nil) ((hard No satisfying instance found~% sat-output) nil (quote) (and) nil nil nil) ((recursive-call) nil (consp) (equal) nil nil nil) ((sat-output) nil (symbol-name symbol-name) nil nil nil nil) (nil nil (car quote) nil nil nil nil) ((sat-output sat) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::known-consp (nil nil nil (let) nil nil nil) (((consp-var (consp-vari var $sat))) nil nil nil (if) nil nil) (nil nil (valid-varp) (mv mv) nil nil nil) ((consp-var t nil nil) nil nil (equal) nil nil nil) (nil (1) nil (ce-vali) nil nil nil) ((consp-var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::known-eq-atom1 (nil nil nil nil nil nil (cond)) (nil nil ((endp atom-alist) (equal (ce-vali (cdr (car atom-alist)) $sat) 1) (eq (car (car atom-alist)) nil) (eq (car (car atom-alist)) t) t) nil nil nil nil) (nil nil nil nil nil (mv mv recursive-call recursive-call recursive-call) nil) ((nil nil non-nil non-t t nil nil t non-t $sat non-nil t $sat non-nil non-t $sat) nil (car cdr cdr cdr) nil nil nil nil) ((atom-alist atom-alist atom-alist) nil (car) nil nil nil nil) ((atom-alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::known-eq-atom (nil nil nil nil nil (known-eq-atom1) nil) ((non-nil non-t $sat) nil nil (atoms-alist-vari) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::add-new-ce-val1 (nil nil nil (cond) nil nil nil) (nil nil ((not (valid-varp var)) t) nil nil nil nil) (nil nil nil (cond let) nil nil nil) ((($sat (update-ce-i-var-vali var val $sat))) nil ((endp todo-list) t) nil nil (recursive-call) nil) (($sat $sat) nil (logical-car) (car-vari cons) nil (recursive-call) nil) (($sat var $sat val todo-list) nil (caar cdar cdr) (cons) nil nil nil) ((todo-list todo-list todo-list) nil (logical-cdr) (cdr-vari) nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::add-new-ce-val (nil nil nil (let) nil nil nil) ((($sat (add-new-ce-val1 var val nil $sat))) nil nil (mv) nil nil nil) ((val $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::known-eq-val1 (nil nil nil (cond) nil nil nil) (nil nil ((endp eq-alist) t) nil nil nil nil) (nil nil nil (let*) nil nil (mv)) ((nil nil non-nil non-t non-cons-list) nil nil nil ((a (caar eq-alist))) nil nil) (nil nil (eq-x-a a-val eq-x-a-val (ce-val-unknownp a-val) eq-x-a-val (eq a-val nil) (eq a-val t) (consp a-val) t) nil nil nil nil) (nil nil (cdar) (ce-i-var-vali equal) nil nil (mv mv recursive-call recursive-call recursive-call recursive-call)) ((eq-alist a $sat nil nil nil nil t a-val non-cons-list t non-t non-cons-list $sat non-nil t non-cons-list $sat non-nil non-t $sat non-nil non-t non-cons-list $sat) (1) (not not cdr cdr cdr cdr) (ce-vali cons) (er) nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::known-eq-val (nil nil nil (let) nil nil nil) (((eq-alist (eq-alist-vari var $sat))) nil nil nil nil nil (known-eq-val1)) ((eq-alist non-nil non-t non-cons-list $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::car-non-cons-list (nil nil nil nil nil nil (cond)) (nil nil ((endp non-cons-list) (eq (caar non-cons-list) nil) (eq (caar non-cons-list) t) (consp (caar non-cons-list)) t) nil nil nil nil) (nil nil nil nil (mv) (recursive-call recursive-call recursive-call recursive-call) nil) ((car-non-nil car-non-t recursive-call t car-non-t recursive-call car-non-nil t recursive-call car-non-nil car-non-t car-non-nil car-non-t recursive-call) nil (cdr cdr cdr cdr) (cons) nil nil nil) ((non-cons-list non-cons-list non-cons-list recursive-call non-cons-list) nil (caar) nil nil nil nil) ((non-cons-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::cdr-non-cons-list (nil nil nil nil nil nil (cond)) (nil nil ((endp non-cons-list) (eq (cdar non-cons-list) nil) (eq (cdar non-cons-list) t) (consp (cdar non-cons-list)) t) nil nil nil nil) (nil nil nil nil (mv) (recursive-call recursive-call recursive-call recursive-call) nil) ((cdr-non-nil cdr-non-t recursive-call t cdr-non-t recursive-call cdr-non-nil t recursive-call cdr-non-nil cdr-non-t cdr-non-nil cdr-non-t recursive-call) nil (cdr cdr cdr cdr) (cons) nil nil nil) ((non-cons-list non-cons-list non-cons-list recursive-call non-cons-list) nil (cdar) nil nil nil nil) ((non-cons-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var-check (nil nil nil nil (if) nil nil) (nil nil (not) nil (mv-let) nil nil) ((nil nil nil nil non-nil non-t non-cons-const) nil (valid-varp) nil (eq-atom mv-let) (known-eq-atom) nil) ((var atom-val non-nil non-t var non-nil non-t $sat) nil (consp-known) (known-consp) (mv-let) nil nil) ((consp-val var $sat) nil nil nil (cond) (eq-val-known) (known-eq-val)) ((eq-val non-nil non-t non-cons-const var non-nil non-t non-cons-const $sat) nil (eq-atom eq-val-known t) nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::eval-i-expr (nil nil nil nil nil nil nil) (nil nil ((atom i-expr) (quotep i-expr) (eq (car i-expr) (quote consp)) (eq (car i-expr) (quote cons)) (eq (car i-expr) (quote equal)) t) nil nil nil nil) (nil nil (unquote ce-val-consp) (ce-i-var-vali ce-val-cons ce-val-equal) nil (er) nil) ((i-expr $sat i-expr hard Invalid i-expression: ~x0~% i-expr) nil (quote) (recursive-call recursive-call recursive-call recursive-call recursive-call) nil nil nil) (($sat $sat $sat $sat $sat recursive-call) nil (cadr cadr caddr cadr caddr) nil nil nil nil) ((i-expr i-expr i-expr i-expr i-expr) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-true-f-exprp (nil nil nil nil nil (cond) nil) (nil nil ((eq (quote t) f-expr) (eq (quote nil) f-expr) (< 0 f-expr) t) nil nil nil nil) ((t nil) nil nil (eq eq) nil nil nil) (nil (1 0) nil (ce-vali ce-vali) nil nil nil) ((f-expr $sat $sat) nil (-) nil nil nil nil) ((f-expr) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-cnf-lits-unsatp (nil nil nil nil (cond) nil nil) (nil nil ((endp cnf-lits) (ce-true-f-exprp (car cnf-lits) $sat) t) nil nil nil nil) ((t nil) nil nil (recursive-call) nil nil nil) (($sat) nil (cdr) nil nil nil nil) ((cnf-lits) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var-iete-list (nil nil nil nil (cond) nil nil) (nil nil ((endp iete-list) (ce-cnf-lits-unsatp (iete-cnf-lits (car iete-list)) $sat) t) nil nil nil nil) (nil nil nil (mv mv recursive-call) nil nil nil) ((nil nil t $sat) nil (cdr) (eval-i-expr) nil nil nil) (($sat iete-list) nil (iete-expr) nil nil nil nil) (nil nil (car) nil nil nil nil) ((iete-list) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var-cete-list (nil nil nil nil (cond) nil nil) (nil nil ((endp cete-list) (ce-cnf-lits-unsatp (cete-cnf-lits (car cete-list) $sat) $sat) t) nil nil nil nil) (nil nil nil (recursive-call) (mv mv) nil nil) ((nil nil nil t $sat) nil (cdr) (cete-car cete-cdr) nil nil nil) (($sat $sat cete-list) nil (car car) nil nil nil nil) ((cete-list cete-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var1 (nil nil nil (cond) nil nil nil) (nil nil (t-struct t) nil nil nil nil) (nil nil nil nil (mv-let mv-let) nil nil) (nil nil (known-val) (ce-var-iete-list cond) nil nil (ce-var-check cond)) ((val $sat val consp-known consp-val non-nil non-t non-cons-const var non-nil non-t non-cons-const $sat) nil (ts-iete-list known-val t known-val (or (and consp-known consp-val) (and (not consp-known) (or (valid-varp (car-vari var $sat)) (valid-varp (cdr-vari var $sat))))) (not non-nil) (not non-t) t) nil nil nil nil) ((t-struct) nil nil nil (add-new-ce-val mv-let add-new-ce-val mv-let add-new-ce-val add-new-ce-val mv-let) nil nil) ((var val $sat var val $sat var nil $sat var t $sat) nil (unused-num get-unused-number) (known-cons ce-var-cete-list cond car-non-nil) (mv-let add-new-ce-val) (car-non-cons-list) nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var (nil nil nil nil nil nil nil) ((var nil nil nil $sat) nil nil (todo-structi) nil nil nil) ((var $sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-var-list (nil nil nil (cond) nil nil nil) (nil nil ((endp var-list) t) nil nil nil nil) (($sat) nil nil nil nil (mv-let) nil) (nil nil (val declare) (ce-var recursive-call) nil nil nil) (($sat $sat $sat) nil (car ignore cdr) nil nil nil nil) ((var-list val var-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::get-ce-alist (nil nil nil nil (if) nil nil) ((ans) nil (endp) (let*) nil nil nil) ((input-alist) nil nil nil ((entry (car input-alist)) recursive-call) nil nil) (($sat) nil (input var val cdr) (cons) nil nil nil) ((input-alist ans) nil (car cdr) (ce-i-var-vali cons) nil nil nil) ((entry entry var $sat input val) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::btoi (nil nil nil nil (if) nil nil) ((x) (1 0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::add-ce-vals (nil nil nil nil (if) nil nil) (($sat) nil (endp) (let*) nil nil nil) ((inst-list ($sat (update-ce-vali n (btoi (car inst-list)) $sat))) nil nil nil (recursive-call) nil nil) (($sat) nil (1+ cdr) nil nil nil nil) ((n inst-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-list-i-expr-vals (nil nil nil (cond) nil nil nil) (nil nil ((endp i-expr-list) t) nil nil nil nil) (nil nil nil (revappend) (recursive-call) nil nil) ((acc nil $sat) nil (cdr) (cons) nil nil nil) ((i-expr-list acc) nil nil (eval-i-expr) nil nil nil) (($sat) nil (car) nil nil nil nil) ((i-expr-list) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::ce-un-fn-val-alist (nil nil nil (cond) nil nil nil) (nil nil ((endp ufe-list) t) nil nil nil nil) ((acc) nil nil (let) nil nil nil) (((arg-vals (ce-list-i-expr-vals (ufe-arg-list (car ufe-list)) nil $sat))) nil nil (cond) nil nil nil) (nil nil ((assoc-equal arg-vals acc) t) nil nil nil nil) (nil nil nil (let) (recursive-call) nil nil) ((acc $sat (call-val (ce-i-var-vali (ufe-top-var (car ufe-list)) $sat))) nil (cdr) nil (recursive-call) nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::add-ce-un-fn-vals (nil nil nil (cond) nil nil nil) (nil nil ((endp un-fn-list) t) nil nil nil nil) (($sat) nil nil (let*) nil nil nil) (nil nil nil (recursive-call) ((fn (car un-fn-list))) nil nil) (($sat) nil (ufe-list ce-un-fn-val-alist $sat cdr) nil nil nil nil) ((un-fn-list) nil nil nil (lookup-ufe-list ce-un-fn-val-alist set-un-fn-vals) nil nil) ((fn nil $sat ufe-list nil $sat fn ce-un-fn-val-alist $sat) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::gen-ce (nil nil nil (prog2$) nil nil nil) (nil nil (cw) (let*) nil nil nil) ((Generating counter-example~%) nil nil (mv) nil nil nil) ((ce-alist $sat) nil ($sat $sat $sat $sat $sat $sat ce-alist) nil nil nil nil) (nil nil nil (resize-ce-i-var-val resize-ce-val resize-ce-i-var-val add-ce-un-fn-vals) (add-ce-vals ce-var-list get-ce-alist) nil nil) (($sat *max-vars* $sat *max-vars* $sat $sat $sat $sat nil $sat) (0 1 0) (sat-inst-list completed-var-list un-fn-list) (rev-append) nil nil nil) ((sat-output $sat $sat nil) nil (input-alist) nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::run-ce (nil nil nil (cond) nil nil nil) (nil nil ((endp input-clause) t) nil nil nil nil) (nil nil nil nil nil (mv mv-let) nil) ((nil $sat state) nil (quote declare) nil (err if) (run-ce-expr) nil) ((no-error val $sat state ce-alist $sat state val) nil (car ignore) nil nil (mv recursive-call) nil) ((input-clause err t $sat state ce-alist $sat state) nil (quote cdr) nil nil nil nil) ((no-error input-clause) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::print-ce-ins (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let*) nil nil nil) ((ce-alist) nil nil ((entry (car ce-alist)) prog2$) nil nil nil) (nil nil (input-var val recursive-call) nil (cw) nil nil) ((~x0: ~x1~% input-var val) nil (car cdr cdr) nil nil nil nil) ((entry entry ce-alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::print-ce-un-fn (nil nil nil (cond) nil nil nil) (nil nil ((endp un-fn-val-alist) t) nil nil nil nil) ((nil) nil nil (let) nil nil nil) (nil nil ((arg-vals (quote-list (caar un-fn-val-alist) nil))) (prog2$) nil nil nil) (nil nil (call-val) (recursive-call) (cw) nil nil) ((~x0: ~x1~% call-val fn) nil (cdar cdr) (cons) nil nil nil) ((un-fn-val-alist fn arg-vals un-fn-val-alist) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::print-ce-un-fn-list (nil nil nil (cond) nil nil nil) (nil nil ((endp un-fn-list) t) nil nil nil nil) ((nil) nil nil nil (let*) nil nil) (nil nil (declare) ((fn (car un-fn-list)) recursive-call) nil nil nil) (($sat) nil (un-fn-val-alist val ignore cdr) nil nil nil nil) ((val un-fn-list) nil nil (print-ce-un-fn) (lookup-un-fn-vals) nil nil) ((fn nil $sat fn un-fn-val-alist) nil nil nil nil nil nil)) (/clause-processors/SULFA/books/sat/check-output.lisp::print-ce (nil nil nil nil (let*) nil nil) ((nil) nil ((val1 (print-ce-ins ce-alist)) declare) nil nil nil nil) (nil nil (val2) (ignore) nil nil nil) ((val1 val2) nil nil (print-ce-un-fn-list) nil nil nil) (($sat) nil (un-fn-list) nil nil nil nil) (($sat) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/coi/nary/rewrite-equal-hint.lisp::member? (nil nil nil nil (if) nil nil) ((nil) nil (consp) (or) nil nil nil) ((list) nil nil (equal recursive-call) nil nil nil) ((x x) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::equiv-term (nil nil nil nil nil nil (and)) (nil nil (consp consp consp) (equal let) nil nil nil) ((term (term (cadr term))) nil (car quote cdr cadr) nil nil nil (and)) ((term not term term term) nil (consp consp not) (member?) nil nil nil) ((equivs) nil (car cdr cddr) (equal) nil nil nil) ((term term term) nil (cadr caddr) nil nil nil nil) ((term term) nil nil nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::optimize-equiv-term (nil nil nil nil (if) nil nil) ((term) nil (`) nil nil (and) nil) (nil nil (consp consp consp symbolp) ((, (car term))) nil nil nil) ((term) nil (cdr cddr caddr , ,) nil nil nil nil) ((term term term) nil (caddr cadr) nil nil nil nil) ((term term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::step-rewrite-equiv-hint (nil nil nil nil (if) nil nil) (nil nil nil (and let) (if) nil nil) ((stable (term (car clause))) nil (consp) (let and) (if if) nil nil) ((clause (term (equiv-term equivs term)) stable cases once nil nil) nil (` `) (and) (if) nil nil) ((term stable once) nil nil nil (:computed-hint-replacement :computed-hint-replacement) (rewrite-equiv-hint rewrite-equiv-hint) nil) ((once equivs once cases equivs (step-rewrite-equiv-hint stable-under-simplificationp (quote t) (quote nil) (quote (, equivs)) clause) :cases (,@ cases) (step-rewrite-equiv-hint stable-under-simplificationp (quote nil) (quote nil) (quote (, equivs)) clause) :cases t) nil (cdr cdr) (cons) nil nil nil) ((cases clause clause) nil (`) nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::equiv-var-term (nil nil nil nil nil nil (and)) (nil nil (consp consp consp) (equal let) nil nil nil) ((term (term (cadr term))) nil (car quote cdr cadr) nil nil nil nil) ((term not term term term) nil (consp consp not) (member?) (if) nil nil) ((equivs) nil (car cdr cddr symbolp not) (equal) (if) nil nil) ((term term term nil) nil (cadr symbolp symbolp not cadr caddr) nil nil nil nil) ((term term term) nil (caddr caddr symbolp) nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::find-equiv (nil nil nil nil (if) nil nil) ((nil) nil (consp) (let) nil nil nil) ((clause (term (car clause))) nil nil (let) nil nil nil) (((term (equiv-var-term equivs term))) nil nil (or) nil nil nil) ((term) nil nil (recursive-call) nil nil nil) ((equivs) nil (cdr) nil nil nil nil) ((clause) nil nil nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::slow-rewrite-equiv-hint (nil nil nil nil (if) nil nil) (nil nil (consp) (let) (if) nil nil) ((clause (term (car clause)) cases) nil nil (let) (if if) nil nil) (((term (equiv-var-term equivs term)) once nil once nil) nil (` `) nil (if) nil nil) ((term) nil nil nil (:computed-hint-replacement :computed-hint-replacement) (recursive-call recursive-call) nil) ((once equivs once cases equivs (slow-rewrite-equiv-hint (quote t) (quote nil) (quote (, equivs)) clause) :cases (,@ cases) (slow-rewrite-equiv-hint (quote nil) (quote nil) (quote (, equivs)) clause) :cases t) nil (cdr cdr) (cons) nil nil nil) ((cases clause clause) nil (`) nil nil nil nil)) (/coi/nary/rewrite-equal-hint.lisp::slow-rewrite-equiv-hint (nil nil nil nil (if) nil nil) ((stbl nil) nil nil (let) nil nil nil) (((term (find-equiv equivs clause))) nil nil nil (if) nil nil) ((term) nil nil nil (if if) nil nil) ((once nil once nil) nil (`) (let) nil nil nil) (((term (` (not (hide (rewrite-equiv (, (optimize-equiv-term term)))))))) nil (`) nil (:computed-hint-replacement) nil nil) (((slow-rewrite-equiv-hint stable-under-simplificationp (quote nil) (quote (, equivs)) clause) :cases t) nil nil nil (:computed-hint-replacement) nil nil)))
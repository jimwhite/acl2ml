((/clause-processors/generalize.lisp::replace-alist-to-bindings (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((alist) nil nil (cons recursive-call) nil nil nil) ((bindings) nil (cdar cdr) (gen-eval) nil nil nil) ((alist bindings alist) nil (caar) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::simple-generalize-cp (nil nil nil (let) nil nil nil) (((syms (strip-cdrs alist))) nil nil nil (if) nil nil) (nil nil (list list) nil nil (and) nil) ((clause) nil (not symbol-listp not no-duplicatesp-equal) (replace-subterms-list) nil nil nil) ((syms syms clause alist) nil nil (intersectp-equal member-equal) nil nil nil) ((syms nil syms) nil (term-vars-list) nil nil nil nil) ((clause) nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::alist-for-simple-generalize-cp (nil nil nil (let) nil nil nil) (((syms (strip-cdrs alist))) nil nil nil (if) nil nil) ((env) nil nil (append) nil (and) nil) ((env) nil (not symbol-listp not no-duplicatesp-equal) (replace-alist-to-bindings) nil nil nil) ((syms syms alist env) nil nil (intersectp-equal member-equal) nil nil nil) ((syms nil syms) nil (term-vars-list) nil nil nil nil) ((clause) nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::char-of-digit-equal-fn (nil nil nil (implies) nil nil nil) (nil nil nil (equal) nil nil nil) (nil nil (integerp integerp) (<= <= < < equal equal) nil nil nil) ((n m n m n m n m) (0 0 10 10) (char-of-digit char-of-digit) nil nil nil nil) ((n m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::chars-of-digit-equal-n-fn (nil nil nil (or) nil nil nil) (nil nil (zp) (and) nil nil nil) ((m) nil nil (char-of-digit-equal-fn recursive-call) nil nil nil) ((n n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::chars-of-digit-equal-n-m-fn (nil nil nil (or) nil nil nil) (nil nil (zp) (and) nil nil nil) ((n) nil nil (chars-of-digit-equal-n-fn recursive-call) nil nil nil) ((m m) nil (1- 1-) nil nil nil nil) ((n n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::char-of-digit-members (nil nil nil (or) nil nil nil) (nil nil (zp) (and) nil nil nil) ((n) nil (recursive-call) (member-equal) nil nil nil) ((*digit-chars*) nil (char-of-digit 1-) nil nil nil nil) ((n) nil (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::nat-to-charlist1 (nil nil nil nil (if) nil nil) ((nil) nil (zp) (cons) nil nil nil) ((n) nil (char-of-digit recursive-call) nil nil nil nil) (nil nil nil (mod floor) nil nil nil) ((n n) (10 10) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::nat-to-str (nil nil nil (coerce) nil nil nil) (nil nil (reverse quote) nil nil nil nil) ((string) nil (nat-to-charlist) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::symbol-n (nil nil nil (intern-in-package-of-symbol) nil nil nil) ((base) nil nil nil (concatenate) nil nil) (nil nil (quote symbol-name nat-to-str) nil nil nil nil) ((string base n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::past-syms-in-avoid (nil nil nil nil (if) nil nil) (nil (0) (zp) nil (if) nil nil) ((m) nil (1+) (member-eq) (recursive-call) nil nil) ((avoid-lst base avoid-lst) nil (1-) (symbol-n) (recursive-call) nil nil) ((base base avoid-lst m) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/generalize.lisp::psia-redef (nil nil nil nil (if) nil nil) (nil (0) (zp) nil (if) nil nil) ((m) nil (1+) (member-eq) (recursive-call) nil nil) ((avoid-lst base avoid-lst) nil (1-) (symbol-n) (recursive-call) nil nil) ((base base m) nil (1- 1-) (remove-equal) nil nil nil) ((m m avoid-lst) nil nil (symbol-n) nil nil nil) ((base) nil (1-) nil nil nil nil)) (/clause-processors/generalize.lisp::make-n-vars (nil nil nil nil (if) nil nil) ((nil) nil nil (let) (or) nil nil) (((new (symbol-n base m))) nil (zp not not) nil (if) nil nil) ((n) nil (natp symbolp) (member-eq cons) nil (recursive-call) nil) ((m base new avoid-lst n base avoid-lst new) nil (1+) nil nil (recursive-call) nil) ((m base avoid-lst) nil (1- 1+) nil nil nil nil) ((n m) nil nil nil nil nil nil)))
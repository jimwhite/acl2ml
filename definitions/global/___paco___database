((/paco/database.lisp::trip-seen (nil nil nil (let) nil nil nil) (((temp (assoc-eq (car trip) seen))) nil nil (cond) nil nil nil) (nil nil ((null temp) t) nil nil nil nil) ((nil) nil nil (member-eq) nil nil nil) (nil nil (cadr cdr) nil nil nil nil) ((trip temp) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::mark-as-seen (nil nil nil (let) nil nil nil) (((temp (assoc-eq (car trip) seen))) nil nil (cond) nil nil nil) (nil nil ((null temp) t) nil nil nil nil) (nil nil nil (cons) (put-assoc-eq) nil nil) ((seen seen) nil (car) (cons cons) nil nil nil) ((trip) nil (car list cadr cdr) nil nil nil nil) ((trip trip temp) nil (cadr) nil nil nil nil)) (/paco/database.lisp::copy-recognizer-alist (nil nil nil (cond) nil nil nil) (nil nil ((endp alist) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((paco::recognizer-tuple :nume :fn :true-ts :false-ts :strongp) nil (cdr) nil (access access access access access) nil nil) ((recognizer-tuple :nume recognizer-tuple :fn recognizer-tuple :true-ts recognizer-tuple :false-ts recognizer-tuple :strongp alist) nil (car car car car car) nil nil nil nil) ((alist alist alist alist alist) nil nil nil nil nil nil)) (/paco/database.lisp::copy-type-prescriptions (nil nil nil (cond) nil nil nil) (nil nil ((endp tp-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((paco::type-prescription :nume :basic-ts :term :hyps :vars) nil (cdr) nil (access access access access access) nil nil) ((type-prescription :nume type-prescription :basic-ts type-prescription :term type-prescription :hyps type-prescription :vars tp-lst) nil (car car car car car) nil nil nil nil) ((tp-lst tp-lst tp-lst tp-lst tp-lst) nil nil nil nil nil nil)) (/paco/database.lisp::acceptable-rewrite-hyps (nil nil nil nil nil nil (cond)) (nil nil ((endp hyps) (or (variablep (car hyps)) (fquotep (car hyps))) (or (eq (ffn-symb (car hyps)) (quote FORCE)) (eq (ffn-symb (car hyps)) (quote CASE-SPLIT))) (and (eq (ffn-symb (car hyps)) (quote SYNP)) (not (eq (car (cadr (fargn (car hyps) 2))) (quote SYNTAXP)))) t) nil nil nil nil) ((t nil nil) nil (recursive-call recursive-call) nil nil nil nil) (nil nil (cdr cdr) nil nil nil nil) ((hyps hyps) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::copy-lemmas (nil nil nil nil (cond) nil nil) (nil nil ((endp lemmas) (acceptable-rewrite-hyps (access rewrite-rule (car lemmas) :hyps)) t) nil nil nil nil) ((nil) nil (recursive-call) (cons) nil nil nil) (nil nil (recursive-call cdr) nil nil nil nil) ((paco::rewrite-rule :nume :hyps :equiv :lhs :rhs :subclass :heuristic-info lemmas) nil (cdr) (let cond) (access access access access access) nil nil) ((rewrite-rule :nume rewrite-rule :hyps rewrite-rule :equiv rewrite-rule :lhs rewrite-rule :rhs (subclass (access rewrite-rule (car lemmas) :subclass)) lemmas) nil (car car car car car (eq (access rewrite-rule (car lemmas) :subclass) (quote definition)) t) nil nil nil (case)) ((lemmas lemmas lemmas lemmas lemmas subclass) nil (abbreviation meta definition otherwise) (cons) (access) nil nil)) (/paco/database.lisp::copy-elim-rule (nil nil nil nil nil nil nil) ((paco::elim-rule :nume :crucial-position :destructor-term :destructor-terms :hyps :equiv :lhs :rhs) nil (quote) nil (access access access access access access access) nil nil) ((elim-rule x :nume elim-rule x :crucial-position elim-rule x :destructor-term elim-rule x :destructor-terms elim-rule x :hyps EQUAL elim-rule x :lhs elim-rule x :rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::copy-built-in-clauses1 (nil nil nil (cond) nil nil nil) (nil nil ((endp bic-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((paco::built-in-clause :nume :all-fnnames :clause) nil (cdr) nil (access access access) nil nil) ((built-in-clause :nume built-in-clause :all-fnnames built-in-clause :clause bic-lst) nil (car car car) nil nil nil nil) ((bic-lst bic-lst bic-lst) nil nil nil nil nil nil)) (/paco/database.lisp::copy-built-in-clauses (nil nil nil (cond) nil nil nil) (nil nil ((endp bic-alist) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) (cons) nil nil nil) (nil nil (caar copy-built-in-clauses1 cdr) nil nil nil nil) ((bic-alist bic-alist) nil (cdar) nil nil nil nil) ((bic-alist) nil nil nil nil nil nil)) (/paco/database.lisp::copy-induction-machine (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil (paco::make)) ((paco::tests-and-calls :tests :calls) nil (cdr) nil (access access) nil nil) ((tests-and-calls :tests tests-and-calls :calls lst) nil (car car) nil nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/database.lisp::copy-quick-block-info (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil (case) nil) (nil nil (car self-reflexive unchanging otherwise cdr) nil nil nil nil) ((lst lst) nil (quote quote quote) nil nil nil nil) ((paco::self-reflexive paco::unchanging paco::questionable) nil nil nil nil nil nil)) (/paco/database.lisp::copy-justification (nil nil nil nil nil nil nil) ((paco::justification :subset :mp :rel :measure) nil nil nil (access access access access) nil nil) ((justification j :subset justification j :mp justification j :rel justification j :measure) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::copy-induction-rules (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((paco::induction-rule :nume :pattern :condition :scheme) nil (cdr) nil (access access access access) nil nil) ((induction-rule :nume induction-rule :pattern induction-rule :condition induction-rule :scheme lst) nil (car car car car) nil nil nil nil) ((lst lst lst lst) nil nil nil nil nil nil)) (/paco/database.lisp::copy-type-set-inverter-rules (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil nil) ((paco::type-set-inverter-rule :nume :ts :terms) nil (cdr) nil (access access subst-var-lst) nil nil) ((type-set-inverter-rule :nume type-set-inverter-rule :ts lst) nil (car car quote quote) nil (access) nil nil) ((lst lst paco::x acl2::x type-set-inverter-rule :terms) nil (car) nil nil nil nil)) (/paco/database.lisp::copy-generalize-rules (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) nil nil nil (paco::make)) ((paco::generalize-rule :nume :formula) nil (cdr) nil (access access) nil nil) ((generalize-rule :nume generalize-rule :formula lst) nil (car car) nil nil nil nil) ((lst lst) nil nil nil nil nil nil)) (/paco/database.lisp::copy-trips (nil nil nil nil nil (cond) nil) (nil nil ((equal w w0) (endp w) (trip-seen (car w) seen) t) nil nil nil nil) (nil nil nil (mv mv let*) nil nil nil) ((t nil seen a w0 paco-w0 state) nil (cdr) (revappend revappend) nil ((new-seen (mark-as-seen (car w) seen))) nil) ((a paco-w0 a nil w new-seen new-a w0 paco-w0 state) nil (sym prop val new-a cdr) nil nil nil nil) ((w) nil (caar cadar cddar) nil nil nil nil) ((w w w prop) nil (GLOBAL-VALUE FORMALS (BODY UNNORMALIZED-BODY RECURSIVEP CONTROLLER-ALISTS PRIMITIVE-RECURSIVE-DEFUNP LEVEL-NO) TYPE-PRESCRIPTIONS LEMMAS ELIMINATE-DESTRUCTORS-RULE INDUCTION-MACHINE QUICK-BLOCK-INFO JUSTIFICATION INDUCTION-RULES otherwise) nil nil nil nil)) (/paco/database.lisp::transfer-paco-w1 (nil nil nil nil (mv-let) nil nil) (nil nil (flg) (prog2$) nil nil nil) ((paco-w w nil nil w0 paco-w0 state) nil nil (retract-world extend-world) nil nil nil) ((paco-w) nil (quote quote) nil (if) nil nil) ((paco::paco flg paco-w0 nil paco::paco) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::transfer-paco-w (nil nil nil (let) nil nil nil) (((paco-w (if (and (boundp-global (quote paco::paco-w) state) (boundp-global (quote acl2::paco-w) state)) (transfer-paco-w1 (w state) (@ acl2::paco-w) (@ paco::paco-w) state) (transfer-paco-w1 (w state) nil nil state)))) nil nil (er-progn) nil nil nil) (nil nil (value) (assign) nil nil nil) ((paco::paco-w paco-w nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::copy-ens1 (nil nil nil nil nil (cond) nil) (nil nil ((not (and (integerp i) (<= 0 i) (integerp max) (<= 0 max))) (> i max) (aref1 array-name array i) t) nil nil nil nil) ((nil) nil nil (revappend) nil nil (recursive-call recursive-call)) ((ans nil max array-name array ans max array-name array) nil nil (+ + cons) nil nil nil) ((i i i ans) (1 1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::copy-ens (nil nil (paco::make-btree1) nil nil nil nil) (nil nil nil nil nil nil (copy-ens1)) ((nil) (0) nil nil (access access access) nil nil) ((enabled-structure ens :index-of-last-enabling enabled-structure ens :array-name enabled-structure ens :theory-array) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::transfer-paco-ens (nil nil nil (cond) nil nil nil) (nil nil ((and (boundp-global (quote paco::paco-ens) state) (boundp-global (quote acl2::paco-ens) state) (equal (@ acl2::paco-ens) (ens state))) t) nil nil nil nil) (nil nil (value) nil (er-progn) nil nil) ((nil) nil (value) (assign assign) nil nil nil) ((paco::paco-ens acl2::paco-ens nil) nil (copy-ens ens) nil nil nil nil) ((state) nil (ens) nil nil nil nil) ((state) nil nil nil nil nil nil)) (/paco/database.lisp::transfer-nume-to-rune-map (nil nil nil (let) nil nil nil) (nil nil ((d (car (cadr (assoc-keyword :dimensions (cdr (assoc-eq :header (access enabled-structure (ens state) :theory-array)))))))) (er-let*) nil nil nil) (((map (cond ((boundp-global (quote nume-to-rune-map) state) (value (@ nume-to-rune-map))) (t (er-progn (assign nume-to-rune-map (make enabled-structure :index-of-last-enabling -1 :theory-array (compress1 name (cons (list :header :dimensions (list d) :maximum-length (1+ d) :default nil :name name) nil)) :array-name name :array-length d :array-name-root (all-but-last (coerce (symbol-name name) (quote list))) :array-name-suffix 0)) (value (@ nume-to-rune-map))))))) nil (name) (cond) nil nil nil) (nil nil (quote (and (boundp-global (quote acl2::paco-w) state) (equal (@ acl2::paco-w) (w state))) t) nil nil nil nil) ((NUME-TO-RUNE-MAP-0) nil (value) (er-let*) nil nil nil) ((nil (map (load-theory-into-enabled-structure (quote (universal-theory-fn :here (w state))) (universal-theory-fn :here (w state)) nil map nil nil (w state) (quote transfer-nume-to-rune-map) state))) nil nil (er-progn) nil nil nil) (nil nil (value) (assign) nil nil nil)) (/paco/database.lisp::transfer-environments (nil nil nil (pprogn) nil nil nil) (nil nil nil (er-progn) nil nil (fms)) ((Computing and transferring the ACL2 environment to Paco... nil *standard-co* state nil) nil nil (cond) (if) nil nil) ((from-scratch-flg) nil (value (and (boundp-global (quote acl2::paco-w) state) (equal (@ acl2::paco-w) (w state))) t) (er-progn) nil nil nil) ((nil) nil nil (assign assign pprogn) nil nil (er-progn)) ((paco::paco-w nil acl2::paco-w nil) nil (value transfer-paco-w transfer-paco-ens transfer-nume-to-rune-map) (assign pprogn) nil nil (fms)) ((~%Done.~% nil *standard-co* state nil nil state state state acl2::paco-w) nil (w value) nil nil nil (fms))) (/paco/database.lisp::probable-paco-clause-id (nil nil nil nil (cond) nil nil) (nil nil ((atom lst) (and (integerp (car lst)) (< 0 (car lst))) t) nil nil nil nil) ((nil) nil (recursive-call) (equal) nil nil nil) ((lst nil) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::value-nil (nil nil nil (cond) nil nil nil) (nil nil ((eq x nil) t) nil nil nil nil) (nil nil (value) nil nil (er) nil) ((nil soft ctx Paco ~x0 hints must end in nil. key) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-use-hint (nil nil nil nil (cond) nil nil) (nil nil ((atom arg) (and (true-listp (car arg)) (eq (car (car arg)) :INSTANCE) (< 0 (len (cdr (car arg)))) (symbolp (cadr (car arg)))) t) nil nil nil nil) (nil nil nil (let) nil (value-nil er) nil) ((:USE arg ctx state (thm (formula (cadr (car arg)) nil wrld)) soft ctx Ill-formed :INSTANCE ~x0) nil (car) (er-let*) nil nil nil) ((arg) nil (value) ((alist (translate-substitution (cddr (car arg)) ctx wrld state))) nil nil nil) (nil nil (thm rst) (cons) nil nil nil) ((rst) nil nil (sublis-var) (if) (recursive-call) nil)) (/paco/database.lisp::translate-paco-expand-hint (nil nil nil (cond) nil nil nil) (nil nil ((atom arg) t) nil nil nil nil) (nil nil nil (er-let*) nil (value-nil) nil) ((:EXPAND arg ctx state (term (translate (car arg) t t t ctx wrld state))) nil nil (cond) nil nil nil) (nil nil ((and (nvariablep term) (not (fquotep term)) (or (flambda-applicationp term) (body (ffn-symb term) t wrld))) t) nil nil nil nil) (nil nil nil (er-let*) nil (er) nil) (((rst (translate-paco-expand-hint (cdr arg) ctx wrld state)) soft ctx The term ~x0 is not expandable. term) nil (value) nil nil nil nil)) (/paco/database.lisp::runes-to-numes (nil nil nil nil (cond) nil nil) (nil nil ((atom lst) (runep (car lst) wrld) t) nil nil nil nil) (nil nil (value) (er-let*) nil (er) nil) ((nil (rst (runes-to-numes (cdr lst) ctx wrld state)) soft ctx ~x0 is not a rune.) nil (value car) nil nil nil nil) ((lst) nil nil (add-to-set-equal) nil nil nil) ((rst) nil nil (fnume) nil nil nil) ((wrld) nil (car) nil nil nil nil)) (/paco/database.lisp::translate-paco-in-theory-hint (nil nil nil (cond) nil nil nil) (nil nil ((and (true-listp arg) (case (car arg) (paco::e/d (and (equal (len arg) 3) (true-listp (cadr arg)) (true-listp (caddr arg)))) (paco::enable t) (paco::disable t) (otherwise nil))) t) nil nil nil nil) (nil nil nil (er-let*) nil (er) nil) ((soft ctx Ill-formed :IN-THEORY hint, ~x0. arg) nil ((numes-to-enable (runes-to-numes (case (car arg) (paco::e/d (cadr arg)) (paco::enable (cdr arg)) (otherwise nil)) ctx wrld state))) (let) nil nil nil) (((currently-disabled-numes (paco::btree-contents (paco::ens)))) nil (numes-to-disable value) nil nil nil nil) (nil nil (paco::make-btree) nil nil (runes-to-numes) nil) ((ctx wrld state) nil nil (union-equal) nil (case) nil)) (/paco/database.lisp::translate-paco-hands-off-hint (nil nil nil nil nil (cond) nil) (nil nil ((atom arg) (and (consp (car arg)) (eq (car (car arg)) (quote lambda)) (consp (cdr (car arg))) (true-listp (cadr (car arg)))) (and (symbolp (car arg)) (function-symbolp (car arg) wrld)) t) nil nil nil nil) (nil nil nil (er-let* er-let*) nil (value-nil er) nil) ((:HANDS-OFF arg ctx state (rst (translate-paco-hands-off-hint (cdr arg) ctx wrld state)) soft ctx The object ~x0 is not a legal element of a :HANDS-OFF ~
           hint.) nil ((term (translate (cons (car arg) (cadr (car arg))) t t t ctx wrld state)) value value car) nil nil nil nil) ((arg) nil (rst) (cons cons) nil nil nil) ((rst rst) nil (ffn-symb car) nil nil (recursive-call) nil) ((ctx wrld state term arg) nil (cdr) nil nil nil nil)) (/paco/database.lisp::translate-paco-do-not-hint (nil nil nil (cond) nil nil nil) (nil nil ((and (true-listp arg) (subsetp-equal arg paco::*waterfall*)) t) nil nil nil nil) (nil nil (value) nil nil (er) nil) ((arg soft ctx The :DO-NOT hint requires a subset of ~x0. paco::*waterfall*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-cases-hint (nil nil nil (cond) nil nil nil) (nil nil ((atom arg) t) nil nil nil nil) (nil nil nil (er-let*) nil (value-nil) nil) ((:CASES arg ctx state) nil ((term (translate (car arg) t t t ctx wrld state)) value) nil nil nil nil) (nil nil (rst) (cons) nil nil nil) ((term rst) nil nil nil nil (recursive-call) nil) ((ctx wrld state) nil (cdr) nil nil nil nil)) (/paco/database.lisp::translate-paco-by-hint (nil nil nil (cond) nil nil nil) (nil nil ((symbolp arg) t) nil nil nil nil) (nil nil nil (let) nil (er) nil) (((thm (formula arg t wrld)) soft ctx ~x0 does not name a theorem. arg) nil nil (cond) nil nil nil) (nil nil (thm t) nil nil nil nil) (nil nil (value) nil nil (er) nil) ((thm soft ctx ~x0 does not name a theorem. arg) nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-induct-hint (nil nil nil (er-let*) nil nil nil) (((term (translate arg t t t ctx wrld state))) nil (value) nil nil nil nil) (nil nil nil nil (cond) nil nil) (nil nil ((equal term *nil*) (equal term *t*) t) nil nil nil nil) ((:DO-NOT-INDUCT t term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-x-hint (nil nil nil nil nil nil nil) ((key) nil (:USE :EXPAND :IN-THEORY :HANDS-OFF :DO-NOT :CASES :BY :INDUCT otherwise) nil nil nil nil) (nil nil nil nil nil (translate-paco-use-hint translate-paco-expand-hint translate-paco-in-theory-hint translate-paco-hands-off-hint translate-paco-do-not-hint translate-paco-cases-hint translate-paco-by-hint translate-paco-induct-hint er) nil) ((val ctx wrld state val ctx wrld state val ctx wrld state val ctx wrld state val ctx wrld state val ctx wrld state val ctx wrld state val ctx wrld state soft ctx Paco does not support ~x0 hints. key) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-hint-key-val-lst (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (keywordp (car lst)) t) nil nil nil nil) (nil nil (value) (er-let*) nil (er) nil) ((nil soft ctx Every other element of a hint specification must ~
               be a keyword and ~x0 is not.) nil ((tval (translate-paco-x-hint (car lst) (cadr lst) ctx wrld state)) value car) nil nil nil nil) ((lst) nil (rst) (cons) nil nil nil) ((rst) nil nil (cons) nil (recursive-call) nil) ((ctx wrld state tval) nil (cddr car) nil nil nil nil)) (/paco/database.lisp::translate-paco-hint (nil nil nil (cond) nil nil nil) (nil nil ((and (true-listp x) (probable-paco-clause-id (car x)) (evenp (len (cdr x)))) t) nil nil nil nil) (nil nil nil (er-let*) nil (er) nil) (((alist (translate-paco-hint-key-val-lst (cdr x) ctx wrld state)) soft ctx Each Paco hint must be of the form (id :key1 val1 ... :keyn valn),~
          where id is a true-list of natural numbers.  ~x0 is not of this ~
          form. x) nil (value) nil nil nil nil) (nil nil nil (cons) nil nil nil) ((alist) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/paco/database.lisp::translate-paco-hints (nil nil nil (cond) nil nil nil) (nil nil ((atom x) t) nil nil nil nil) (nil nil nil (er-let*) (if) nil nil) (nil nil (null value (pair (translate-paco-hint (car x) ctx wrld state)) value) nil (er) nil nil) ((x nil soft ctx :HINTS must be a true-list.) nil (rst) (cons) nil nil nil) ((pair rst) nil nil nil nil (recursive-call) nil) ((ctx wrld state) nil (cdr) nil nil nil nil)) (/paco/database.lisp::paco::defthm-fn (nil nil nil (er-progn) nil nil nil) (nil nil nil (transfer-environments er-let*) nil nil nil) ((state nil) nil ((tterm (translate term t t t (quote paco::defthm) (w state) state))) (let*) nil nil nil) (((p (paco::prove tterm (paco::ens) (paco::w) hint-settings waterfall-depth))) nil (hint-settings) (cond) nil nil nil) (nil nil ((eq (paco::describe-proof-attempt p 0) :QED) t) nil nil (translate-paco-hints) nil) ((hints state) nil (w) (cons er-progn) (er-progn) nil nil) ((name state) nil (quote value) (assign assign pprogn) nil nil nil)))
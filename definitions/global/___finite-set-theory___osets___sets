((/finite-set-theory/osets/sets.lisp::in (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (and and) nil nil nil) ((x) nil (not) (or or) nil nil nil) (nil nil (empty) (equal recursive-call equal and) nil nil nil) ((X a a a) nil (head tail car cdr) (or) nil nil nil) ((X X x x) nil nil (equal recursive-call) nil nil nil) ((a a) nil (cadr cddr) nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::subset (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (fast-subset) (if) nil nil) ((t X Y) nil (empty) (and) nil nil nil) ((X) nil nil (in recursive-call) nil nil nil) ((Y Y) nil (head tail) nil nil nil nil) ((X X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::fast-union (nil nil nil nil nil nil (cond)) (nil nil ((endp x) (endp y) (equal (car x) (car y)) (mbe :logic (<< (car x) (car y)) :exec (fast-lexorder (car x) (car y))) t) nil nil nil nil) (nil nil nil (revappend revappend) (recursive-call recursive-call recursive-call) nil nil) ((acc y acc x y x) nil (cdr cdr cdr cdr) (cons cons cons) nil nil nil) ((x y acc x acc y acc) nil (car car car) nil nil nil nil) ((x x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::fast-intersect (nil nil nil nil nil nil (cond)) (nil nil ((endp X) (endp Y) (equal (car X) (car Y)) (mbe :logic (<< (car X) (car Y)) :exec (fast-lexorder (car X) (car Y))) t) nil nil nil nil) (nil nil nil (revappend revappend) (recursive-call recursive-call recursive-call) nil nil) ((acc nil acc nil Y acc X acc) nil (cdr cdr cdr cdr) (cons) nil nil nil) ((X Y acc X Y) nil (car) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::fast-intersectp (nil nil nil nil nil nil (cond)) (nil nil ((endp X) (endp Y) (equal (car X) (car Y)) (mbe :logic (<< (car X) (car y)) :exec (fast-lexorder (car X) (car Y))) t) nil nil nil nil) ((nil nil t) nil nil (recursive-call recursive-call) nil nil nil) ((Y X) nil (cdr cdr) nil nil nil nil) ((X Y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::fast-difference (nil nil nil nil nil nil (cond)) (nil nil ((endp X) (endp Y) (equal (car X) (car Y)) (mbe :logic (<< (car X) (car Y)) :exec (fast-lexorder (car X) (car Y))) t) nil nil nil nil) (nil nil nil (revappend revappend) (recursive-call recursive-call recursive-call) nil nil) ((acc nil acc X acc Y X acc) nil (cdr cdr cdr cdr) (cons) nil nil nil) ((X Y X acc Y) nil (car) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::delete (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil nil (cond cond) nil nil) (nil nil ((empty X) (equal a (head X)) t (endp X) (equal a (car X)) t) nil nil nil nil) ((nil nil) nil (tail cdr) (insert insert) nil nil nil) ((X X) nil (head car) (recursive-call recursive-call) nil nil nil) ((X a X a) nil (tail cdr) nil nil nil nil) ((X X) nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::union (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil nil (if fast-union) nil nil) ((X Y nil) nil (empty sfix) (insert) nil nil nil) ((X Y) nil (head) (recursive-call) nil nil nil) ((X Y) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::intersect (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil nil (cond fast-intersect) nil nil) ((X Y nil) nil ((empty X) (in (head X) Y) t) nil nil nil nil) (nil nil (sfix) (insert recursive-call) nil nil nil) ((X Y) nil (head tail) (recursive-call) nil nil nil) ((X Y X) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::intersectp (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil (not) (fast-intersectp) nil nil nil) ((X Y) nil (empty) nil nil nil nil) (nil nil nil (intersect) nil nil nil) ((X Y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::difference (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil nil (cond fast-difference) nil nil) ((X Y nil) nil ((empty X) (in (head X) Y) t) nil nil nil nil) (nil nil (sfix) (recursive-call insert) nil nil nil) ((X Y) nil (tail head) (recursive-call) nil nil nil) ((X X Y) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::cardinality (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil (length) nil (if) nil nil) (nil (0) (empty 1+) (the) nil nil nil) ((X list X) nil (recursive-call) nil nil nil nil) (nil nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::mergesort-exec (nil nil nil nil (cond) nil nil) (nil nil ((atom x) (atom (cdr x)) t) nil nil nil nil) ((nil) nil nil nil (mv-let) (mbe) nil) ((:logic :exec) nil (list part1 halve-list) (insert) (fast-union) nil nil) ((nil part2 x nil) nil (car car recursive-call recursive-call) nil nil nil nil) ((x x part1 part2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::mergesort (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil (mergesort-exec) nil (if) nil nil) ((nil x) nil (endp) (insert) nil nil nil) ((x) nil (car recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::all (nil nil nil nil (if) nil nil) ((t) nil (empty) (and) nil nil nil) ((set-for-all-reduction) nil (predicate recursive-call) nil nil nil nil) (nil nil (head tail) nil nil nil nil) ((set-for-all-reduction set-for-all-reduction) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/finite-set-theory/osets/sets.lisp::weak-insert-induction (nil nil nil nil nil (cond) nil) (nil nil ((empty X) (in a X) (equal (head (insert a X)) a) t) nil nil nil nil) ((nil nil nil) nil (list) nil nil nil nil) (nil nil nil (recursive-call) nil nil nil) ((a) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
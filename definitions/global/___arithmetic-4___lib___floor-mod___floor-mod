((/arithmetic-4/lib/floor-mod/floor-mod.lisp::floor* (nil nil nil nil nil nil (cond)) (nil nil ((not (rationalp x)) (not (rationalp y)) (equal y 0) (< y 0) t) nil nil nil nil) ((t t t) nil nil nil (cond cond) nil nil) (nil nil ((< 0 x) (< y x) t (< x 0) (< x y) t) nil nil nil nil) ((t t) nil (1- 1+ 1- 1+) nil nil nil nil) (nil nil nil (recursive-call recursive-call recursive-call recursive-call) nil nil nil) ((y y y y) nil nil (+ - + -) nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::mod* (nil nil nil nil nil nil (cond)) (nil nil ((not (rationalp x)) (not (rationalp y)) (equal y 0) (< y 0) t) nil nil nil nil) ((t t t) nil nil nil (cond cond) nil nil) (nil nil ((< 0 x) (< y x) t (< x 0) (< x y) t) nil nil nil nil) ((t t) nil nil (recursive-call recursive-call recursive-call recursive-call) nil nil nil) ((y y y y) nil nil (+ - + -) nil nil nil) ((x y x y x y x y) nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::find-divisive-factor (nil nil nil nil nil nil nil) (nil nil ((variablep x) (fquotep x) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let let) (if) nil (cond)) ((nil (inv (invert-match x)) (temp (find-divisive-factor (arg1 x) mfc state))) nil (consp (eq (fn-symb (arg1 x)) (quote UNARY-/)) (quotep (arg1 x)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) (let) (if if) nil nil) (((c (unquote x)) nil nil temp temp) nil (cdr list) (let let let let and) (if recursive-call) nil nil) ((x nil (inv (invert-match x)) (c (unquote x)) (inv (invert-match x)) (inv (invert-match x)) mfc state) nil (list arg2) (cons) (and if if if if stable-under-rewriting-products) (proveably-non-zero) nil) ((nil nil nil nil mfc state inv mfc state inv x) nil (rationalp not list list list list quote ` quote) (< cons and and and) nil (and) nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::mod-+-cancel-0-fn-1 (nil nil nil nil nil (cond) nil) (nil nil ((equal (fargn x 1) z) (eq (fn-symb (fargn x 2)) (quote BINARY-+)) (equal (fargn x 2) z) t) nil nil nil nil) ((t t nil) nil nil (recursive-call) nil nil nil) ((z) nil nil (fargn) nil nil nil) ((x) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::mod-+-cancel-0-fn (nil nil nil nil (if) nil nil) ((nil) nil nil (and mod-+-cancel-0-fn-1) nil nil nil) ((x z) nil (not) (eq) nil nil nil) (nil nil (fn-symb quote) (eq) nil nil nil) ((x BINARY-+) nil (fn-symb quote) nil nil nil nil) ((z BINARY-+) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::floor-+-cancel-0-fn-2 (nil nil nil (let) nil nil nil) (((neg-x (negate-match x))) nil nil (and) nil nil nil) (nil nil nil (equal) (stable-under-rewriting-sums) nil nil) ((*t* neg-x mfc state) nil nil nil nil nil nil) ((t t mfc state) nil (quote `) nil nil nil nil) (nil nil nil (EQUAL (neg-x , neg-x)) nil nil nil) ((z) nil (UNARY--) (y z) nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::floor-+-cancel-0-fn-1 (nil nil nil nil nil (cond) nil) (nil nil ((floor-+-cancel-0-fn-2 (fargn x 1) y z mfc state) (eq (fn-symb (fargn x 2)) (quote BINARY-+)) (floor-+-cancel-0-fn-2 (fargn x 2) y z mfc state) t) nil nil nil nil) ((nil) nil (list list) nil nil nil (recursive-call)) ((y z mfc state) nil nil (cons fargn cons) nil nil nil) ((x) (2) (quote negate-match quote negate-match) nil nil nil nil) ((addend addend) nil nil (fargn fargn) nil nil nil) ((x x) (1 2) nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::floor-+-cancel-0-fn (nil nil nil nil (if) nil nil) ((nil) nil nil (and) nil nil (floor-+-cancel-0-fn-1)) ((x y z mfc state) nil (not) (eq) nil nil nil) (nil nil (fn-symb quote) (eq) nil nil nil) ((x BINARY-+) nil (fn-symb quote) nil nil nil nil) ((z BINARY-+) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::factors-ccc (nil nil nil nil (if) nil nil) (nil nil (list) (eq cons) nil nil nil) ((product) nil (fn-symb quote recursive-call) (fargn) nil nil nil) ((product BINARY-* product) (1) nil (fargn) nil nil nil) ((product) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::find-common-factors-1 (nil nil nil nil (cond) nil nil) (nil nil ((endp x-factors) (and (member-equal (car x-factors) y-factors) (proveably-non-zero-rational (quote X) (` ((x , (car x-factors)))) mfc state) (stable-under-rewriting-products (invert-match (car x-factors)) mfc state)) t) nil nil nil nil) ((nil) nil (list) nil nil (recursive-call) nil) ((y-factors mfc state) nil (cdr) (cons) nil nil nil) ((x-factors) nil (quote invert-match) nil nil nil nil) ((factor) nil (car) nil nil nil nil) ((x-factors) nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::find-common-factors (nil nil nil (let*) nil nil nil) (nil nil ((x-factors (factors-ccc x))) nil nil (find-common-factors-1) nil) ((x-factors y-factors mfc state) nil (y-factors) nil nil nil nil) (nil nil (factors-ccc) nil nil nil nil) ((y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::find-cancelling-addends (nil nil nil nil (cond) nil nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (and (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (negate-match x)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match x) mfc state)) t) nil nil nil nil) ((nil) nil (list) nil nil (cond) nil) (nil nil ((and (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (negate-match (fargn x 1))) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match (fargn x 1)) mfc state)) (eq (fn-symb (fargn x 2)) (quote BINARY-+)) (and (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (negate-match (fargn x 2))) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match (fargn x 2)) mfc state)) t) (cons) nil nil nil) ((nil) nil (list list quote negate-match) nil nil (recursive-call) nil) ((y mfc state addend x) nil nil (cons fargn cons) nil nil nil) ((x) (2) (quote negate-match quote negate-match) nil nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::simplify-mod-+-mod-fn (nil nil nil nil (cond) nil nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (and (eq (fn-symb x) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn x 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match x) mfc state)) t) nil nil nil nil) ((nil) nil nil (let) (list) nil nil) (nil nil ((arg1 (fargn x 1))) (cons cons cons) nil (cond) nil) (nil nil (arg2 (and (eq (fn-symb arg1) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn arg1 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match arg1) mfc state)) (eq (fn-symb arg2) (quote BINARY-+)) (and (eq (fn-symb arg2) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn arg2 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match arg2) mfc state)) t quote quote quote negate-match) (fargn fargn) nil nil nil) ((nil w x z x term x) (1 2) nil (fargn) (list list) (recursive-call) nil) ((x arg2 y mfc state) (2) nil (cons cons cons cons cons cons) nil nil nil)) (/arithmetic-4/lib/floor-mod/floor-mod.lisp::simplify-mod-+-minus-mod-fn (nil nil nil nil (cond) nil nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (and (eq (fn-symb x) (quote UNARY--)) (eq (fn-symb (fargn x 1)) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn (fargn x 1) 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match (fargn x 1)) mfc state)) t) nil nil nil nil) ((nil) nil nil (let) (list) nil nil) (nil nil ((arg1 (fargn x 1))) (cons cons cons) nil (cond) nil) (nil nil (arg2 (and (eq (fn-symb arg1) (quote UNARY--)) (eq (fn-symb (fargn arg1 1)) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn (fargn arg1 1) 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match (fargn arg1 1)) mfc state)) (eq (fn-symb arg2) (quote BINARY-+)) (and (eq (fn-symb arg2) (quote UNARY--)) (eq (fn-symb (fargn arg2 1)) (quote MOD)) (proveably-integer (quote (BINARY-* X (UNARY-/ Y))) (` ((x , (fargn (fargn arg2 1) 2)) (y , y))) mfc state) (stable-under-rewriting-sums (negate-match (fargn arg2 1)) mfc state)) t quote quote quote negate-match) (fargn fargn) nil nil nil) ((nil w z term) (1 2) nil (fargn fargn fargn fargn) (list list) (recursive-call) nil) ((x arg2 y mfc state x x x) (2 1 1 1) nil (cons cons cons cons cons cons) nil nil nil)))
((/arithmetic-4/lib/basic-ops/simplify.lisp::simplify-terms-such-as-ax+bx-rel-0-fn (nil nil nil nil (if) nil nil) ((nil) nil nil (eq let) nil nil nil) (((common-factors (common-factors (factors (arg1 sum)) (arg2 sum)))) nil (fn-symb quote) nil (if) nil nil) ((sum BINARY-+ common-factors nil) nil nil (let) nil nil nil) (nil nil ((common (make-product common-factors))) (list) nil nil nil) (nil nil (remainder) (cons cons) nil nil nil) ((common remainder) nil (quote quote) (remainder) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::good-val-triple-p (nil nil nil nil nil nil nil) (nil nil (consp rationalp consp rationalp consp rationalp) nil nil nil nil) ((x) nil (car cdr cadr cddr caddr) nil nil nil nil) ((x x x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::val-< (nil nil nil nil nil nil nil) (nil nil ((< (car x) (car y)) (< (car y) (car x)) (< (cadr x) (cadr y)) (< (cadr y) (cadr x)) (< (caddr x) (caddr y)) t) nil nil nil nil) ((t nil t nil t nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::addend-val (nil nil nil nil nil nil (cond)) (nil nil ((variablep addend) (constant-p addend) (eq (ffn-symb addend) (quote UNARY--)) (and (eq (ffn-symb addend) (quote BINARY-*)) (constant-p (arg1 addend))) t) nil nil nil nil) (nil nil (recursive-call) (let let) (list list) nil nil) (((val (unquote addend)) (val (unquote (arg1 addend)))) (0 1 0 0 1 0) (arg1) nil (if if) nil nil) ((addend) nil (rationalp rationalp) nil (list list list list) nil nil) ((val val) (0 0 0 0 1 0 0 1 0 0) (abs abs) nil nil nil nil) ((val val) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::addend-info-entry (nil nil nil nil (list) nil nil) ((x) nil (addend-pattern addend-val) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::info-entry-p (nil nil nil (and) nil nil nil) (nil nil (true-listp good-val-triple-p) nil nil nil nil) ((x) nil (cadr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::info-list-p (nil nil nil nil (if) nil nil) (nil nil (consp) (and eq) nil nil nil) ((x x nil) nil (info-entry-p recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::addend-info-list (nil nil nil nil (if) nil nil) (nil nil (list) (eq cons) nil nil nil) (nil nil (fn-symb quote addend-info-entry recursive-call addend-info-entry) nil nil nil nil) ((x BINARY-+ x) nil (arg1 arg2) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::assoc-addend (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-addend-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::first-match-in-addend-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-addend (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-sums (negate-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-sums (negate-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-matching-addends (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (addend-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-addend-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (addend-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::negative-addend-p (nil nil nil (or) nil nil nil) (nil nil nil (and) (and) nil nil) (nil nil (rational-constant-p) (eq or eq <) nil nil nil) (nil (0) (fn-symb quote variablep not fn-symb quote arg1 unquote) nil nil nil nil) ((x UNARY-- x BINARY-* x) nil (arg1 arg1) (equal) nil nil nil) ((x x) nil (ffn-symb quote) nil nil nil nil) ((UNARY--) nil (arg1) nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-negative-addend1 (nil nil nil nil nil nil (cond)) (nil nil ((not (eq (fn-symb x) (quote BINARY-+))) (and (negative-addend-p (arg1 x)) (stable-under-rewriting-sums (negate-match (arg1 x)) mfc state)) (eq (fn-symb (arg2 x)) (quote BINARY-+)) (and (negative-addend-p (arg2 x)) (stable-under-rewriting-sums (negate-match (arg2 x)) mfc state)) t) nil nil nil nil) ((nil) nil (list list) nil (if recursive-call) nil nil) ((nil mfc state) nil (list arg2) (and cons cons) nil nil nil) ((x) nil (negative-addend-p quote negate-match quote negate-match) (cons) (stable-under-rewriting-sums) nil nil) ((x mfc state x x) nil (negate-match quote negate-match arg1 arg2) nil nil nil nil) ((x x x x x) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-negative-addend (nil nil nil (let) nil nil nil) (((temp1 (find-negative-addend1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-negative-addend1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-val-gather-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (abs) (+) (if) nil nil) (nil (1) (unquote rational-constant-p abs recursive-call recursive-call) nil nil nil nil) ((exponent) nil (arg1 unquote arg1 arg2) nil nil nil nil) ((exponent exponent exponent) nil (arg1) nil nil nil nil) ((exponent) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-val-gather-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (constant-p factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil nil (recursive-call recursive-call) (let) (list list list) nil nil) (((val (unquote factor))) (0 1 0 0 0 0 1 0) (arg1 arg1 factor-val-gather-exponents1) nil (if) nil nil) ((factor factor) nil (rationalp arg2) nil (list list) nil nil) ((val factor) (0 0 0 0 1) (abs) nil nil nil nil) ((val) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-val-scatter-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (abs) (+) (if) nil nil) (nil (1) (unquote rational-constant-p abs recursive-call recursive-call) nil nil nil nil) ((exponent) nil (arg1 unquote arg1 arg2) nil nil nil nil) ((exponent exponent exponent) nil (arg1) nil nil nil nil) ((exponent) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-val-scatter-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (constant-p factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil nil (recursive-call recursive-call) (let) (list list list) nil nil) (((val (unquote factor))) (0 1 0 0 0 0 1 0) (arg1 arg1 factor-val-scatter-exponents1) nil (if) nil nil) ((factor factor) nil (rationalp arg2) nil (list list) nil nil) ((val factor) (0 0 0 0 1) (abs) nil nil nil nil) ((val) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-gather-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-gather-exponents factor-val-gather-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::assoc-factor-gather-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-gather-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-gather-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (val-< (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-gather-exponents-info-list (nil nil nil nil nil (cond) nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote BINARY-*)) (eq (fn-symb x) (quote UNARY--)) t) nil nil nil nil) (nil nil (recursive-call list) (let cons) nil nil nil) (((temp (factor-gather-exponents-info-list (arg2 x)))) nil (factor-gather-exponents-info-entry recursive-call arg1 factor-gather-exponents-info-entry) nil (if) nil nil) ((temp nil x x) nil (arg1 arg2) (factor-gather-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::first-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-factor-gather-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-gather-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::first-rational-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-rational-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-rational-match-in-factor-gather-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-gather-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-scatter-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-scatter-exponents factor-val-scatter-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::assoc-factor-scatter-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-scatter-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-scatter-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (val-< (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::factor-scatter-exponents-info-list (nil nil nil nil nil (cond) nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote UNARY--)) (eq (fn-symb x) (quote BINARY-*)) t) nil nil nil nil) (nil nil (factor-gather-exponents-info-list list) (let cons) nil nil nil) (((temp (factor-scatter-exponents-info-list (arg2 x)))) nil (arg1 factor-scatter-exponents-info-entry recursive-call factor-scatter-exponents-info-entry) nil (if) nil nil) ((temp nil x x) nil (arg1 arg2) (factor-scatter-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::first-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil nil (cond) (recursive-call) nil) ((info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil nil nil) ((info-list1) nil (list list) nil nil (recursive-call) nil) ((info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-match-in-factor-scatter-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-scatter-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::first-rational-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (cond) (recursive-call) nil) ((temp info-list2 mfc state) nil ((and (val-< (cadr (car info-list1)) (cadr temp)) (stable-under-rewriting-products (invert-match (caddr (car info-list1))) mfc state)) (stable-under-rewriting-products (invert-match (caddr temp)) mfc state) t cdr) nil nil (proveably-rational) nil) ((mfc state info-list1) nil (quote ` list list) nil nil (recursive-call) nil) ((x (x , (caddr temp)) info-list2 mfc state) nil (cdr) (cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-rational-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) nil (if) nil nil) ((info-list2 nil) nil (info-list2) nil nil (first-rational-match-in-factor-scatter-exponents-info-lists) nil) ((info-list1 info-list2 mfc state) nil nil nil (if) nil nil) ((info-list1 nil) nil (factor-scatter-exponents-info-list) nil nil nil nil) ((rhs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents2 (nil nil nil nil nil nil (cond)) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let) (if) nil (cond)) ((nil (temp (find-divisive-factor-scatter-exponents2 (arg1 x) mfc state))) nil (list (eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (consp (cdr (arg1 x))) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) nil (stable-under-rewriting-products if) nil nil) ((mfc state nil temp temp) nil (invert-match) (cons) (if if if if recursive-call) nil nil) ((x nil nil nil nil mfc state) nil (quote invert-match list list list list arg2) nil (stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products) nil nil) ((x x mfc state mfc state mfc state mfc state x) nil (invert-match invert-match invert-match invert-match) (cons cons cons cons) nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (let) (find-divisive-factor-scatter-exponents2) nil nil) (((temp (find-divisive-factor-scatter-exponents2 (arg1 x) mfc state)) x mfc state) nil nil nil (if) nil nil) ((temp temp) nil nil nil (recursive-call) nil nil) ((mfc state) nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-divisive-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-divisive-factor-scatter-exponents1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-divisive-factor-scatter-exponents1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents2 (nil nil nil nil nil nil (cond)) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let) (if) nil (cond)) ((nil (temp (find-rational-divisive-factor-scatter-exponents2 (arg1 x) mfc state))) nil (list (eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (consp (cdr (arg1 x))) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) (and) (if) nil nil) ((nil temp temp) nil nil (cons) (stable-under-rewriting-products if if if if recursive-call) (proveably-rational) nil) ((mfc state mfc state nil nil nil nil mfc state) nil (quote ` invert-match quote invert-match list list list list arg2) (and and and and) nil nil nil) ((x (x , x) x x x x) nil nil (cons cons cons cons) (stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products stable-under-rewriting-products) (proveably-rational proveably-rational proveably-rational proveably-rational) nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (let) (find-rational-divisive-factor-scatter-exponents2) nil nil) (((temp (find-rational-divisive-factor-scatter-exponents2 (arg1 x) mfc state)) x mfc state) nil nil nil (if) nil nil) ((temp temp) nil nil nil (recursive-call) nil nil) ((mfc state) nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/arithmetic-4/lib/basic-ops/simplify.lisp::find-rational-divisive-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-rational-divisive-factor-scatter-exponents1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1 temp1) nil nil (let) nil nil nil) (((temp2 (find-rational-divisive-factor-scatter-exponents1 rhs mfc state))) nil nil nil (if) nil nil) ((temp2 temp2 nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
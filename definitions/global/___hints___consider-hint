((/hints/consider-hint.lisp::listify-consideration-lst (nil nil nil nil nil nil (cond)) (nil nil ((atom arg) (not (true-listp arg)) (null (cdr arg)) (and (symbolp (car arg)) (keywordp (cadr arg))) t) nil nil nil nil) ((nil arg arg) nil (list list) nil nil nil nil) ((arg arg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::get-lhs (nil nil nil (let) nil nil nil) (((lst (unprettyify term))) nil nil (cond) nil nil nil) (nil nil ((equal (length lst) 1) t) nil nil nil nil) (nil nil nil nil (er) (mv-let) nil) ((soft ctx We cannot determine the :lhs of a formula because it ~
             flattens to more than one clause.) nil (declare value) nil (equiv) (interpret-term-as-rewrite-rule1) nil) ((lhs rhs ttree t wrld lhs) nil (remove-lambdas ens) nil (ignore) nil nil) ((state equiv rhs ttree) nil (cdr) nil nil nil nil)) (/hints/consider-hint.lisp::translate-consideration1 (nil nil nil (cond) nil nil nil) (nil nil ((not (and (symbolp name) (formula name nil wrld) (true-listp lst) (evenp (length lst)) (subsetp (evens lst) (quote (:pattern :target :instance :functional-instance))))) t) nil nil nil nil) (nil nil nil (er-let*) nil (er) nil) ((soft ctx A :CONSIDER hint element should be a list consisting of an ~
         event name followed by a list of even length containing ~
         alternating keys and values, with the keys :PATTERN, ~
         :TARGET, :INSTANCE, and :FUNCTIONAL-INSTANCE being legal. ~
         Your hint element ~x0 is ill-formed!) nil (value) (cons) ((pattern (let ((temp (assoc-keyword :pattern lst))) (cond ((and temp (not (eq (cadr temp) :lhs))) (translate (cadr temp) t t t ctx wrld state)) (t (get-lhs (formula name nil wrld) ctx wrld state)))))) nil nil) ((name lst) nil (target var-alist fn-alist) nil nil nil nil) ((consideration :name name :pattern pattern :target target :psubst0 :user-level) nil nil (let cons) (convert-var-and-fn-alists-to-psubst) (translate-substitution translate-functional-substitution) nil) (((temp (assoc-keyword :target lst)) ctx wrld state ctx wrld state var-alist fn-alist wrld name lst) nil (cadr cadr) nil (cond) nil nil)) (/hints/consider-hint.lisp::translate-consideration (nil nil nil (cond) nil nil nil) (nil nil ((atom x) t) nil nil nil nil) (nil nil nil nil nil nil (translate-consideration1 translate-consideration1)) ((x nil ctx wrld state ctx wrld state) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::translate-consider-hint1 (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) (nil nil (value) (er-let*) nil nil nil) ((nil) nil ((c (translate-consideration (car lst) ctx wrld state)) value) nil nil nil nil) (nil nil (rest) (cons) nil nil nil) ((c rest) nil nil nil nil (recursive-call) nil) ((ctx wrld state) nil (cdr) nil nil nil nil)) (/hints/consider-hint.lisp::translate-consider-hint (nil nil nil (cond) nil nil nil) (nil nil ((null arg) t) nil nil nil nil) (nil nil nil (let) (er) nil nil) ((soft ctx Empty :CONSIDER hints are illegal. (lst (listify-consideration-lst arg))) nil nil (cond) nil nil nil) (nil nil ((null lst) t) nil nil nil nil) (nil nil nil nil nil (er translate-consider-hint1) nil) ((soft ctx The value of a :CONSIDER hint must be a symbol ~
                       or a true-list and ~x0 is neither. arg lst ctx wrld state) nil nil nil nil nil nil)) (/hints/consider-hint.lisp::convert-pairs-to-doublets (nil nil nil (cond) nil nil nil) (nil nil ((endp alist) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) (list) nil nil nil) (nil nil (car cdr cdr) nil nil nil nil) ((alist) nil (car car) nil nil nil nil) ((alist alist) nil nil nil nil nil nil)) (/hints/consider-hint.lisp::convert-doublets-to-pairs (nil nil nil (cond) nil nil nil) (nil nil ((endp substn) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (recursive-call) (cons) nil nil nil) (nil nil (car cadr cdr) nil nil nil nil) ((substn) nil (car car) nil nil nil nil) ((substn substn) nil nil nil nil nil nil)) (/hints/consider-hint.lisp::prettyify-substn (nil nil nil (cond) nil nil nil) (nil nil ((endp substn) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (list) (recursive-call) nil nil) ((functionalp wrld) nil (car cdr) nil (if) nil nil) ((functionalp substn) nil (car) nil (if untranslate) nil nil) ((substn nil wrld) nil (symbolp cadr cadr) (make-lambda) nil nil nil)) (/hints/consider-hint.lisp::prettyify-lmi (nil nil nil nil nil nil (cond)) (nil nil ((atom lmi) (eq (car lmi) :instance) (eq (car lmi) :functional-instance) (eq (car lmi) :theorem) t) nil nil nil nil) ((lmi lmi) nil nil (list) (list* list*) nil nil) ((:INSTANCE :FUNCTIONAL-INSTANCE :theorem) nil nil (recursive-call recursive-call) (prettyify-substn prettyify-substn untranslate) nil nil) ((wrld nil wrld wrld t wrld t wrld) nil (cadr cddr cadr cddr cadr) nil nil nil nil) ((lmi lmi lmi lmi lmi) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::prettyify-lmi-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp lmi-lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (prettyify-lmi recursive-call) nil nil nil) ((wrld wrld) nil (car cdr) nil nil nil nil) ((lmi-lst lmi-lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::convert-mixed-subst-to-lmi (nil nil nil nil (mv-let) nil nil) (nil nil (var-alist strip-mixed-subst) nil (mv-let) nil nil) ((initial-fn-alist mixed-subst) nil (fn-alist `) nil (rename-free-vars-in-fn-substitution) nil nil) ((inverse-subst thm initial-fn-alist wrld) nil nil nil (:INSTANCE) nil nil) (nil nil (,@ ,@) (:FUNCTIONAL-INSTANCE) nil nil nil) ((inverse-subst) nil (, ,@ convert-pairs-to-doublets) nil nil nil nil) ((name var-alist) nil (convert-pairs-to-doublets) nil nil nil nil)) (/hints/consider-hint.lisp::convert-mixed-substs-to-lmi-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp mixed-substs) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil nil nil (convert-mixed-subst-to-lmi recursive-call) nil) ((name thm wrld name thm wrld) nil (car cdr) nil nil nil nil) ((mixed-substs mixed-substs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::prettyify-ranked-mixed-substs (nil nil nil (cond) nil nil nil) (nil nil ((endp ranked-mixed-substs) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (list) nil (recursive-call) nil) ((name thm wrld) nil (car cdr) (prettyify-lmi) nil nil nil) ((wrld ranked-mixed-substs) nil (car) nil nil (convert-mixed-subst-to-lmi) nil) ((ranked-mixed-substs name thm wrld) nil (cdr) nil nil nil nil)) (/hints/consider-hint.lisp::collect-high-ranking-mixed-substs (nil nil nil nil nil (cond) nil) (nil nil ((endp ranked-mixed-substs) (endp (cdr ranked-mixed-substs)) (equal (car (car ranked-mixed-substs)) (car (cadr ranked-mixed-substs))) t) nil nil nil nil) ((nil) nil (list list) (cons) nil nil nil) (nil nil (cdr cdr recursive-call cdr) nil nil nil nil) (nil nil (car car cdr car) nil nil nil nil) ((ranked-mixed-substs ranked-mixed-substs ranked-mixed-substs ranked-mixed-substs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::convert-considerations-to-lmi-lst-lst (nil nil nil (cond) nil nil nil) (nil nil ((endp considerations) t) nil nil nil nil) (nil nil (value) (er-let*) nil nil nil) ((nil) nil ((lmi-lst (convert-consideration-to-lmi-lst cl (car considerations) wrld nil ctx state)) value) nil nil nil nil) (nil nil (lmi-lst-lst) (cons) nil nil nil) ((lmi-lst lmi-lst-lst) nil nil nil nil nil (recursive-call)) ((cl wrld ctx state) nil (cdr) nil nil nil nil)) (/hints/consider-hint.lisp::dnf-size (nil nil nil (cond) nil nil nil) (nil nil ((endp cnf) t) nil nil nil nil) (nil (1) nil (*) nil nil nil) (nil nil (len recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((cnf cnf) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::convert-considerations-to-dnf (nil nil nil (er-let*) nil nil nil) (((cnf (convert-considerations-to-lmi-lst-lst cl considerations wrld ctx state))) nil nil (cond) nil nil nil) (nil nil ((< 100 (dnf-size cnf)) t) nil nil nil nil) (nil nil (value) nil nil (er) nil) ((soft ctx There are ~x0 combinations of substitutions ~
                 suggested by your :consider hint.  We abort when ~
                 there are more than 100.  Sorry.) nil (dnf-size) (all-picks) nil nil nil) ((cnf cnf nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::map-list (nil nil nil (cond) nil nil nil) (nil nil ((endp lst) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (list recursive-call) nil nil nil) ((x x) nil (car cdr) nil nil nil nil) ((lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::process-considerations (nil nil nil (er-let*) nil nil nil) (nil nil ((considerations (translate-consider-hint val ctx wrld state)) value) nil nil nil nil) (nil nil (lmi-lst-lst) (cond) nil nil nil) (nil nil ((and (consp lmi-lst-lst) (null (cdr lmi-lst-lst))) t) nil nil nil (convert-considerations-to-dnf)) ((cl considerations wrld ctx state) nil nil (list list) nil nil nil) ((:USE :OR) nil (car) (map-list) nil nil nil) ((lmi-lst-lst :USE lmi-lst-lst) nil nil nil nil nil nil)) (/hints/consider-hint.lisp::put-assoc-keyword (nil nil nil nil (cond) nil nil) (nil nil ((endp keyword-alist) (eq key (car keyword-alist)) t) nil nil nil nil) (nil nil nil (list cons cons) nil nil nil) ((key val key) nil (car) (cons cons) nil nil nil) ((val keyword-alist) nil (cddr cadr) nil (recursive-call) nil nil) ((keyword-alist keyword-alist key val) nil (cddr) nil nil nil nil) ((keyword-alist) nil nil nil nil nil nil)) (/hints/consider-hint.lisp::consider-hint-generator (nil nil nil (er-let*) nil nil nil) (((or-seg (process-considerations val clause world ctx state))) nil (value) nil nil nil nil) (nil nil nil nil (put-assoc-keyword) nil nil) ((:merge t) nil nil nil (splice-keyword-alist) nil nil) ((:consider or-seg) nil nil nil (splice-keyword-alist) nil nil) ((:merge nil keyword-alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/consider-hint.lisp::consider-hint-checker (nil nil nil (er-let*) nil nil nil) (((temp (translate-consider-hint val ctx world state))) nil (value) nil nil nil nil) ((nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/defexec/find-path/fpst.lisp::number-unmarked1 (nil nil nil nil (if) nil nil) (nil (0) nil (and) (if) nil nil) (nil nil (integerp 1+) (< = recursive-call) nil nil nil) ((i i maxnode st) (1) (1+) (marksi recursive-call) nil nil nil) ((i st i st) nil (1+) nil nil nil nil) ((i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::number-unmarked (nil nil nil (number-unmarked1) nil nil nil) ((st) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::measure-st (nil nil nil (cons) nil nil nil) (nil nil (1+ len) nil nil nil nil) ((c) nil (number-unmarked) nil nil nil nil) ((st) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::numberlistp (nil nil nil nil (if) nil nil) (nil nil (consp) (and equal) nil nil nil) ((l l nil) nil nil (bounded-natp recursive-call) nil nil nil) ((max max) nil (car cdr) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::graphp1-st (nil nil nil nil (if) nil nil) ((t) nil nil (and and) nil nil nil) (nil nil (stp) (bounded-natp numberlistp recursive-call) nil nil nil) ((i maxnode st maxnode st) nil (1+) (gi) nil nil nil) ((i st i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::graphp-st (nil nil nil (and) nil nil nil) (nil nil (stp) (graphp1-st) nil nil nil) ((st st) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::myrev (nil nil nil nil (if) nil nil) ((nil) nil (endp) (append) nil nil nil) ((x) nil (recursive-call list) nil nil nil nil) (nil nil (cdr car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::repeat (nil nil nil nil (if) nil nil) ((nil) nil nil (and cons) nil nil nil) ((v) nil (integerp) (< recursive-call) nil nil nil) ((n n v) (0) (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::linear-find-next-step-st-mbe (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil nil (if if) nil nil) ((st st) nil (endp endp) (let) (cond) nil nil) ((c c) nil ((cur (coerce-node (car c))) (equal (marksi (car c) st) 1) (equal (car c) b) t) nil (cond) nil nil) (nil nil (temp (equal (marksi cur st) 1) (equal cur b) t) (let let) (recursive-call) nil nil) ((b st (st (update-status 0 st)) (st (update-marksi (car c) 1 st))) nil (number-unmarked cdr) (let let update-stack let) (recursive-call) nil nil) ((st b st (st (update-status 0 st)) (st (update-marksi cur 1 st)) c st (st (update-stack (cons (car c) (stack st)) st))) nil (cdr myrev) (update-stack let let) nil nil nil)) (/defexec/find-path/fpst.lisp::graph-equivp1 (nil nil nil nil (if) nil nil) ((t) nil nil (< and) nil nil nil) ((maxnode) nil (nfix) (equal) (recursive-call) nil nil) ((i alist st) nil (1+) (neighbors gi) nil nil nil) ((i alist i st) nil (nfix) nil nil nil nil) ((i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::graph-equivp (nil nil nil nil (graph-equivp1) nil nil) ((alist st) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::mark-equivp1 (nil nil nil nil (if) nil nil) ((t) nil nil (< and) nil nil nil) ((maxnode) nil (nfix) (iff) (recursive-call) nil nil) ((i list st) nil (1+) (member equal) nil nil nil) ((i list) (1) (nfix) (marksi) nil nil nil) ((i st i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::mark-equivp (nil nil nil nil (mark-equivp1) nil nil) ((list st) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::equiv (nil nil nil nil (and) nil nil) (nil nil nil (equal graph-equivp mark-equivp) nil nil nil) ((stack g st mt st) nil (stack) nil nil nil nil) ((st) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/defexec/find-path/fpst.lisp::induct-equiv (nil nil nil nil (if) nil nil) ((st) nil (endp) (let) nil nil nil) ((c) nil ((cur (coerce-node (car c)))) nil (cond) nil nil) (nil nil (temp (equal (marksi cur st) 1) (equal cur b) t) nil nil nil nil) (nil nil (number-unmarked) (let let) nil nil nil) ((st b st stack g mt (st (update-status 0 st)) (st (update-marksi cur 1 st))) nil (cdr) (update-stack let) nil nil nil) ((c st (st (update-stack (cons (car c) (stack st)) st))) nil (myrev) (let) nil nil nil)))
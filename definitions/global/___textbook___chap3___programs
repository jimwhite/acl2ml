((/textbook/chap3/programs.lisp::fib (nil nil nil nil (if) nil nil) (nil (1) nil (or +) nil nil nil) (nil nil (zp recursive-call recursive-call) (int=) nil nil nil) ((n n) (1) (1-) (-) nil nil nil) ((n n) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::pascal (nil nil nil nil (if) nil nil) (nil (1) nil (+) (or) nil nil) (nil nil (zp zp) (equal recursive-call recursive-call) nil nil nil) ((i j i j j) nil (1- 1- 1-) nil nil nil nil) ((i j i) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::mem (nil nil nil nil (if) nil nil) ((nil) nil (endp) nil (if) nil nil) ((x t) nil nil (equal recursive-call) nil nil nil) ((e e) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::subset (nil nil nil nil (if) nil nil) ((t) nil (endp) (and) nil nil nil) ((x) nil nil (mem recursive-call) nil nil nil) ((y y) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::un (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (mem (car x) y) t) nil nil nil nil) ((y) nil nil (recursive-call cons) nil nil nil) ((y) nil (cdr car) (recursive-call) nil nil nil) ((x x y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::int (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (mem (car x) y) t) nil nil nil nil) ((nil) nil nil (cons recursive-call) nil nil nil) ((y) nil (car cdr) (recursive-call) nil nil nil) ((x y x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::diff (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (mem (car x) y) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((y) nil (cdr car) (recursive-call) nil nil nil) ((x x y) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::rev (nil nil nil nil (if) nil nil) ((nil) nil (endp) (append) nil nil nil) ((x) nil (recursive-call list) nil nil nil nil) (nil nil (cdr car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::insert (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (< n (car x)) t) nil nil nil nil) (nil nil (list) (cons cons) nil nil nil) ((n n x) nil (car) (recursive-call) nil nil nil) ((x n) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::isort (nil nil nil nil (if) nil nil) ((nil) nil (endp) (insert) nil nil nil) ((x) nil (car recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::flatten (nil nil nil nil (if) nil nil) (nil nil (atom list) (append) nil nil nil) ((x x) nil (recursive-call recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::swap-tree (nil nil nil nil (if) nil nil) ((x) nil (atom) (cons) nil nil nil) ((x) nil (recursive-call recursive-call) nil nil nil nil) (nil nil (cdr car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::depth (nil nil nil nil (if) nil nil) (nil (0) (atom) (let) nil nil nil) ((x) nil ((dcar (depth (car x))) 1+) nil nil nil nil) (nil nil (dcdr) nil (if) nil nil) ((dcdr dcar) nil (recursive-call) (<) nil nil nil) ((dcar dcdr) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::subtree (nil nil nil nil (cond) nil nil) (nil nil ((endp p) (eq (car p) (quote a)) t) nil nil nil nil) ((x) nil nil (recursive-call recursive-call) nil nil nil) (nil nil (cdr car cdr cdr) nil nil nil nil) ((p x p x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::replace-subtree (nil nil nil nil (cond) nil nil) (nil nil ((endp p) (eq (car p) (quote a)) t) nil nil nil nil) ((new) nil nil (cons cons) nil nil nil) (nil nil (cdr car) nil (recursive-call recursive-call) nil nil) ((new x x new) nil (cdr car cdr cdr) nil nil nil nil) ((p x p x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::deep-tip-1 (nil nil nil nil (cond) nil nil) (nil nil ((atom x) (< (depth (car x)) (depth (cdr x))) t) nil nil nil nil) ((x) nil (recursive-call recursive-call) nil nil nil nil) (nil nil (cdr car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::deep-tip-aux (nil nil nil nil (if) nil nil) (nil nil (atom) (mv) (mv-let) nil nil) ((x x) (0) (a1 recursive-call) nil (mv-let) nil nil) ((n1) nil (car a2 recursive-call) nil (if) nil nil) ((x n2) nil (cdr) (< mv mv) nil nil nil) ((x n1 n2 a2 a1) nil (1+ 1+) nil nil nil nil) ((n2 n1) nil nil nil nil nil nil)) (/textbook/chap3/programs.lisp::deep-tip (nil nil nil nil nil (mv-let) nil) ((a1) nil (a1 deep-tip-aux declare) nil nil nil nil) ((n1 x) nil (ignore) nil nil nil nil) ((n1) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
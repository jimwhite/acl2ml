((/coi/util/util-definitions.lisp::subterm-rec (nil nil nil nil (if) nil nil) ((nil) nil (consp) (let) nil nil nil) ((y (term (car y))) nil nil nil (or) nil nil) (nil nil nil (equal and recursive-call) nil nil nil) ((x term x) nil (consp cdr) (recursive-call) nil nil nil) ((term x y) nil (cdr) nil nil nil nil) ((term) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::subterm-p (nil nil nil (and) nil nil nil) (nil nil (consp) (subterm-rec) nil nil nil) ((y x) nil (cdr) nil nil nil nil) ((y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::good-rewrite-order (nil nil nil nil (if) nil nil) (nil nil nil (and smaller-term) (if) nil nil) ((y x) nil (symbolp symbolp quotep) (and) (or) nil nil) ((x y x) nil (quotep quotep) (<< and subterm-p) nil nil nil) ((y y y x) nil (cadr cadr not) (smaller-term) nil nil nil) ((y x x y) nil nil (subterm-p) nil nil nil) ((x y) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::fixequiv (nil nil nil (equal) nil nil nil) (nil nil (fix fix) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::fixlist (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((list) nil (fix recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::acl2-number-listp (nil nil nil (cond) nil nil nil) (nil nil ((atom l) t) nil nil nil nil) (nil nil nil (eq and) nil nil nil) ((l nil) nil (acl2-numberp recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((l l) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::fixlist-equiv (nil nil nil (equal) nil nil nil) (nil nil (fixlist fixlist) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::def::subtype-events (nil nil nil (let) nil nil nil) (nil nil ((implies-name (packn-pos (list IMPLIES- name) name)) `) nil nil nil nil) (nil nil (name-implies) nil nil nil nil) ((nil) nil (in-theory in-theory) (packn-pos defthm rule-set rule-set) nil (defun defthm) nil) ((name :rule-classes type-backchain type-definitions) nil (, , ,@ , , , :rewrite disable disable :rewrite ,) (list implies implies) nil nil nil) ((name -IMPLIES name args declare body implies-name name-implies :forward-chaining name) nil (, (, name) (, name) , :rewrite , ,) nil nil nil nil) ((body body name name-implies) nil (,@ ,@ ,) nil nil nil nil)) (/coi/util/util-definitions.lisp::subtype-strip-decls-rec (nil nil nil nil (if) nil nil) (nil nil (consp) (met mv) nil nil nil) ((list nil body) nil ((decls res)) (mv) nil nil nil) ((res) nil nil (recursive-call cons) nil nil nil) ((body decls) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::subtype-strip-decls (nil nil nil nil (if) nil nil) (nil nil (consp) (subtype-strip-decls-rec mv) nil nil nil) ((list nil nil) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::href (nil nil nil nil nil (concatenate) nil) ((~il[ x ]) nil (quote) nil nil nil nil) ((string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::docref (nil nil nil nil nil (concatenate) nil) ((~l[ x ]) nil (quote) nil nil nil nil) ((string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::n ((nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::verbatim (nil nil nil nil nil (concatenate) nil) ((~bv[] x ~ev[]) nil (quote) nil nil nil nil) ((string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::quoted (nil nil nil nil nil (concatenate) nil) ((~bq[] x ~eq[]) nil (quote) nil nil nil nil) ((string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) nil (/coi/util/util-definitions.lisp::clause-not (nil nil (`) nil nil nil nil) (nil nil nil nil (if) nil nil) (nil nil (, quote quote) nil nil nil nil) ((x nil t) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::clause-implies (nil nil (`) nil nil nil nil) (nil nil nil nil (if) nil nil) (nil nil (, , quote) nil nil nil nil) ((x y t) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::clause-cons (nil nil nil (cons) nil nil nil) ((clause) nil (clause-not) nil nil nil nil) ((a) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::ifixequiv (nil nil nil (equal) nil nil nil) (nil nil (ifix ifix) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::ith (nil nil nil nil (if) nil nil) ((nil) nil (consp) nil (if) nil nil) ((list) nil (zp car) (recursive-call) nil nil nil) ((list) nil (nfix 1- cdr) nil nil nil nil) ((n n list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::val-map (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((binding) nil (`) nil (recursive-call) nil nil) ((var) nil ((, (car binding)) 1+ cdr) nil nil nil nil) ((n binding) nil nil (val) nil nil nil) (nil nil (, ,) nil nil nil nil) ((n var) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::metlist-fn (nil nil nil nil (if) nil nil) ((nil) nil (consp) (cons) nil nil nil) ((vars) nil (`) (recursive-call) nil nil nil) (nil nil ((, (car vars)) 1+ cdr) nil nil nil nil) ((n vars) nil nil (val) nil nil nil) ((gensym::metlist) nil (,) nil nil nil nil) ((n) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::nfixequiv (nil nil nil (equal) nil nil nil) (nil nil (nfix nfix) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::member? (nil nil nil nil (if) nil nil) ((nil) nil (consp) (or) nil nil nil) ((list) nil nil (equal recursive-call) nil nil nil) ((x x) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::equiv-var-term (nil nil nil nil nil nil (and)) (nil nil (consp consp consp) (equal let) nil nil nil) ((term (term (cadr term))) nil (car quote cdr cadr) nil nil (and) nil) ((term not term term) nil (consp consp) (member? let) nil nil nil) ((equivs) nil (car cdr cddr (lhs (cadr term))) nil (or) nil nil) ((term term term nil) nil (rhs) (and and) nil nil nil) (nil nil (caddr ` `) (good-rewrite-order good-rewrite-order) nil nil nil)) (/coi/util/util-definitions.lisp::find-equiv (nil nil nil nil (if) nil nil) ((nil) nil (consp) (let) nil nil nil) ((clause (term (car clause))) nil nil (let) nil nil nil) (((nterm (equiv-var-term equivs term))) nil nil (or) nil nil nil) (nil nil nil (and recursive-call) nil nil nil) ((nterm equivs) nil (cdr) (cons) nil nil nil) ((term nterm clause) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::clause-contains (nil nil nil nil (if) nil nil) ((nil) nil (consp) (or) nil nil nil) ((clause) nil nil (equal recursive-call) nil nil nil) ((term1 term1) nil (car cdr) nil nil nil nil) ((clause clause) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::replace-1 (nil nil nil nil (if) nil nil) ((nil) nil (consp) nil (if) nil nil) ((clause) nil nil (equal cons cons) nil nil nil) ((term1 term2) nil (car cdr car) nil (recursive-call) nil nil) ((clause clause clause term1 term2) nil (cdr) nil nil nil nil) ((clause) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::rewrite-equiv-clause-processor (nil nil nil nil (if) nil nil) (nil nil (consp list) (let) nil nil nil) ((hints clause) nil ((term1 (car hints))) (let) nil nil nil) (((clause (replace-1 term1 term2 clause))) nil (term2) (list) nil nil nil) ((clause) nil (cdr list) nil nil nil nil) ((hints) nil nil (clause-implies) nil nil nil) ((term2 term1) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::slow-rewrite-equiv-hint (nil nil nil nil (if) nil nil) ((nil) nil nil (and let) nil nil nil) ((old (default (and old (` (:COMPUTED-HINT-REPLACEMENT ((slow-rewrite-equiv-hint stable-under-simplificationp nil (quote (, equivs)) clause)) :cases (t)))))) nil nil (clause-contains or) nil nil nil) ((old clause default) nil nil (and) nil nil nil) (nil nil nil (or let) nil nil nil) ((old stbl (hint (find-equiv equivs (reverse clause)))) nil nil (or) nil nil nil) ((default) nil nil (and) nil nil nil)) (/coi/util/util-definitions.lisp::slow-rewrite-equiv-hint (nil nil nil nil (if) nil nil) ((nil) nil nil (and let) nil nil nil) ((old (default (and old (` (:COMPUTED-HINT-REPLACEMENT ((slow-rewrite-equiv-hint stable-under-simplificationp nil (quote (, equivs)) clause))))))) nil nil (clause-contains or) nil nil nil) ((old clause default) nil nil (and) nil nil nil) (nil nil nil (or let) nil nil nil) ((stbl old (hint (find-equiv equivs clause))) nil nil (or) nil nil nil) ((default) nil nil (and) nil nil nil)) (/coi/util/util-definitions.lisp::wf-rule-list (nil nil (true-listp) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-set-ref (nil nil nil (or) nil nil nil) (nil nil (eqlablep) nil (and) nil nil) ((ref) nil (consp eqlablep eqlablep) nil nil nil nil) ((ref) nil (car cdr) nil nil nil nil) ((ref ref) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-set-ref-list (nil nil nil nil (if) nil nil) (nil nil (consp null) (and) nil nil nil) ((list list) nil (wf-set-ref recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::weak-version-entry (nil nil nil (and) nil nil nil) (nil nil (true-listp) (equal) nil nil nil) ((entry) (5) (len) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::versi0n (nil nil (car) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::include-rules (nil nil (cadr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::omit-rules (nil nil (caddr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::include-sets (nil nil (cadddr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::omit-sets (nil nil (car) nil nil nil nil) (nil nil (cddddr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-version-entry (nil nil nil nil nil nil nil) (nil nil (weak-version-entry eqlablep wf-rule-list wf-rule-list wf-set-ref-list wf-set-ref-list) nil nil nil nil) ((entry) nil (versi0n include-rules omit-rules include-sets omit-sets) nil nil nil nil) ((entry entry entry entry entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::version-entry (nil nil nil nil nil nil (list)) ((versi0n include-rules omit-rules include-sets omit-sets) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-version-list (nil nil nil nil (if) nil nil) (nil nil (consp null) (and) nil nil nil) ((list list) nil (wf-version-entry recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::contains-version-entry (nil nil nil nil (if) nil nil) ((nil) nil (consp) (or) nil nil nil) ((list) nil nil (equal recursive-call) nil nil nil) ((set set) nil (versi0n cdr) nil nil nil nil) ((list) nil (car) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::get-version-entry (nil nil nil nil (if) nil nil) (nil nil (consp) (new-version-entry) (if) nil nil) ((list :version set) nil (car) (equal recursive-call) nil nil nil) ((set list set) nil (versi0n cdr) nil nil nil nil) ((list) nil (car) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::set-version-entry (nil nil nil nil (if) nil nil) (nil nil (consp list) nil (if) nil nil) ((list entry) nil nil (equal cons cons) nil nil nil) ((set entry) nil (versi0n cdr car) nil (recursive-call) nil nil) ((list list set entry) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::weak-rule-set-entry (nil nil nil (and) nil nil nil) (nil nil (true-listp) (equal) nil nil nil) ((entry) (3) (len) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::set-name (nil nil (car) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::default-set-version (nil nil (cadr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::version-list (nil nil (caddr) nil nil nil nil) ((entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-rule-set-entry (nil nil nil nil nil (and) nil) (nil nil (weak-rule-set-entry eqlablep eqlablep wf-version-list) nil nil nil nil) ((entry) nil (set-name default-set-version version-list) nil nil nil nil) ((entry entry entry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::rule-set-entry (nil nil nil nil (list) nil nil) ((set-name default-set-version version-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-rule-set-list (nil nil nil nil (if) nil nil) (nil nil (consp null) (and) nil nil nil) ((list list) nil (wf-rule-set-entry recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::contains-rule-set-entry (nil nil nil nil (if) nil nil) ((nil) nil (consp) (or) nil nil nil) ((list) nil nil (equal recursive-call) nil nil nil) ((set set) nil (set-name cdr) nil nil nil nil) ((list) nil (car) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::get-rule-set-entry (nil nil nil nil (if) nil nil) (nil nil (consp) (new-rule-set-entry) (if) nil nil) ((list :set-name set) nil (car) (equal recursive-call) nil nil nil) ((set list set) nil (set-name cdr) nil nil nil nil) ((list) nil (car) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::set-rule-set-entry (nil nil nil nil (if) nil nil) (nil nil (consp list) nil (if) nil nil) ((list entry) nil nil (equal cons cons) nil nil nil) ((set entry) nil (set-name cdr car) nil (recursive-call) nil nil) ((list list set entry) nil (car cdr) nil nil nil nil) ((list list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::weak-rule-set (nil nil nil (and) nil nil nil) (nil nil (true-listp) (equal) nil nil nil) ((set) (3) (len) nil nil nil nil) ((set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::default-library (nil nil (car) nil nil nil nil) ((rule-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::default-version (nil nil (cadr) nil nil nil nil) ((rule-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::rule-set-list (nil nil (caddr) nil nil nil nil) ((rule-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::wf-rule-set (nil nil nil nil nil (and) nil) (nil nil (weak-rule-set eqlablep eqlablep wf-rule-set-list) nil nil nil nil) ((set) nil (default-library default-version rule-set-list) nil nil nil nil) ((set set set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::rule-set (nil nil nil nil (list) nil nil) ((default-library default-version rule-set-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::add-rules-to-ref-in-rule-set (nil nil nil (let*) nil nil nil) (nil nil nil nil (update-rule-set) nil nil) ((rule-set :rule-set-list rule-set-list) nil (key rule-set-entry version-list version version-entry version-entry version-list rule-set-entry rule-set-list) nil nil nil nil) (nil nil (version-list) (get-rule-set-entry get-version-entry) (if if set-version-entry update-rule-set-entry set-rule-set-entry) nil (update-version-entry)) ((ref key rule-set-list rule-set-entry version version-list version-entry :include-rules :omit-rules version version-entry version-list rule-set-entry :version-list version-list key rule-set-entry rule-set-list) nil (consp car consp cdr default-set-version) (append append) nil nil nil) ((ref ref ref ref rule-set-entry include-rules omit-rules) nil (include-rules omit-rules) nil nil nil nil) ((version-entry version-entry) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::add-sets-to-ref-in-rule-set (nil nil nil (let*) nil nil nil) (nil nil nil nil (update-rule-set) nil nil) ((rule-set :rule-set-list rule-set-list) nil (key rule-set-entry version-list version version-entry version-entry version-list rule-set-entry rule-set-list) nil nil nil nil) (nil nil (version-list) (get-rule-set-entry get-version-entry) (if if set-version-entry update-rule-set-entry set-rule-set-entry) nil (update-version-entry)) ((ref key rule-set-list rule-set-entry version version-list version-entry :include-sets :omit-sets version version-entry version-list rule-set-entry :version-list version-list key rule-set-entry rule-set-list) nil (consp car consp cdr default-set-version) (append append) nil nil nil) ((ref ref ref ref rule-set-entry include-sets omit-sets) nil (include-sets omit-sets) nil nil nil nil) ((version-entry version-entry) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::set-ref-default-version-in-rule-set (nil nil nil (let*) nil nil nil) (nil nil nil nil (update-rule-set) ((rule-set-list (rule-set-list rule-set))) nil) ((rule-set :rule-set-list rule-set-list) nil (key rule-set-entry rule-set-entry rule-set-list) nil nil nil nil) (nil nil nil (get-rule-set-entry) (if update-rule-set-entry set-rule-set-entry) nil nil) ((ref key rule-set-list rule-set-entry :default-set-version version key rule-set-entry rule-set-list) nil (consp car) nil nil nil nil) ((ref ref) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::set-default-library (nil nil nil (let*) nil nil nil) (nil nil ((key (if (consp ref) (car ref) ref))) nil nil nil (update-rule-set)) ((rule-set :default-library key :default-version version) nil (version) nil nil nil nil) (nil nil nil nil (if) nil nil) ((nil) nil (consp cdr) nil nil nil nil) ((ref ref) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::get-default-library-ref (nil nil nil (cons) nil nil nil) (nil nil (default-library default-version) nil nil nil nil) ((rule-set rule-set) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::ref-exists (nil nil nil (let*) nil nil nil) (nil nil nil (and) nil nil nil) ((rule-set-exits version-exists) nil (key rule-set-exits rule-set-entry version-list version version-exists) nil nil nil nil) (nil nil (version-list) (contains-rule-set-entry get-rule-set-entry contains-version-entry) (if if) nil nil) ((ref key rule-set-list key rule-set-list rule-set-entry nil version version-list) nil (consp car consp cdr) nil nil nil nil) ((ref ref ref ref) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::ref-set-exists (nil nil nil nil (if) nil nil) ((t) nil (consp) (let) nil nil nil) ((list (ref (car list))) nil nil (and) nil nil nil) (nil nil nil (ref-exists recursive-call) nil nil nil) ((ref rule-set rule-set) nil (cdr) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::define-new-set (nil nil nil (let*) nil nil nil) (nil nil nil nil (update-rule-set) nil nil) ((rule-set :rule-set-list rule-set-list) nil (rule-set rule-set-list key version rule-set-entry rule-set-entry version-list version-entry include-sets omit-sets version-entry version-entry version-list rule-set-entry rule-set-list) nil nil nil nil) (nil nil (rule-set-list version-list include-sets omit-sets) (get-rule-set-entry get-version-entry) (if if update-rule-set-entry set-version-entry update-rule-set-entry set-rule-set-entry) (assert assert) (update-version-entry)) ((rule-set All extended/omitted rule sets must already exist rule-set ref nil key rule-set-list rule-set-entry :default-set-version version rule-set-entry version version-list version-entry version-entry version-entry Fundamental redefinition of rule-classes is prohibited version-entry :include-sets extends :omit-sets omits version version-entry version-list rule-set-entry :version-list version-list key rule-set-entry rule-set-list) nil (quote consp car consp cdr quote) (and and) nil nil nil) ((recursive-call ref ref ref ref recursive-call) nil nil (ref-set-exists ref-set-exists or or) nil nil nil) ((extends rule-set omits rule-set) nil (null null) (equal equal) nil nil nil)) (/coi/util/util-definitions.lisp::query-ref (nil nil nil (let*) nil nil nil) (nil nil nil ((rule-set-list (rule-set-list rule-set))) (if) nil nil) ((rule-set-entry) nil (key rule-set-entry consp) (let*) nil nil nil) ((ref) nil ((version (cdr ref))) (get-rule-set-entry get-version-entry) (if) nil nil) ((ref key rule-set-list version version-list) nil (consp car version-list) nil nil nil nil) ((ref ref) nil (version-list) nil nil nil nil) ((rule-set-entry) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::alt-e/d-to-ed-list (nil nil nil nil (if) nil nil) ((nil) nil (consp) (append) nil nil nil) ((list) nil nil nil (if recursive-call) nil nil) ((e rule-set) nil (list not cdr) nil (ref-list-to-de) nil nil) ((rule-set nil e list) nil (car list) nil nil nil nil) ((list) nil nil nil (ref-list-to-disable) nil nil) ((rule-set nil) nil (car) nil nil nil nil)) (/coi/util/util-definitions.lisp::d/e-list (nil nil nil nil (if) nil nil) (nil nil (consp) (let) (if) nil nil) ((list theory) nil ((disable (caar list)) current-theory) (equal) nil (acl2::union-theories-fn) nil) ((enable t world theory :here :here) nil (enable) nil nil (acl2::set-difference-theories-fn) nil) ((disable t world) nil (cdar) nil (recursive-call) nil nil) ((list theory world) nil (cdr) nil nil nil nil) ((list) nil nil nil nil nil nil)) (/coi/util/util-definitions.lisp::update-library-version (nil nil nil (let) nil nil nil) (((hit (assoc new list))) nil nil nil (if) nil nil) (nil nil (consp) (cons) (if) nil nil) ((hit list list) nil (error) (equal cons) nil nil nil) ((old Cannot Redefine new old) nil (cdr) nil nil nil nil) ((hit) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
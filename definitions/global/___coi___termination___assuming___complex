((/coi/termination/assuming/complex.lisp::tarai-open (nil nil nil nil (if) nil nil) ((y) nil nil (<=) (if) nil nil) ((x y z x) nil nil (<=) nil nil nil) ((y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::either-not-rationalp (nil nil nil (or) nil nil nil) (nil nil (not not) nil nil nil nil) (nil nil (rationalp rationalp) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::cc (nil nil nil (let) nil nil nil) (((y (rfix y))) nil nil nil (if) nil nil) (nil nil nil (equal complex complex) nil nil nil) ((y y) (0 1) (rfix rfix) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::insert-and-count (nil nil nil nil (if) nil nil) (nil nil (acl2-numberp) (mv) (if) nil nil) ((x n list) nil nil (member mv mv) nil nil nil) ((x list n list) nil (1+) (cons) nil nil nil) ((n x list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::unique-nonnumbers (nil nil nil nil (mv-let) nil nil) (nil nil (n) nil (insert-and-count mv-let) nil nil) ((list x nil) (0) (n) nil (insert-and-count) (mv-let) nil) ((list y n list n) nil (n declare) nil (insert-and-count) nil nil) ((list z n list) nil (ignore) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::m0 (nil nil nil nil (unique-nonnumbers) nil nil) ((x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::m1 (nil nil nil nil (if) nil nil) (nil (0 1) nil (<=) nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::m2 (nil nil nil (let) nil nil nil) (nil nil nil ((rx (realpart x)) -) nil nil nil) (nil nil (ry rz) (max min) nil nil nil) ((rz rz) nil (realpart realpart) (max min) nil nil nil) ((y z rx ry rx ry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::m3 (nil nil nil (let) nil nil nil) (nil nil nil ((rx (realpart x)) -) nil nil nil) ((rx) nil (ry rz) (min) nil nil nil) ((rz) nil (realpart realpart) (min) nil nil nil) ((y z rx ry) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::m4 (nil nil nil (let) nil nil nil) (nil nil nil ((ix (imagpart x)) -) nil nil nil) ((ix) nil (iy iz) (min) nil nil nil) ((iz) nil (imagpart imagpart) (min) nil nil nil) ((y z ix iy) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::tarai-measure (nil nil nil (let) nil nil nil) (((m0 (m0 x y z))) nil nil (let) nil nil nil) (nil nil nil ((x (* d x))) nil nil (llist)) ((m0) nil (y z) nil (m1 m2 m3 m4) nil nil) ((x y z x y z x y z x y z) nil nil (* *) nil nil nil) ((d y d z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::d-check-complex (nil nil nil (and) nil nil nil) (nil nil (integerp integerp) nil nil nil nil) (nil nil nil (* *) nil nil nil) ((d d) nil (realpart imagpart) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::d-check (nil nil nil nil nil nil (and)) (nil nil (integerp) (< d-check-complex d-check-complex d-check-complex) nil nil nil) ((d d d d d) (0) (fix fix fix) nil nil nil nil) ((x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::tarai-induction (nil nil nil (cond) nil nil nil) (nil nil ((and (d-check d x y z) (> x y)) t) nil nil nil nil) ((y) nil nil nil nil (list) nil) (nil nil nil nil nil (recursive-call recursive-call recursive-call recursive-call) nil) ((d d y z d z x d x y) nil (1- 1- 1-) nil (tarai-open tarai-open tarai-open) nil nil) ((y z z x x y x y z) nil (1- 1- 1-) nil nil nil nil) ((x y z) nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::d-complex-witness (nil nil nil (*) nil nil nil) (nil nil (denominator denominator) nil nil nil nil) (nil nil (realpart imagpart) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/termination/assuming/complex.lisp::d-witness (nil nil nil nil (*) nil nil) (nil nil (d-complex-witness d-complex-witness d-complex-witness) nil nil nil nil) (nil nil (fix fix fix) nil nil nil nil) ((x y z) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
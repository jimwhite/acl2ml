((/textbook/chap4/solutions-logic-mode.lisp::from-end (nil nil nil (nth) nil nil nil) ((n) nil (reverse) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::update-alist (nil nil nil (cons) nil nil nil) ((alist) nil nil (cons) nil nil nil) ((key val) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k (nil nil nil nil (if) nil nil) (nil nil (evenp 1+) (/) nil nil nil) ((k k) (2) nil (*) nil nil nil) ((k) (3) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k (nil nil nil nil (if) nil nil) (nil nil (evenp 1+) (/) nil nil nil) ((k k) (2) nil (*) nil nil nil) ((k) (3) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::mem (nil nil nil nil (if) nil nil) ((nil) nil (endp) nil (if) nil nil) ((x t) nil nil (equal recursive-call) nil nil nil) ((e e) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::no-dupls-p (nil nil nil nil (if) nil nil) ((t) nil (endp) nil (if) nil nil) ((lst nil) nil (recursive-call) (mem) nil nil nil) (nil nil (car cdr cdr) nil nil nil nil) ((lst lst lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::get-keys (nil nil nil nil (if) nil nil) ((nil) nil (endp) (cons) nil nil nil) ((alist) nil (caar recursive-call) nil nil nil nil) ((alist) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::del (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (equal elt (car lst)) t) nil nil nil nil) ((nil) nil (cdr) (cons) nil nil nil) ((lst) nil (car) (recursive-call) nil nil nil) ((lst elt) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::perm (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) (nil nil (endp) (and) nil nil nil) ((y) nil nil (mem recursive-call) nil nil nil) ((y) nil (car cdr) (del) nil nil nil) ((x x y) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::update-alist-rec (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (equal key (caar alist)) t) nil nil nil nil) (nil nil (list) (cons cons) nil nil nil) (nil nil (cdr car) (cons cons) (recursive-call) nil nil) ((key val key val alist alist key val) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter-list (nil nil nil nil (if) nil nil) (nil nil (quote) (equal cons) nil nil nil) ((k k) (1 1) (recursive-call) nil nil nil nil) (nil nil (next-k) nil nil nil nil) ((k) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter (nil nil nil nil (if) nil nil) (nil (0) (1+) (equal) nil nil nil) ((k) (1) (recursive-call) nil nil nil nil) (nil nil (next-k) nil nil nil nil) ((k) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations (nil nil nil nil (if) nil nil) (nil (0) nil (equal max) nil nil nil) ((n) (1) (next-k-iter recursive-call) nil nil nil nil) ((n) nil (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::cast-out-nines (nil nil nil nil (if) nil nil) (nil nil (recursive-call) (or or) nil nil nil) (nil nil (zp sum-base-10-digits) (< equal equal) nil nil nil) ((n n n n n) (10 0 9) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::fact (nil nil nil nil (if) nil nil) (nil (1) (zp) (*) nil nil nil) ((n n) nil (recursive-call) nil nil nil nil) (nil nil nil (-) nil nil nil) ((n) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::fact-tailrec (nil nil nil nil (if) nil nil) ((acc) nil (zp) (recursive-call) nil nil nil) ((n) nil nil (- *) nil nil nil) ((n n acc) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::fact1 (nil nil nil (fact-tailrec) nil nil nil) ((n) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::get-keys-tail-rec (nil nil nil nil (if) nil nil) (nil nil (endp reverse) (recursive-call) nil nil nil) ((alist acc) nil (cdr) (cons) nil nil nil) ((alist acc) nil (caar) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::get-keys1 (nil nil nil (get-keys-tail-rec) nil nil nil) ((alist nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::update-alist-tail-rec (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (equal key (caar alist)) t) nil nil nil nil) (nil nil (reverse) (revappend) nil (recursive-call) nil) ((acc key val) nil (cdr) (cons cons cons) nil nil nil) ((acc alist acc) nil (cdr car) (cons cons) nil nil nil) ((key val key val alist alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::update-alist-rec1 (nil nil nil nil nil (update-alist-tail-rec) nil) ((key val alist nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter-list-tail-rec (nil nil nil nil (if) nil nil) (nil nil (reverse) (int= recursive-call) nil nil nil) ((k) (1) (next-k) (cons cons) nil nil nil) ((acc k k acc) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter-list1 (nil nil nil (next-k-iter-list-tail-rec) nil nil nil) ((k nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter-tail-rec (nil nil nil nil (if) nil nil) ((acc) nil nil (equal recursive-call) nil nil nil) ((k) (1) (next-k 1+) nil nil nil nil) ((k acc) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iter1 (nil nil nil (next-k-iter-tail-rec) nil nil nil) ((k) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations-tail-rec (nil nil nil nil (if) nil nil) ((acc) nil nil (int= recursive-call) nil nil nil) ((n) (1) (1-) (max) nil nil nil) ((n acc) nil (next-k-iter1) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations1 (nil nil nil (next-k-max-iterations-tail-rec) nil nil nil) ((n) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::split-list (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) (nil nil nil (mv) (mv-let) nil nil) ((nil nil) nil (evens recursive-call) (mv) nil nil nil) ((odds evens) nil (cdr) (cons) nil nil nil) ((x odds) nil (car) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::merge2 (nil nil nil nil nil (cond) nil) (nil nil ((endp x) (endp y) (< (car x) (car y)) t) nil nil nil nil) ((y x) nil nil (cons cons) nil nil nil) (nil nil (car car) (recursive-call recursive-call) nil nil nil) ((x y y x) nil (cdr cdr) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::mergesort (nil nil nil nil (if) nil nil) ((x) nil nil (and) (mv-let) nil nil) (nil nil (consp consp odds split-list) (merge2) nil nil nil) ((x evens x) nil (cdr recursive-call recursive-call) nil nil nil nil) ((x odds evens) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::safe-times (nil nil nil nil (if) nil nil) (nil (0) nil (and *) nil nil nil) ((x y) nil (acl2-numberp acl2-numberp) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::safe-plus (nil nil nil nil (if) nil nil) (nil (0) nil (and +) nil nil nil) ((x y) nil (acl2-numberp acl2-numberp) nil nil nil nil) ((x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::acl2-value (nil nil nil nil (cond) nil nil) (nil nil ((consp x) (or (eq x t) (eq x nil) (acl2-numberp x) (characterp x) (stringp x)) t) nil nil nil nil) ((x) nil nil (let) (cond) nil nil) (((a-val (assoc-eq x a))) nil ((eq (car x) (quote +)) (eq (car x) (quote *)) t) nil (if) nil nil) ((a-val) (0) (cdr) (safe-plus safe-times equal) nil nil nil) ((a-val) nil nil (recursive-call recursive-call recursive-call recursive-call recursive-call recursive-call) nil nil nil) ((a a a a a a) nil (cadr caddr cadr caddr cadr caddr) nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-ar (nil nil nil (let) nil nil nil) (((next-k-try (and (< k bound) (aref1 (quote next-k-array) ar k)))) nil nil nil (if) nil nil) ((next-k-try) nil nil (mv let) nil nil nil) ((next-k-try ar (next-k (next-k k))) nil nil (mv) nil nil nil) ((next-k) nil nil nil (if) nil nil) ((ar) nil nil (<) nil (aset1) nil) ((k bound ar k next-k) nil (quote) nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iterations-ar-rec (nil nil nil nil (if) nil nil) (nil nil nil (int= mv) (mv-let) nil nil) ((k acc ar) (1) (next-k) nil (next-k-ar) (recursive-call) nil) ((ar k ar bound next-k ar bound) nil (1+) nil nil nil nil) ((acc) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-array (nil nil nil (compress1) nil nil nil) (nil nil (quote `) nil nil nil nil) ((recursive-call (:header :dimensions ((, size)) :maximum-length (, (* size 2)) :default nil :name next-k-array)) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-iterations-ar (nil nil nil nil nil (next-k-iterations-ar-rec) nil) ((k k) (0) (next-k-array) nil nil nil nil) ((k) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations-ar-rec (nil nil nil nil (if) nil nil) ((max) nil nil (int=) (mv-let) nil nil) ((n) (1) (iterations) nil nil (next-k-iterations-ar-rec recursive-call) nil) ((ar n ar bound ar bound) (0) (1-) (max) nil nil nil) ((n max iterations) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations-ar (nil nil nil nil nil (next-k-max-iterations-ar-rec) nil) ((n n) (0) (next-k-array) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::fill-in (nil nil nil (cond) nil nil nil) (nil nil ((< i *len*) t) nil nil nil nil) (nil nil nil nil (if seq) nil nil) ((st) nil nil (= update-prev recursive-call update-prev) nil (seq) nil) ((st st st st) (-1) (next-k 1+) (ansi recursive-call update-prev ansi) (update-ansi) nil nil) ((i st st i st st i st i) nil (next-k 1+ 1+ prev) nil nil nil nil) ((i st) nil (prev prev) nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::fill-all-in (nil nil nil (cond) nil nil nil) (nil nil ((> cnt len) t) nil nil nil nil) ((st) nil nil nil (seq) nil nil) ((st) nil nil (fill-in) (recursive-call) nil nil) ((cnt st len st) nil (1+) nil nil nil nil) ((cnt) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::max-st (nil nil nil (cond) nil nil nil) (nil nil ((> cnt len) t) nil nil nil nil) ((m) nil nil nil (if) nil nil) (nil nil nil (>) nil (recursive-call recursive-call) nil) ((m len st m len st) nil (1+ 1+) (ansi ansi) nil nil nil) ((cnt st cnt cnt st cnt) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations-stobj-aux (nil nil nil nil nil nil (seq)) ((st) nil nil (update-prev) (update-ansi update-ansi fill-all-in) nil nil) ((st st len st st) (0 0 1 0 2) nil nil nil (max-st) nil) ((len st) (2 0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/textbook/chap4/solutions-logic-mode.lisp::next-k-max-iterations-stobj (nil nil nil (let) nil nil nil) (((st (next-k-max-iterations-stobj-aux len st))) nil nil (mv) nil nil nil) ((st) nil (prev) nil nil nil nil) ((st) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
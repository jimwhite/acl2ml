((/arithmetic-3/bind-free/simplify.lisp::insert-0 (nil nil (declare) nil nil nil nil) (nil nil (ignore) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::addend-val (nil nil nil nil nil nil (cond)) (nil nil ((variablep addend) (fquotep addend) (eq (ffn-symb addend) (quote UNARY--)) (and (eq (ffn-symb addend) (quote BINARY-*)) (rational-constant-p (arg1 addend))) t) nil nil nil nil) (nil (1 1 1) (recursive-call unquote) nil nil nil nil) (nil nil (arg1 arg1) nil nil nil nil) ((addend addend) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factors (nil nil nil nil (if) nil nil) (nil nil (list) (eq cons) nil nil nil) ((product) nil (fn-symb quote recursive-call) (fargn) nil nil nil) ((product BINARY-* product) (1) nil (fargn) nil nil nil) ((product) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::make-product (nil nil nil nil nil (cond) nil) (nil nil ((null factors) (null (cdr factors)) (null (cddr factors)) t) nil nil nil nil) (nil nil (quote car) nil (list list) nil nil) ((factors) nil (quote quote car cadr quote car recursive-call) nil nil nil nil) ((BINARY-* factors factors BINARY-* factors) (1) (cdr) nil nil nil nil) ((factors) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::remainder-bbb (nil nil nil nil (if) nil nil) (nil nil (make-product) (eq let) nil nil nil) (((first (make-product (set-difference-equal (factors (fargn sum 1)) common-factors)))) nil (fn-symb quote) (set-difference-equal) (list) nil nil) ((sum BINARY-+ first common-factors) nil (quote factors) (recursive-call) nil nil nil) ((BINARY-+ common-factors sum) nil nil (fargn) nil nil nil) ((sum) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::common-factors-aaa (nil nil nil nil (cond) nil nil) (nil nil ((null factors) (eq (fn-symb sum) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (recursive-call intersection-equal) nil nil nil) ((factors) nil (factors) (intersection-equal fargn) nil nil nil) ((factors sum sum) (2) (factors) nil nil nil nil) (nil nil nil (fargn) nil nil nil) ((sum) (1) nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::simplify-terms-such-as-a+ab-rel-0-fn (nil nil nil nil (if) nil nil) ((nil) nil nil (eq let) nil nil nil) (((common-factors (common-factors-aaa (factors (fargn sum 1)) (fargn sum 2)))) nil (fn-symb quote) nil (if) nil nil) ((sum BINARY-+ common-factors nil) nil nil (let) nil nil nil) (nil nil ((common (make-product common-factors))) (list) nil nil nil) (nil nil (remainder) (cons cons) nil nil nil) ((common remainder) nil (quote quote) (remainder-bbb) nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-val-gather-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (unquote) (+) (if) nil nil) ((exponent) (1) (rational-constant-p unquote recursive-call recursive-call) nil nil nil nil) (nil nil (arg1 arg1 arg1 arg2) nil nil nil nil) ((exponent exponent exponent exponent) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-val-gather-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (fquotep factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil (1 1 1) (recursive-call recursive-call factor-val-gather-exponents1) nil nil nil nil) (nil nil (arg1 arg1 arg2) nil nil nil nil) ((factor factor factor) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-val-scatter-exponents1 (nil nil nil nil nil nil (cond)) (nil nil ((variablep exponent) (rational-constant-p exponent) (eq (ffn-symb exponent) (quote BINARY-*)) (eq (ffn-symb exponent) (quote BINARY-+)) t) nil nil nil nil) (nil (1 1) (unquote) (+) (if) nil nil) ((exponent) (1) (rational-constant-p unquote recursive-call recursive-call) nil nil nil nil) (nil nil (arg1 arg1 arg1 arg2) nil nil nil nil) ((exponent exponent exponent exponent) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-val-scatter-exponents (nil nil nil nil nil nil nil) (nil nil ((variablep factor) (fquotep factor) (eq (ffn-symb factor) (quote UNARY-/)) (eq (ffn-symb factor) (quote UNARY--)) (eq (ffn-symb factor) (quote EXPT)) t) nil nil nil nil) (nil (1 1 1) (recursive-call recursive-call factor-val-scatter-exponents1) nil nil nil nil) (nil nil (arg1 arg1 arg2) nil nil nil nil) ((factor factor factor) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::addend-info-entry (nil nil nil nil (list) nil nil) ((x) nil (addend-pattern addend-val) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::info-entry-p (nil nil nil (and) nil nil nil) (nil nil (true-listp rationalp) nil nil nil nil) ((x) nil (cadr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::addend-info-list (nil nil nil nil (if) nil nil) (nil nil (list) (eq cons) nil nil nil) (nil nil (fn-symb quote addend-info-entry recursive-call addend-info-entry) nil nil nil nil) ((x BINARY-+ x) nil (arg1 arg2) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::info-list-p (nil nil nil nil (if) nil nil) (nil nil (consp) (and eq) nil nil nil) ((x x nil) nil (info-entry-p recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::assoc-addend (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-addend-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::first-match-in-addend-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-addend (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil (recursive-call) (if) nil nil) ((info-list2) nil (caddr caddr cdr) (<=) nil nil nil) ((temp info-list1) nil (cadr cadr car) nil nil nil nil) ((temp info-list1) nil (car) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-matching-addends (nil nil nil (let*) nil nil nil) (nil nil nil ((info-list1 (addend-info-list lhs))) (if) nil nil) ((match nil) nil (info-list2 match list) nil nil nil nil) (nil nil (addend-info-list) (first-match-in-addend-info-lists cons) nil nil nil) ((rhs info-list1 info-list2 match) nil (quote) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::negative-addend-p (nil nil nil nil (or) nil nil) (nil nil nil (and) (and and) nil nil) (nil nil (quotep rationalp rational-constant-p) (< eq or eq <) nil nil nil) ((x) (0 0) (unquote unquote fn-symb quote variablep not fn-symb quote arg1 unquote) nil nil nil nil) ((x x x UNARY-- x BINARY-* x) nil (arg1 arg1) (equal) nil nil nil) ((x x) nil (ffn-symb quote) nil nil nil nil) ((UNARY--) nil (arg1) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-negative-addend1 (nil nil nil nil nil nil (cond)) (nil nil ((not (eq (fn-symb x) (quote BINARY-+))) (negative-addend-p (arg1 x)) (eq (fn-symb (arg2 x)) (quote BINARY-+)) (negative-addend-p (arg2 x)) t) nil nil nil nil) ((nil) nil (arg1 recursive-call arg2) nil (if) nil nil) ((x nil x x) nil (negative-addend-p arg2) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-negative-addend (nil nil nil (let) nil nil nil) (((temp1 (find-negative-addend1 lhs))) nil nil nil (if) nil nil) ((temp1) nil (list) (let) nil nil nil) (((temp2 (find-negative-addend1 rhs))) nil nil (cons) (if) nil nil) ((temp1 temp2 nil) nil (quote list) nil nil nil nil) ((x) nil nil (cons) nil nil nil) ((temp2) nil (quote) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-gather-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-gather-exponents factor-val-gather-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::assoc-factor-gather-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-gather-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-gather-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (<= (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-gather-exponents-info-list (nil nil nil nil (cond) nil nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote BINARY-*)) t) nil nil nil nil) (nil nil (list) (let cons) nil nil nil) (((temp (factor-gather-exponents-info-list (arg2 x)))) nil (factor-gather-exponents-info-entry recursive-call factor-gather-exponents-info-entry) nil (if) nil nil) ((temp nil x) nil (arg1 arg2) (factor-gather-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::first-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil (recursive-call) (if) nil nil) ((info-list2) nil (caddr caddr cdr) (<=) nil nil nil) ((temp info-list1) nil (cadr cadr car) nil nil nil nil) ((temp info-list1) nil (car) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) (if) nil nil) ((match nil) nil (info-list2 match list) nil nil nil nil) (nil nil nil (cons) (if if) nil nil) ((info-list1 nil info-list2 nil match) nil (factor-gather-exponents-info-list quote) (first-match-in-factor-gather-exponents-info-lists) nil nil nil) ((rhs info-list1 info-list2 x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::first-rational-match-in-factor-gather-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-gather-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (if) (recursive-call) nil) ((temp info-list2 mfc state) nil (caddr caddr cdr) (<=) (proveably-rational) nil nil) ((mfc state temp info-list1) nil (caddr cadr cadr car) nil nil nil nil) ((temp temp info-list1) nil (car) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-rational-matching-factors-gather-exponents (nil nil nil (let*) nil nil nil) (nil nil nil ((info-list1 (factor-gather-exponents-info-list lhs))) (if) nil nil) ((match nil) nil (info-list2 match list) nil nil nil nil) (nil nil nil (cons) (if if) nil nil) ((info-list1 nil info-list2 nil match) nil (factor-gather-exponents-info-list quote) nil nil (first-rational-match-in-factor-gather-exponents-info-lists) nil) ((rhs info-list1 info-list2 mfc state x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-scatter-exponents-info-entry (nil nil nil nil (list) nil nil) ((x) nil (factor-pattern-scatter-exponents factor-val-scatter-exponents) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::assoc-factor-scatter-exponents (nil nil nil nil (cond) nil nil) (nil nil ((endp info-list) (matching-factor-scatter-exponents-patterns-p x (caar info-list)) t) nil nil nil nil) ((nil) nil (car) (recursive-call) nil nil nil) ((info-list x) nil (cdr) nil nil nil nil) ((info-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-scatter-exponents-intersect-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (caar info-list1) info-list2))) nil nil nil (cond) nil nil) (nil nil ((not temp) (<= (cadr temp) (cadr (car info-list1))) t) nil nil nil nil) (nil nil nil (recursive-call cons cons) nil nil nil) ((info-list2 temp) nil (cdr car) (recursive-call recursive-call) nil nil nil) ((info-list1 info-list2 info-list1 info-list2) nil (cdr cdr) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::factor-scatter-exponents-info-list (nil nil nil nil (cond) nil nil) (nil nil ((eq (fn-symb x) (quote BINARY-+)) (eq (fn-symb x) (quote BINARY-*)) t) nil nil nil nil) (nil nil (list) (let cons) nil nil nil) (((temp (factor-scatter-exponents-info-list (arg2 x)))) nil (factor-scatter-exponents-info-entry recursive-call factor-scatter-exponents-info-entry) nil (if) nil nil) ((temp nil x) nil (arg1 arg2) (factor-scatter-exponents-intersect-info-lists) nil nil nil) ((temp x x) nil (recursive-call) nil nil nil nil) (nil nil (arg1) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::first-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil (recursive-call) (if) nil nil) ((info-list2) nil (caddr caddr cdr) (<=) nil nil nil) ((temp info-list1) nil (cadr cadr car) nil nil nil nil) ((temp info-list1) nil (car) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) (if) nil nil) ((match nil) nil (info-list2 match list) nil nil nil nil) (nil nil nil (cons) (if if) nil nil) ((info-list1 nil info-list2 nil match) nil (factor-scatter-exponents-info-list quote) (first-match-in-factor-scatter-exponents-info-lists) nil nil nil) ((rhs info-list1 info-list2 x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::first-rational-match-in-factor-scatter-exponents-info-lists (nil nil nil nil (if) nil nil) ((nil) nil (endp) (let) nil nil nil) ((info-list1 (temp (assoc-factor-scatter-exponents (car (car info-list1)) info-list2))) nil nil nil (if) nil nil) (nil nil nil (and) (if) (recursive-call) nil) ((temp info-list2 mfc state) nil (caddr caddr cdr) (<=) (proveably-rational) nil nil) ((mfc state temp info-list1) nil (caddr cadr cadr car) nil nil nil nil) ((temp temp info-list1) nil (car) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-rational-matching-factors-scatter-exponents (nil nil nil (let*) nil nil nil) (nil nil nil ((info-list1 (factor-scatter-exponents-info-list lhs))) (if) nil nil) ((match nil) nil (info-list2 match list) nil nil nil nil) (nil nil nil (cons) (if if) nil nil) ((info-list1 nil info-list2 nil match) nil (factor-scatter-exponents-info-list quote) nil nil (first-rational-match-in-factor-scatter-exponents-info-lists) nil) ((rhs info-list1 info-list2 mfc state x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-negative-factor-scatter-exponents2 (nil nil nil nil nil nil (cond)) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil x nil) nil nil (let) nil nil (cond)) (((temp (find-negative-factor-scatter-exponents2 (arg1 x)))) nil ((eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) nil (if) nil nil) ((x x x x nil temp temp) nil (recursive-call) nil nil nil nil) (nil nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-negative-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil (find-negative-factor-scatter-exponents2) (let) nil nil nil) (((temp (find-negative-factor-scatter-exponents2 (arg1 x))) x) nil nil nil (if) nil nil) ((temp temp) nil (recursive-call) nil nil nil nil) (nil nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-negative-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-negative-factor-scatter-exponents1 lhs))) nil nil nil (if) nil nil) ((temp1) nil (list) (let) nil nil nil) (((temp2 (find-negative-factor-scatter-exponents1 rhs))) nil nil (cons) (if) nil nil) ((temp1 temp2 nil) nil (quote list) nil nil nil nil) ((x) nil nil (cons) nil nil nil) ((temp2) nil (quote) nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-rational-negative-factor-scatter-exponents2 (nil nil nil nil nil nil (cond)) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote UNARY-/)) (eq (ffn-symb x) (quote EXPT)) (eq (ffn-symb x) (quote BINARY-*)) t) nil nil nil nil) ((nil nil) nil nil (let) (if) nil (cond)) ((x nil (temp (find-rational-negative-factor-scatter-exponents2 (arg1 x) mfc state))) nil ((eq (fn-symb (arg1 x)) (quote UNARY-/)) (and (quotep (arg1 x)) (not (integerp (cadr (arg1 x)))) (rationalp (cadr (arg1 x))) (eql (numerator (cadr (arg1 x))) 1)) (eq (fn-symb (arg2 x)) (quote UNARY--)) (and (eq (fn-symb (arg2 x)) (quote BINARY-*)) (rational-constant-p (arg1 (arg2 x))) (< (unquote (arg1 (arg2 x))) 0)) t) nil (proveably-rational if) nil nil) ((x mfc state nil temp temp) nil nil nil (if if if if recursive-call) nil nil) ((x nil x nil x nil x nil mfc state) nil (arg2) nil (proveably-rational proveably-rational proveably-rational proveably-rational) nil nil) ((x mfc state x mfc state x mfc state x mfc state x) nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-rational-negative-factor-scatter-exponents1 (nil nil nil nil (cond) nil nil) (nil nil ((or (variablep x) (fquotep x)) (eq (ffn-symb x) (quote BINARY-+)) t) nil nil nil nil) ((nil) nil nil (let) (find-rational-negative-factor-scatter-exponents2) nil nil) (((temp (find-rational-negative-factor-scatter-exponents2 (arg1 x) mfc state)) x mfc state) nil nil nil (if) nil nil) ((temp temp) nil nil nil (recursive-call) nil nil) ((mfc state) nil (arg2) nil nil nil nil) ((x) nil nil nil nil nil nil)) (/arithmetic-3/bind-free/simplify.lisp::find-rational-negative-factor-scatter-exponents (nil nil nil (let) nil nil nil) (((temp1 (find-rational-negative-factor-scatter-exponents1 lhs mfc state))) nil nil nil (if) nil nil) ((temp1) nil (list) (let) nil nil nil) (((temp2 (find-rational-negative-factor-scatter-exponents1 rhs mfc state))) nil nil (cons) (if) nil nil) ((temp1 temp2 nil) nil (quote list) nil nil nil nil) ((x) nil nil (cons) nil nil nil) ((temp2) nil (quote) nil nil nil nil)))
((/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::theta_alt (nil nil nil nil (+) nil nil) (nil nil nil (bitn_alt bitn_alt *) nil nil nil) ((y y) (-2) (1-) (* bitn_alt) nil nil nil) ((i y) (2) (1+) (*) nil nil nil) ((i) (2) nil (*) nil nil nil) ((i) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-theta_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt theta_alt) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::bmux4_alt (nil nil nil nil nil nil nil) ((zeta) nil (1 -1 2 -2 0) nil nil nil nil) ((x) (0) nil (*) (bits_alt bits_alt) nil nil) ((x) (0 2 0) (lognot 1- lognot 1-) nil nil nil nil) ((x n n) nil nil (*) nil nil nil) ((x) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::neg (nil nil nil nil (if) nil nil) (nil (1 0) nil (<) nil nil nil) ((x) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp4_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn_alt bitn_alt *) (bmux4_alt bmux4_alt) nil nil) ((x n x n) (0 0 2) (lognot zeta lognot zeta zeta 1-) nil nil nil nil) ((i i i) nil (neg neg 1-) nil nil nil nil) ((i) nil (zeta zeta) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-zeta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (*) nil nil nil) (nil nil (zeta 1-) (expt) nil nil nil) ((m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp4_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil (pp4_alt recursive-call) nil nil) ((x n x n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp4_alt-theta_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn_alt bitn_alt *) (bmux4_alt bmux4_alt) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) (theta_alt theta_alt theta_alt) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (theta_alt theta_alt) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp4_alt-theta_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp4_alt-theta_alt recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::m-mu-chi (nil nil nil (cond) nil nil nil) (nil nil ((equal mode (quote mu)) (equal mode (quote chi))) nil nil nil nil) (nil nil nil nil (if if) nil nil) (nil (1 0) (zp zp) (cons cons) nil nil nil) ((i i) (1 0) nil (cons cons) nil nil nil) ((i i) (1 1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::phi_alt (nil nil nil nil (if) nil nil) (nil (-1) nil (=) (bits_alt) nil nil) (nil (3 1 0) nil (mu_alt) (bits_alt) nil nil) ((i y) (1 0) nil (mu_alt) nil nil nil) ((i y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-odd-powers-of-2 (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (expt) nil nil nil) (nil (2) (1- 1-) nil nil nil nil) ((m) nil nil (*) nil nil nil) ((m) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-phi_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt phi_alt) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp4_alt-phi_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn_alt bitn_alt *) (bmux4_alt bmux4_alt) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) (phi_alt phi_alt phi_alt) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (phi_alt phi_alt) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp4_alt-phi_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp4_alt-phi_alt recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::gamma_alt (nil nil nil nil (if) nil nil) (nil nil (zp) (bitn_alt logior) nil nil nil) ((i c) (0) nil (bitn_alt bitn_alt) nil nil nil) ((a b) nil nil (+ +) nil nil nil) (nil (-1 -1) nil (* *) nil nil nil) ((i i) (2 2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::delta_alt (nil nil nil nil (if) nil nil) (nil nil (zp) (bitn_alt logand) nil nil nil) ((i d) (0) (lognot) (logior) nil nil nil) (nil nil nil (logand logior logxor) nil nil nil) (nil nil nil (bitn_alt bitn_alt logand logand bitn_alt bitn_alt) nil nil nil) ((a b a b) nil (1- 1-) (+ + bitn_alt bitn_alt) nil (gamma_alt gamma_alt) nil) ((a a b c b a b c) (-2 -2) (1- 1-) (* * + + * *) nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::psi_alt (nil nil nil nil (if) nil nil) (nil (0) (not) nil nil nil (+)) (nil nil (natp) (*) (bits_alt bits_alt) (gamma_alt) (delta_alt)) ((i a b i a b c i a b c d) (-4) (1+ 1+) (* * +) nil nil nil) ((i i) (2 2) nil (* *) nil (gamma_alt) (delta_alt)) ((i i a b c a b c d) (2 2) (1+ 1+) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-psi_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (*) nil nil (recursive-call)) ((a b c d) nil (1-) (expt) nil nil (psi_alt)) ((a b c d m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp4_alt-psi_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn_alt bitn_alt *) (bmux4_alt bmux4_alt) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) nil nil nil (psi_alt psi_alt psi_alt)) ((i a b c d i a b c d a b c d i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil nil nil nil (psi_alt psi_alt)) ((i a b c d i a b c d) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp4_alt-psi_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil nil nil) ((x a b c d n x a b c d n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::eta_alt (nil nil nil nil nil (+) nil) (nil nil nil (bitn_alt bitn_alt * *) nil nil nil) ((y y) (2 -4) (1-) (* bitn_alt bitn_alt) nil nil nil) ((i y y) (3) (1+) (* +) nil nil nil) ((i) (3 2) nil (* *) nil nil nil) ((i i) (3 3) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-eta_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt eta_alt) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (3) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::bmux8_alt (nil nil nil nil nil nil nil) ((zeta_alt) nil (1 -1 2 -2 3 -3 4 -4 0) nil nil nil nil) ((x) (0) nil (* * *) (bits_alt bits_alt bits_alt bits_alt) nil nil) ((x x x) (0 2 0 3 0 4 0) (lognot 1- lognot 1- lognot 1- lognot 1-) nil nil nil nil) ((x n n n n) nil nil (* * *) nil nil nil) ((x x x) (2 3 4) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp8_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (3 2 1 3 2 1 0 2 1 0) (neg) (bitn_alt bitn_alt *) (bmux8_alt bmux8_alt) nil nil) ((x n x n) (0 0 3) (lognot xi lognot xi xi 1-) nil nil nil nil) ((i i i) nil (neg neg 1-) nil nil nil nil) ((i) nil (xi xi) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-xi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (*) nil nil nil) (nil nil (xi 1-) (expt) nil nil nil) ((m) (2) (1-) (*) nil nil nil) ((m) (3) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp8_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil (pp8_alt recursive-call) nil nil) ((x n x n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::pp8_alt-eta_alt (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (3 2 1 3 2 1 0 2 1 0) (neg) (bitn_alt bitn_alt *) (bmux8_alt bmux8_alt) nil nil) ((x n x n) (0 0 3) (lognot lognot 1-) (eta_alt eta_alt eta_alt) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (eta_alt eta_alt) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-new-proofs.lisp::sum-pp8_alt-eta_alt (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp8_alt-eta_alt recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
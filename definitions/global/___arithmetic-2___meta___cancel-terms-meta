((/arithmetic-2/meta/cancel-terms-meta.lisp::info-list-entry (nil nil nil (cons) nil nil nil) (nil nil nil (my-apply-1 cons) nil nil nil) ((pattern-fun piece piece) nil (rfix) nil nil nil nil) (nil nil nil (my-apply-1) nil nil nil) ((val-fun piece) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::info-list-intersect (nil nil nil nil (if) nil nil) ((nil) nil (atom) (let) nil nil nil) ((info-list1 (temp (assoc-pattern-matchp (pattern (first info-list1)) info-list2))) nil nil nil (if) nil nil) ((temp) nil nil (cons) (recursive-call) nil nil) ((info-list2 bin-op) nil (rest) nil (if recursive-call) nil nil) ((temp info-list2 bin-op info-list1) nil (first rest) nil (use-firstp) nil nil) ((bin-op info-list1 info-list1) nil (val val) nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::info-list1 (nil nil nil nil (if) nil nil) (nil nil (list) (and cons) nil nil nil) (nil nil (consp) (eq) (info-list-entry info-list-entry) (recursive-call) nil) ((term bin-op pattern-fun val-fun pattern-fun val-fun bin-op term pattern-fun val-fun) nil (ffn-symb arg1 arg2) nil nil nil nil) ((term term term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::info-list (nil nil nil (cond) nil nil nil) (nil nil ((and (eq bin-op (quote BINARY-*)) (eq (fn-symb term) (quote BINARY-+))) t) nil nil nil nil) (nil nil nil (let) nil (info-list1) nil) (((temp (info-list (arg2 term) pattern-fun val-fun bin-op)) term pattern-fun val-fun bin-op) nil nil nil (if) nil nil) ((temp nil) nil nil nil (info-list-intersect) nil nil) ((temp bin-op) nil nil nil nil (info-list1) nil) ((pattern-fun val-fun bin-op) nil (arg1) nil nil nil nil)) nil (/arithmetic-2/meta/cancel-terms-meta.lisp::my-apply-2 (nil nil nil nil (case) nil nil) ((fun) nil (proveably-rational true) nil nil nil nil) (nil nil nil nil (proveably-rational true) nil nil) ((arg mfc state arg mfc state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::cancelling-piece (nil nil nil nil (if) nil nil) (nil nil nil (eq) (if cond) nil nil) ((bin-op) nil (quote ` ` (eq (fn-symb piece) (quote UNARY--)) (and (eq (fn-symb piece) (quote BINARY-*)) (quotep (fargn piece 1))) t) (eq) nil nil nil) ((BINARY-*) nil (fn-symb quote UNARY-/ ` `) (EXPT fargn) nil nil nil) ((piece EXPT piece) (1) (UNARY-/ , , UNARY--) (BINARY-*) nil nil nil) ((piece) nil (, , , ,) (fargn) nil nil nil) ((piece piece) (2) (kwote) (fargn fargn) nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::strip-cancelling-piece (nil nil nil nil (if) nil nil) ((cancelling-piece) nil (recursive-call) (member-eq) nil nil nil) (nil nil (fn-symb quote arg1) nil nil nil nil) ((cancelling-piece cancelling-piece) nil nil (UNARY--) nil nil nil) ((UNARY-/ EXPT) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::first-match (nil nil nil nil (if) nil nil) (nil nil (endp) (let*) (mv) nil nil) ((info-list1 nil nil nil) nil nil nil (if) ((temp (assoc-pattern-matchp (pattern (first info-list1)) info-list2))) nil) (nil nil (use-first piece pattern cancelling-piece) (and) (mv) nil nil) ((temp t pattern cancelling-piece info-list2 criterion bin-op mfc state) nil (rest) nil (if if if if) (my-apply-2) nil) ((temp nil temp nil temp nil temp nil criterion cancelling-piece mfc state info-list1) nil nil (cancelling-piece) (use-firstp if if) nil nil) ((bin-op use-first use-first piece bin-op) nil (val val piece piece pattern pattern) nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::first-negative2 (nil nil nil (let) nil nil nil) (((val (rfix (my-apply-1 val-fun term)))) nil nil nil (if) nil nil) (nil nil nil (and) (mv mv) nil nil) ((t nil nil nil) nil nil (< my-apply-1 cancelling-piece) nil (my-apply-2) nil) ((val criterion term mfc state pattern-fun term term bin-op) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::first-negative1 (nil nil nil nil (if) nil nil) (nil nil nil (and) (mv-let) nil nil) ((term pattern-fun val-fun criterion bin-op mfc state) nil (consp) (eq flag) (if) nil nil) ((term bin-op to-match cancelling-piece pattern-fun val-fun criterion bin-op mfc state flag) nil (fn-symb arg1) nil (mv) nil nil) ((term term t to-match cancelling-piece pattern-fun val-fun criterion bin-op mfc state) nil (arg2) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::first-negative (nil nil nil nil (if) nil nil) (nil nil nil (and) (mv-let) nil nil) ((term pattern-fun val-fun criterion bin-op mfc state) nil nil (eq eq flag) (if) nil nil) ((bin-op to-match cancelling-piece pattern-fun val-fun criterion bin-op mfc state flag) nil (quote fn-symb quote arg1) nil (mv) nil nil) ((BINARY-* term BINARY-+ term flag to-match cancelling-piece pattern-fun val-fun criterion bin-op mfc state) nil (arg2) nil nil nil nil) ((term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::insert-zero (nil nil nil (cond) nil nil nil) (nil nil ((or (null term) (variablep term) (fquotep term)) t) nil nil nil nil) (nil nil nil nil (if) nil (case)) ((term) nil (quote ffn-symb (BINARY-+ BINARY-*) (UNARY-- UNARY-/) EXPT t) (equal) nil nil nil) ((sub-term term term) nil (quote) (list) (if list if) nil nil) ((term) (0) (quote ffn-symb ffn-symb arg2 quote) (equal recursive-call recursive-call equal) (list) nil nil) ((sub-term term term sub-term term sub-term term sub-term term) nil (quote ffn-symb arg1 arg1 quote) (recursive-call recursive-call) nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::new-term-nf (nil nil nil nil nil (mv-let) nil) ((new-term) nil (flag declare) nil nil nil (new-term)) ((new-term term new-piece pattern pattern-fun bin-op) nil (ignore) nil nil nil nil) ((flag) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::good-arg (nil nil nil (member-eq) nil nil nil) (nil nil (fn-symb quote) nil nil nil nil) ((arg) nil nil nil nil (BINARY-+) nil) ((BINARY-* EXPT UNARY-- UNARY-/) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::good-args-* (nil nil nil nil nil (cond) nil) (nil nil ((or (null arg1) (null arg2)) (member-eq (fn-symb arg1) (quote (EXPT UNARY-- UNARY-/))) (member-eq (fn-symb arg2) (quote (EXPT UNARY-- UNARY-/))) t) nil nil nil nil) ((nil t) nil (not not) nil nil nil nil) (nil nil nil (equal equal) nil nil nil) ((arg2 arg1) nil (quote quote) nil nil nil nil) (nil nil (quote quote) nil nil nil nil) (nil (0 0) nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::good-args-+ (nil nil nil (and) nil nil nil) (nil nil (not not) nil nil nil nil) (nil nil nil (equal equal) nil nil nil) ((arg1 arg2) nil (quote quote) nil nil nil nil) (nil nil (quote quote) nil nil nil nil) (nil (0 0) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/arithmetic-2/meta/cancel-terms-meta.lisp::good-args (nil nil nil (and) nil nil nil) (nil nil nil (or) (if) nil nil) (nil nil (good-arg good-arg) (eq good-args-* good-args-+) nil nil nil) ((arg1 arg2 bin-op arg1 arg2 arg1 arg2) nil (quote) nil nil nil nil) ((BINARY-*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
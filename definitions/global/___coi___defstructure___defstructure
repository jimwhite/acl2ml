((/coi/defstructure/defstructure.lisp::acons$ (nil nil nil (cons) nil nil nil) ((value) nil nil (cons) nil nil nil) ((key datum) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::ncars (nil nil nil nil (cond) nil nil) (nil nil ((= n 0) (null l) t) nil nil nil nil) ((nil nil) nil nil (cons) nil nil nil) (nil nil (car) (recursive-call) nil nil nil) ((l) nil (cdr) (-) nil nil nil) ((n l) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::fold (nil nil nil nil (cond) nil nil) (nil nil ((null args) (null (cdr args)) t) nil nil nil nil) ((nil) nil (car) (cons) nil nil nil) ((args) nil (recursive-call recursive-call) nil nil nil nil) (nil nil nil (ncars nthcdr) nil nil nil) ((args args) nil nil (truncate truncate) nil nil nil) (nil (2 2) (length length) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::flatten (nil nil nil (cond) nil nil nil) (nil nil ((atom args) t) nil nil nil nil) (nil nil nil (cond append) nil nil nil) (nil nil ((null args) t recursive-call recursive-call) nil nil nil nil) ((nil) nil (list car cdr) nil nil nil nil) ((args args args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::dotify (nil nil nil nil nil (cond) nil) (nil nil ((atom l) (atom (cdr l)) (atom (cdr (cdr l))) t) nil nil nil nil) ((l l) nil nil (cond cons) nil nil nil) (nil nil ((null (cdr (cdr l))) t car recursive-call) nil nil nil nil) ((l l) nil (cdr) (cons) nil nil nil) ((l) nil (car cadr) nil nil nil nil) ((l l) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::duplicates-equal (nil nil nil nil (cond) nil nil) (nil nil ((atom lst) (member-equal (car lst) (cdr lst)) t) nil nil nil nil) ((nil) nil (recursive-call) (add-to-set-equal) nil nil nil) (nil nil (car recursive-call cdr) nil nil nil nil) ((lst lst) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::keywordify (nil nil nil (intern-in-package-of-symbol) nil nil nil) ((:keyword) nil (string) nil nil nil nil) ((string-designator) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::keywordify-tree (nil nil nil (cond) nil nil nil) (nil nil ((atom tree) t) nil nil nil nil) (nil nil nil (cons) (cond) nil nil) (nil nil ((not tree) (not (symbolp tree)) t recursive-call recursive-call) nil nil nil nil) ((nil) nil (keywordify car cdr) nil (bomb-from) nil nil) ((Bug. ~p0 tree tree tree tree) nil (quote) nil nil nil nil) ((KEYWORDIFY-TREE) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::x-or-car-x (nil nil nil nil (if) nil nil) ((x) nil (atom car) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::x-or-cadr-x (nil nil nil nil (if) nil nil) ((x) nil (atom cadr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::designated-string (nil nil nil (cond) nil nil nil) (nil nil ((null string-designator) t) nil nil nil nil) (() nil (string) nil nil nil nil) ((string-designator) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::lambda-function-p (nil nil nil nil nil (and) nil) (nil nil (true-listp true-listp) (equal equal) nil nil nil) ((x) (3) (length first quote second) nil nil nil nil) ((x x ACL2::LAMBDA x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::free-vars (nil nil nil (free-vars1) nil nil nil) ((term) nil (quote) nil nil nil nil) ((nil) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::subst-expr-all (nil nil nil (cond) nil nil nil) (nil nil ((atom old-list) t) nil nil nil nil) ((term) nil nil nil (recursive-call) nil nil) (nil nil (cdr cdr) nil (subst-expr) nil nil) ((term new-list old-list) nil (car car) nil nil nil nil) ((new-list old-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::constructor-body (nil nil nil nil (if) nil nil) (nil nil (consp ` quote) nil nil nil nil) ((slot-names nil) nil nil nil (sp) nil nil) (nil nil (list , ,) nil nil nil nil) (nil nil (, car) (recursive-call) nil nil nil) ((slot-names) nil (car cdr cdr) nil nil nil nil) ((keyword-slot-names slot-names keyword-slot-names) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::template-cost (nil nil nil (cond) nil nil nil) (nil nil ((atom template) t) nil nil nil nil) (nil (0) nil nil (+) nil nil) (nil (1) (recursive-call recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((template template) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::constructor (nil nil nil (db-let) nil nil nil) (nil nil nil nil (cond) nil nil) ((acl2-count-lemma constructor-call slot-names representation tag doc template inline keyword-slot-names) nil ((eq representation :MV) inline t) nil nil nil nil) (nil nil nil (list list list) nil nil nil) ((
;  The constructor is defined as a macro that expands into an MV form for
;  every slot.
  
;  The constructor is defined as a macro that accepts every slot.
  
;  The constructor is defined as a function that accepts every slot.
 ) nil (` `) nil (if) nil nil) ((tag) nil (` `) nil nil (DEFMACRO DEFMACRO) nil) (nil nil (, , ,@ , , ,@) (CONS MLAMBDA) nil nil (DEFUN DEFUN))) (/coi/defstructure/defstructure.lisp::weak-predicate-body (nil nil nil (cond) nil nil nil) (nil nil ((atom template) t) nil nil nil nil) (nil nil (cond) nil (append) nil nil) (nil nil ((null template) list) (recursive-call recursive-call) nil nil nil) (nil nil (list ` car ` cdr `) nil nil nil nil) ((template template) nil (` CONSP CAR CDR) nil nil nil nil) (nil nil (NULL , , ,) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::weak-predicate-body-aux (nil nil nil nil (if) nil nil) (nil nil (consp ` quote) nil nil nil nil) ((keyword-slot-names nil) nil nil (cons) nil nil nil) (nil nil (list ,) nil nil nil nil) (nil nil (, recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((keyword-slot-names keyword-slot-names) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::weak-predicate-body (nil nil (`) nil nil nil nil) (nil nil nil (and) nil nil nil) (nil nil (wfr) (equal) nil nil nil) ((nil) nil (,) (path::clrp-list) nil nil nil) ((structure-name) nil (, ,) nil nil nil nil) ((structure-name) nil (weak-predicate-body-aux) nil nil nil nil) ((keyword-slot-names) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::reader-body (nil nil (`) nil nil nil nil) (nil nil nil (gp) nil nil nil) (nil nil (list ,) nil nil nil nil) ((tree) nil (,) nil nil nil nil) (nil nil (keywordify) nil nil nil nil) ((slot) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::weak-predicate (nil nil nil (db-let) nil nil nil) (nil nil nil (let*) nil nil nil) ((weak-predicate-constructor-lemma constructor-call name template tag inline keyword-slot-names) nil ((wp-body (weak-predicate-body keyword-slot-names name))) nil (list*) nil nil) ((
;  This predicate defines the `structure' of the structure, and is used as a
;  weak guard on the readers and writers (if defined).
 ) nil (body `) nil (if) nil nil) ((inline nil) nil nil (list) nil (cond DEFUN) nil) (((, name) 
;  The weak-predicate is satisfied by any explicit reference of the
;  constructor.  We also store this information as a :BUILT-IN-CLAUSE
 ) nil ((null template) (atom template) tag t , ,@ , `) nil nil nil nil) ((recursive-call wp-body) nil (list list list) (list) (guard-declaration) (DEFTHM) nil)) (/coi/defstructure/defstructure.lisp::predicate-body (nil nil nil (db-let) nil nil nil) (nil nil (`) nil (weak-predicate) nil nil) ((weak-predicate-call slot-names assertions) nil nil nil (AND) nil nil) ((T) nil (, ,@) nil nil nil nil) ((weak-predicate-call) nil (remove-duplicates-equal) nil nil nil nil) (nil nil nil (append) nil nil nil) (nil nil (map-access-assertion-subst-assertion) (slot-subst-assertions) nil nil nil)) (/coi/defstructure/defstructure.lisp::predicate-assertions-explicit (nil nil nil (db-let) nil nil nil) (nil nil nil (let) (slot-names) nil nil) ((assertions weak-predicate constructor-call (assertions (remove-duplicates-equal (append (slot-assertions slot-names db) (map-access-assertion-assertion assertions))))) nil nil (cond) nil nil nil) (nil nil (assertions t) nil nil nil nil) (nil nil (` quote) nil nil nil nil) ((T) nil nil (AND) nil nil nil) ((T) nil (,@) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::predicate (nil nil nil (db-let) nil nil nil) (nil nil nil nil (list*) nil nil) ((name predicate-call weak-predicate weak-predicate-call constructor-call predicate-weak-predicate-lemma predicate-constructor-lemma inline 
;  This is the predicate, which contains the weak predicate and every
;  assertion made about the slots of the structure.  The final T guarantees
;  that all DEFSTRUCTURE predicates are Boolean.
 ) nil (`) nil (if) nil nil) ((inline nil) nil nil nil nil (DEFUN list) nil) (((, name) 
;  This lemma shows that the predicate includes the weak predicate, as
;  :REWRITE, :FORWARD-CHAINING, and :BUILT-IN-CLAUSE rules.  Note that the
;  :REWRITE rule is sometimes implicated in thrashing in conjunction with the
;  normalization lemmas.
  
;  This lemma rewrites the predicate on an explicit reference of
;  the constructor.
 ) nil (, ,@ , ` `) nil nil nil nil) ((recursive-call) nil (predicate-body) (DEFTHM) (guard-declaration) (DEFTHM) nil) ((T nil db db :RULE-CLASSES) nil (, ,) (IMPLIES :FORWARD-CHAINING EQUAL) nil nil nil)) (/coi/defstructure/defstructure.lisp::keyword-constructor (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) (name) nil) ((recursive-call slot-names keyword-slot-names required-slot-names recursive-call nil) nil nil (list) nil nil nil) ((
;  This is the keyword constructor macro.  It will expand into a call of the
;  constructor, with appropriate defaulting.
 ) nil (`) nil nil nil nil) (nil nil nil nil (DEFMACRO) nil nil) (nil nil (,) nil (&WHOLE) nil nil) ((recursive-call FORM &REST ARGS FORM ARGS) nil (quote quote quote quote quote) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::writer-body (nil nil nil (cond) nil nil nil) (nil nil ((atom template) t) nil nil nil nil) (nil nil (cond) (let) nil nil nil) (nil nil ((eq slot template) (car-side (writer-body slot (car template) var (` (CAR (, tree)))))) (cond) nil nil nil) ((var) nil (cdr-side car-side cdr-side) nil nil nil nil) (nil nil (` `) nil nil (recursive-call) nil) ((slot var) nil (cdr `) (CONS CONS) nil nil nil)) (/coi/defstructure/defstructure.lisp::writer-macro-fn (nil nil nil nil (if) nil nil) ((bind) nil (`) nil nil (writer-body) nil) ((slot template value name) nil nil (LET) nil nil nil) ((((, *binding-variable*) (CHECK-VARS-NOT-FREE ((, *binding-variable*)) (, name)))) nil (,) nil nil nil nil) (nil nil nil nil nil (writer-body) nil) ((slot template value *binding-variable*) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::writers (nil nil nil (db-let) nil nil nil) (nil nil nil (slot-names) (if) nil nil) ((keyword-slot-names read-only read-only nil) nil nil (cons) nil nil nil) ((
;  These are the `writers' for the structure.
 ) nil nil nil (writer-definitions) nil nil) ((slot-names keyword-slot-names db) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::slot-cost (nil nil nil (cond) nil nil nil) (nil nil ((atom template) t) nil nil nil nil) (nil nil nil (cond or) nil nil nil) (nil nil ((eq slot template) t) nil (recursive-call recursive-call) nil nil) ((accum nil slot slot) nil (car 1+ cdr 1+) nil nil nil nil) ((template accum template accum) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::set-cost (nil nil nil (cond) nil nil nil) (nil nil ((atom slots) t) nil nil nil nil) (nil (0) nil (+) nil nil nil) (nil nil nil (recursive-call) (slot-cost) nil nil) ((template template) (0) (car cdr) nil nil nil nil) ((slots slots) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::set-heuristic (nil nil nil (let*) nil nil nil) (nil nil ((keyword-template (keywordify-tree template))) (<=) nil nil nil) ((set-cost) nil (set-cost template-cost) nil nil nil nil) ((keyword-template) nil nil (set-cost) nil nil nil) ((keyword-set-slots keyword-template) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::set-update (nil nil nil (cond) nil nil nil) (nil nil ((atom args) t) nil nil nil nil) ((struct) nil (`) nil nil nil nil) (nil nil nil ((, (cdr (assoc (car args) keyword-writer-map)))) nil nil nil) (nil nil (, ,) nil nil nil nil) (nil nil (cadr) nil (recursive-call) nil nil) ((args keyword-writer-map struct) nil (cddr) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::copy-update (nil nil nil nil (if) nil nil) (nil nil (` `) (or) nil nil nil) (nil nil (atom (, name)) (all-slots-assigned-p LET) nil nil nil) ((struct keyword-slot-names args ((, *binding-variable*) (, struct))) nil (,@ (, name)) nil nil nil nil) (nil nil (,@) nil nil nil (copy-update-fn)) ((keyword-slot-names args keyword-reader-map struct nil) nil nil nil nil nil (copy-update-fn)) ((keyword-slot-names args keyword-reader-map *binding-variable* t) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::inline-update-fn (nil nil nil (cond) nil nil nil) (nil nil ((atom template) t) nil nil nil nil) (nil nil nil (cond) (mv-let) nil nil) (nil nil ((null template) t car-found) nil (mv-let) (recursive-call) nil) ((car-result args check) nil (car ` cdr-found) (mv let* cond) nil (recursive-call) nil) ((nil nil template cdr-result args check) nil (CAR cdr ` (not (or car-found cdr-found)) t) ((keyword-slot (keywordify template)) cond) nil nil nil) ((template) nil (found val found t , CDR) (mv mv) nil nil nil)) (/coi/defstructure/defstructure.lisp::inline-update (nil nil nil (let) nil nil nil) (((bind (and (not (atom struct)) (not (all-slots-assigned-p keyword-slot-names args))))) nil nil nil (mv-let) nil nil) (nil nil (found) (cond) nil (inline-update-fn) nil) ((form args template bind) nil (bind t) nil (if) nil nil) ((bind *binding-variable* struct form) nil (`) nil nil nil nil) (nil nil nil (LET) nil nil nil) ((((, *binding-variable*) (, struct))) nil (,) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::keyword-updater (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) nil (recursive-call)) ((name keyword-slot-names slot-names update-method template recursive-call nil) nil nil (list) nil nil nil) ((
;  This is the macro that provides for updates of multiple slots of a
;  structure. 
 ) nil (`) nil nil nil nil) (nil nil nil nil (DEFMACRO) nil nil) (nil nil (,) nil nil (&WHOLE) nil) ((recursive-call FORM STRUCT &REST ARGS FORM STRUCT ARGS) nil (quote quote quote quote quote quote quote quote) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::read-lemma (nil nil nil (db-let) nil nil nil) (nil nil (slot-names) nil (if) nil nil) ((recursive-call recursive-call nil) nil nil (list) nil nil nil) ((
;  This lemma simplifies reads of an explicit constructor.
 ) nil (`) nil nil nil nil) (nil nil nil (DEFTHM) nil nil nil) (nil nil (, AND) nil nil nil nil) ((recursive-call) nil (,@) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::write-lemma (nil nil nil (db-let) nil nil nil) (nil nil (slot-names) nil (if) nil nil) ((recursive-call recursive-call nil) nil nil (list) nil nil nil) ((
;  This lemma simplifies writes of an explicit constructor.
 ) nil (`) nil nil nil nil) (nil nil nil (DEFTHM) nil nil nil) (nil nil (, AND) nil nil nil nil) ((recursive-call) nil (,@) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::lift-if-syntaxp (nil nil nil nil nil nil (and)) (nil nil (consp consp symbolp) (or or) nil nil nil) ((left right constructor) nil nil (eq eq eq eq) nil nil nil) ((constructor constructor) nil (car quote car car quote car) nil nil nil nil) ((left IF left right IF right) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::lift-if-lemma-fn (nil nil nil (append) nil nil nil) (nil nil nil nil nil nil (lift-if-readers lift-if-writers)) ((slots test left right db slots test left right db) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::lift-if-lemma (nil nil nil (db-let) nil nil nil) (nil nil nil (let) (name) nil nil) ((recursive-call representation slot-names) nil nil ((test (pack-intern name name -TEST))) (if) nil nil) ((recursive-call nil) nil (left right) (list) nil nil nil) ((
;  This lemma lifts IF through calls of the slot accessors.
 ) nil (`) nil (pack-intern pack-intern) nil nil) ((name name -LEFT name name -RIGHT) nil nil (DEFTHM) nil nil nil) (nil nil (, AND) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::elimination-lemma (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) (recursive-call) nil) ((slot-names name force weak-predicate-call nil) nil (and) (list) nil nil nil) ((recursive-call 
;  This is the :ELIM lemma for the constructor.
 ) nil (`) nil nil nil nil) (nil nil nil nil nil (DEFTHM) nil) ((:RULE-CLASSES) nil (, :REWRITE) (IMPLIES) nil nil nil) ((recursive-call :ELIM) nil (,) (EQUAL) nil nil nil)) (/coi/defstructure/defstructure.lisp::normalization-lemma (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) nil (name)) ((constructor-call recursive-call slot-names force weak-predicate-call recursive-call nil) nil nil (list) nil nil nil) ((
;  This lemma normalizes symbolic writes by transforming the symbolic
;  structure into an explicit reference of the constructor.  The first
;  conjunct is a lemma that will normalize equality tests for this structure
;  when one of the objects is an explicit reference of the constructor.
 ) nil (`) nil nil nil nil) (nil nil nil (DEFTHM) nil nil nil) (nil nil (,) (IMPLIES) nil nil nil) ((recursive-call) nil (,) (AND) nil nil nil)) (/coi/defstructure/defstructure.lisp::all-bound-slots (nil nil nil (append) nil nil nil) (nil nil (map-access-assertion-bound-slots) (all-bound-slots-fn) nil nil nil) ((slot-names db) nil (db) nil nil nil nil) ((:ASSERTIONS) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::simple-slot-p (nil nil nil (db-let) nil nil nil) (nil nil ((slot assertions)) (and) nil nil nil) ((slot-names) nil (not) (equal) nil nil nil) (nil nil (remove-duplicates-equal list) (member) nil nil nil) ((slot) nil (map-access-assertion-bound-slots list flatten) nil nil nil nil) ((assertions slot) nil nil (all-bound-slots) nil nil nil) ((db) nil nil (remove) nil nil nil)) (/coi/defstructure/defstructure.lisp::slot-writers-lemmas (nil nil nil (db-let) nil nil nil) (nil nil nil (append) nil nil (weak-predicate-slot-writers-lemma)) ((weak-predicate-call weak-predicate predicate-slot-writers-lemma predicate slot-names) nil nil nil (if if) nil nil) ((weak-predicate-slot-writers-lemma nil predicate-slot-writers-lemma nil) nil nil (list list) nil nil nil) ((
;  This lemma backchains the weak predicate through the slot writers.
   
;  This lemma proves the predicate on a slot writer call.  For simple slots
;  whose assertions (if any) only mention the slot itself one need only prove
;  the assertion about the new slot.  For more complex slot assertions, or if
;  the structure as a whole has an assertion, it is necessary to normalize
;  the slot writer call to an explicit instance of the constructor.
  ) nil (` `) nil nil nil nil) (nil nil nil (DEFTHM DEFTHM) nil nil nil) (nil nil (, , AND) (IMPLIES) nil nil nil)) (/coi/defstructure/defstructure.lisp::read-write-lemma (nil nil nil (db-let) nil nil nil) (nil nil nil nil (recursive-call if) nil nil) ((slot-names force weak-predicate-call recursive-call nil) nil nil (list) nil nil nil) ((
;  This lemma normalizes symbolic reads of symbolic writes by `pushing'
;  reads though nested writes until either 1) a symbolic write of the read
;  slot is detected, or 2) something unrecognized is found.
 ) nil (`) nil nil nil nil) (nil nil nil (DEFTHM) nil nil nil) (nil nil (, AND) nil nil nil nil) ((recursive-call) nil (,@) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::write-write-lemma (nil nil nil (db-let) nil nil nil) (nil nil nil (recursive-call) (if) nil nil) ((template tag recursive-call nil) nil nil (let) nil nil nil) (((template (reverse (flatten (if tag (cdr template) template))))) nil nil (list) nil nil nil) ((
;  This lemma normalizes multiple nested writes of a structure by pushing
;  writes for `deep' slots through writes to `shallow' slots, and reducing
;  redundant writes to the same slot to a single write. 
  ) nil (`) nil nil nil nil) (nil nil nil (DEFTHM) nil nil nil) (nil nil (, AND) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::all-rule-classes (nil nil nil (db-let) nil nil nil) (nil nil (assertions) (append) nil nil nil) ((slot-names) nil (map-assertions-for-rule-classes) (map-slot-assertions-for-rule-classes) nil nil nil) ((slot-names db assertions) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::naked-proofs (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) nil nil) ((predicate predicate-call predicate-guard-hints assertion-lemma-hints guards verify-guards nil) nil nil (or) (append) nil nil) ((assertion-lemma) nil (list) (and and) (and) nil nil) ((guards verify-guards guards verify-guards assertion-lemma) nil (`) (list list) nil nil nil) ((
;  The guard verification for the predicate is performed here since it may
;  need the current environment.  If it does not prove then you may need some
;  hints.  Any :PREDICATE-GUARD-HINTS option to DEFSTRUCTURE will be attached
;  to this lemma.
  
;  This lemma captures all assertions about the structure.  This lemma is not
;  guaranteed to prove.  If it does not prove than you may have to provide
;  some :HINTS.  Any :ASSERTION-LEMMA-HINTS option to DEFSTRUCTURE will be
;  attached to this lemma.  Be sure that you have not specified
;  unsatisfiable assertions. 
 ) nil (LOCAL ` `) nil nil nil nil) (nil nil (IN-THEORY) (VERIFY-GUARDS) nil nil (DEFTHM))) (/coi/defstructure/defstructure.lisp::mv-intro-macro-case-body (nil nil nil (cond) nil nil nil) (nil nil ((atom readers) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil (`) nil (recursive-call) nil nil) ((form) nil ((, n) cdr 1+) nil nil nil nil) ((readers n) nil ((, (car readers))) nil nil nil nil) (nil nil (,) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::mv-intro-macro-fn (nil nil nil (let*) nil nil nil) (nil nil (`) ((event-name (if event-name event-name (pack-intern (car form) name -MV-INTRO- (car form))))) nil nil nil) (nil nil (n mv-nth-form) nil nil (DEFTHM) nil) ((:HINTS (Goal :IN-THEORY (quote (ZP OPEN-MV-NTH (,@ readers))) :EXPAND (HIDE (, mv-nth-form)))) nil (car ` ,) (EQUAL) nil nil nil) ((event-name) nil (,) (MV-NTH) (unique-symbols CASE) nil nil) ((mv-nth-form) (1) (quote flatten , , , ,@ T) nil nil nil nil) ((MV-INTRO-MACRO-N form n form n) nil (HIDE) nil (MV-intro-macro-case-body) nil nil)) (/coi/defstructure/defstructure.lisp::mv-intro-macro (nil nil nil (db-let) nil nil nil) (nil nil nil (name) (if) nil nil) ((slot-names recursive-call recursive-call nil) nil nil (list) nil nil nil) ((
;  This macro generates a lemma that will rewrite MV-NTH applied to any form
;  as a call of the appropriate reader for this MV structure.
) nil (`) nil nil nil nil) (nil nil nil nil nil (DEFMACRO) nil) (nil nil (, DECLARE) (FORM) nil (MV-INTRO-MACRO-FN) nil) ((recursive-call &KEY EVENT-NAME FORM EVENT-NAME) nil (quote quote) (XARGS) nil nil nil)) (/coi/defstructure/defstructure.lisp::r/w-type-prescriptions (nil nil nil (db-let) nil nil nil) ((slot-names) nil (r/w-type-prescriptions-fn) nil nil nil nil) (nil nil nil (append) nil nil nil) (nil nil nil nil (map-if-slots-db map-if-slots-db) nil nil) ((slot-names :READER db slot-names :WRITER db) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::definition-theory (nil nil nil (db-let) nil nil nil) (nil nil nil nil (if) nil nil) ((weak-predicate predicate recursive-call slot-names representation mix inline inline nil) nil nil nil (list) nil nil) ((
;  This theory consists of all :DEFINITION runes associated with the
;  constructor, predicates, and slot readers/writers.  Only the
;  :TYPE-PRESCRIPTIONS and :EXECUTABLE-COUNTERPARTS remain ENABLEd.
 ) nil (` `) nil nil nil nil) (nil nil (IN-THEORY) (DEFTHEORY) nil nil nil) (nil nil (, quote DISABLE) nil nil nil nil) ((recursive-call) nil (,) nil nil ((,@ (if (eq representation :MV) nil (list name)))) nil)) (/coi/defstructure/defstructure.lisp::lemma-theory (nil nil nil (db-let) nil nil nil) (nil nil (recursive-call) nil (if) nil nil) ((inline inline nil) nil nil (list) nil nil nil) ((
;  This theory lists every lemma generated by this DEFSTRUCTURE.  These are
;  normally to remain ENABLEd.
 ) nil (`) nil nil nil nil) (nil nil nil (DEFTHEORY) nil nil nil) (nil nil (, quote) nil nil nil nil) ((recursive-call (,@ (lemma-theory-names *lemma-names* db))) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::check-assertion (nil nil nil (db-let) nil nil nil) ((slot-names) nil nil (cond) nil nil nil) (nil nil ((not (assertion-termp assertion)) t) nil nil nil nil) (nil nil nil (let*) (bomb) nil nil) ((Assertions are required to satisfy STRUCTURES::ASSERTION-TERMP, ~
             and ~p0 does not because ~@1. assertion) nil (reason-for-not-assertion-termp (bound-slots (free-vars assertion))) nil (if) nil nil) ((assertion err) nil (err) nil nil nil (bomb)) ((The putative assertion ~p0 in the context ~p1 is not ~
                   a valid assertion because the free variable list of the ~
                   assertion (as defined by STRUCTURES::FREE-VARS), ~p2, ~
                   ~@3  If you feel that this message is incorrect, ~
                   then restate your assertion as a LAMBDA function ~
                   and try again. assertion context bound-slots err ASSERTION :assertion assertion :bound-slots bound-slots :subst-assertion :slot slot :rules NIL) nil nil (cond) (subst-expr-all) nil nil)) (/coi/defstructure/defstructure.lisp::get-string-designator (nil nil (designated-string) nil nil nil nil) (nil nil nil nil nil nil nil) ((key options :STRING-DESIGNATOR default default) nil (quote) nil nil nil nil) ((DEFSTRUCTURE) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::get-symbol (nil nil nil nil nil nil nil) ((key options :SYMBOL default default) nil (quote) nil nil nil nil) ((DEFSTRUCTURE) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::get-representation (nil nil nil (let) nil nil nil) (nil nil ((opt (get-option-entry :REPRESENTATION options))) (cond) nil nil nil) (nil nil (default opt t) nil nil nil nil) ((:LIST default) nil nil (cond) nil nil nil) (nil nil ((consp opt) t) nil nil nil nil) ((default) nil nil (cond) nil nil nil) (nil nil ((null (cdr opt)) t) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::harvest-field-names (nil nil nil nil (if) nil nil) ((nil) nil (consp) (let) nil nil nil) ((form (line (car form))) nil nil nil (if) nil nil) (nil nil (consp) nil (if if) nil nil) ((line nil) nil (symbolp) (equal cons cons) (recursive-call) nil nil) ((:options line name base) nil (car cdr) nil (join-symbols recursive-call join-symbols recursive-call) nil nil) ((line name base name base name base line name base form) nil (car cdr cdr) nil nil nil nil)) (/coi/defstructure/defstructure.lisp::accessor-predicate (nil nil nil (let*) nil nil nil) (nil nil nil (let) nil ((doc (if (stringp (car doc-and-slots)) (car doc-and-slots) nil))) nil) (((string (structures::get-string-designator :CONC-NAME options (concatenate (quote STRING) (structures::string name) -)))) nil (slots-and-options last-car options? options) (intern-in-package-of-symbol) nil nil nil) ((string name) nil (car) (and) (if if) nil nil) ((doc doc-and-slots options? nil) nil (cdr last consp cdr) (eq) nil nil nil) ((doc-and-slots slots-and-options last-car :OPTIONS last-car) nil (car) nil nil nil nil) ((last-car) nil nil nil nil nil nil)) (/coi/defstructure/defstructure.lisp::add-assertion-types (nil nil nil nil (if) nil nil) ((rst) nil (consp) (let) nil nil nil) ((rst (entry (car rst))) nil nil nil (if) nil nil) (nil nil nil (let cons) (and) nil nil) (((assertion (cadr entry)) entry) nil (consp consp null recursive-call) (let) nil nil nil) ((entry (assertion (if (and (consp assertion) (equal (car assertion) :assert) (consp (cdr assertion)) (null (cddr assertion))) (` (:assert (, (cadr assertion)) :rewrite :forward-chaining)) assertion))) nil (cdr cddr cdr) (let) nil nil nil) ((entry entry (entry (` ((, (car entry)) (, assertion)))) rst) nil nil (cons) nil nil nil)))
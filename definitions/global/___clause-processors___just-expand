((/clause-processors/just-expand.lisp::just-expand-cp-hint-get-rule (nil nil nil nil (if) nil nil) (nil nil (not) (b* b*) nil nil nil) ((rule) nil ((def (def-body fn w))) ((lemmas (getprop fn (quote lemmas) nil (quote current-acl2-world) w))) (list list) nil nil) (nil nil (lemma) ((unless (and def (not (access def-body def :hyp)))) cons (unless (and lemma (not (access rewrite-rule lemma :hyps)) (eq (access rewrite-rule lemma :equiv) (quote equal))))) (access access access access access) nil nil) ((nil fn def-body def :concl def-body def :rune nil rewrite-rule lemma :lhs rewrite-rule lemma :rhs rewrite-rule lemma :rune) nil nil nil (access if er) (er) nil) ((hard? couldn't find a hyp-free definition for ~x0 fn def-body def :formals hard? the definition has hyps or is not EQUAL-based) nil (quote symbolp quote) (find-runed-lemma) (find-named-lemma) nil nil) ((just-expand-cp rule lemmas t rule lemmas just-expand-cp) nil nil (deref-macro-name) nil nil nil)) (/clause-processors/just-expand.lisp::just-expand-cp-finish-hint (nil nil nil (b*) nil nil nil) (nil nil nil (cons) nil nil (((when (atom term)) (er hard? (quote just-expand-cp) atom in term position in hints: ~x0~% term)))) ((trans-term) nil ((mv erp trans-term) (when erp) (list lhs rhs rune) trans-term-vars nonfree-vars `) nil nil nil nil) (nil nil (simple-term-vars) (set-difference-eq) (just-expand-cp-hint-get-rule (lhs , lhs)) (er) nil) ((term t nil nil w hard? translate failed: ~@0~% trans-term rule w trans-term trans-term-vars vars) nil (quote default-state-vars quote car) (rhs rune subst) nil nil nil) ((just-expand-cp nil just-expand-cp trans-term , rhs , rune ,) nil nil (pairlis$) nil nil nil) ((nonfree-vars nonfree-vars) nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::just-expand-cp-parse-hint (nil nil nil nil nil nil nil) ((hint) nil (((quote :with) rule ((quote :free) vars term)) ((quote :free) vars ((quote :with) rule term)) ((quote :free) vars term) ((quote :with) rule term) &) nil nil nil nil) (nil nil nil nil nil (just-expand-cp-finish-hint just-expand-cp-finish-hint just-expand-cp-finish-hint just-expand-cp-finish-hint just-expand-cp-finish-hint) nil) ((rule vars term w rule vars term w nil vars term w rule nil term w nil nil hint w) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::just-expand-cp-parse-hints (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((hints) nil nil (just-expand-cp-parse-hint recursive-call) nil nil nil) ((w w) nil (car cdr) nil nil nil nil) ((hints hints) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::hint-alist-okp (nil nil nil nil nil (and) nil) (nil nil (alistp pseudo-termp pseudo-termp alistp) nil nil nil nil) ((alist) nil (cdr cdr cdr) nil nil nil nil) (nil nil nil (assoc assoc assoc) nil nil nil) ((alist alist alist) nil (quote quote quote) nil nil nil nil) ((lhs rhs subst) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::hints-okp (nil nil nil (or) nil nil nil) (nil nil (atom) nil nil (and) nil) ((hints) nil (consp pseudo-termp hint-alist-okp recursive-call) nil nil nil nil) (nil nil (car caar cdar cdr) nil nil nil nil) ((hints hints hints hints) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::apply-expansion (nil nil nil (b*) nil nil nil) (nil nil nil (substitute-into-term) nil nil nil) ((rhs subst) nil ((mv pat-ok &) (unless pat-ok) lhs (mv lhs-ok subst) (unless lhs-ok) rhs) nil nil nil nil) ((term term) nil (cdr cdr) nil (simple-one-way-unify simple-one-way-unify) nil nil) ((pattern term subst lhs term nil) nil nil (assoc assoc) nil nil nil) ((alist alist) nil (quote quote) nil nil nil nil) ((lhs rhs) nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::expev-alist (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((x) nil nil (cons recursive-call) nil nil nil) ((a) nil (caar cdr) (expev) nil nil nil) ((x a x) nil (cdar) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::hint-alists-to-clauses (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((hints) nil (hint-alist-to-clause recursive-call) nil nil nil nil) (nil nil (cdar cdr) nil nil nil nil) ((hints hints) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::apply-expansions (nil nil nil nil (if) nil nil) ((term) nil (atom) (recursive-call) nil nil nil) ((hints) nil (cdr) nil (apply-expansion) nil nil) ((term hints) nil (caar cdar) nil nil nil nil) ((hints hints) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/clause-processors/just-expand.lisp::just-expand-cp (nil nil nil (b*) nil nil nil) (nil nil nil (((unless (hints-okp hints)) (er hard? (quote just-expand-cp) bad hints) (list clause)) cons) nil nil nil) ((expanded-clause hint-clauses) nil (hint-clauses expanded-clause) nil nil nil nil) (nil nil (hint-alists-to-clauses) (termlist-apply-expansions) nil nil nil) ((hints clause hints) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/coi/osets/sets.lisp::list-to-set (nil nil nil (cond) nil nil nil) (nil nil ((consp list) t) nil nil nil nil) ((nil) nil nil (insert) nil nil nil) (nil nil (car recursive-call) nil nil nil nil) ((list) nil (cdr) nil nil nil nil) ((list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::in (nil nil nil (and) nil nil nil) (nil nil (not) (or) nil nil nil) (nil nil (empty) (equal recursive-call) nil nil nil) ((X a a) nil (head tail) nil nil nil nil) ((X X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::subset (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (fast-subset) (if) nil nil) ((t X Y) nil (empty) (and) nil nil nil) ((X) nil nil (in recursive-call) nil nil nil) ((Y Y) nil (head tail) nil nil nil nil) ((X X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::delete (nil nil nil nil (cond) nil nil) (nil nil ((empty X) (equal a (head X)) t) nil nil nil nil) ((nil) nil (tail) (insert) nil nil nil) ((X) nil (head) (recursive-call) nil nil nil) ((X a) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::union (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (fast-union) (if) nil nil) ((X Y) nil (empty sfix) (insert) nil nil nil) ((X Y) nil (head) (recursive-call) nil nil nil) ((X Y) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::intersect (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (fast-intersect) (cond) nil nil) ((X Y) nil ((empty X) (in (head X) Y) t) nil nil nil nil) (nil nil (sfix) (insert recursive-call) nil nil nil) ((X Y) nil (head tail) (recursive-call) nil nil nil) ((X Y X) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil)) (/coi/osets/sets.lisp::difference (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil nil (fast-difference) (cond) nil nil) ((X Y) nil ((empty X) (in (head X) Y) t) nil nil nil nil) (nil nil (sfix) (recursive-call insert) nil nil nil) ((X Y) nil (tail head) (recursive-call) nil nil nil) ((X X Y) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil)) (/coi/osets/sets.lisp::cardinality (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil (len) nil (if) nil nil) ((X) (0) (empty 1+) nil nil nil nil) ((X) nil (recursive-call) nil nil nil nil) (nil nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::in-list (nil nil nil nil (if) nil nil) ((nil) nil (endp) (or) nil nil nil) ((x) nil nil (equal recursive-call) nil nil nil) ((a a) nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::mergesort-exec (nil nil nil nil (cond) nil nil) (nil nil ((endp x) (endp (cdr x)) t) nil nil nil nil) ((nil) nil nil (insert) (mv-let) nil nil) ((nil) nil (car part1 split-list) (union) nil nil nil) ((x part2 x) nil (recursive-call recursive-call) nil nil nil nil) ((part1 part2) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::mergesort (nil nil nil nil nil (mbe) nil) ((:logic :exec) nil (mergesort-exec) nil (if) nil nil) ((nil x) nil (endp) (insert) nil nil nil) ((x) nil (car recursive-call) nil nil nil nil) ((x) nil (cdr) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::all (nil nil nil nil (if) nil nil) ((t) nil (empty) (and) nil nil nil) ((set-for-all-reduction) nil (predicate recursive-call) nil nil nil nil) (nil nil (head tail) nil nil nil nil) ((set-for-all-reduction set-for-all-reduction) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/coi/osets/sets.lisp::weak-insert-induction (nil nil nil nil nil (cond) nil) (nil nil ((empty X) (in a X) (equal (head (insert a X)) a) t) nil nil nil nil) ((nil nil nil) nil (list) nil nil nil nil) (nil nil nil (recursive-call) nil nil nil) ((a) nil (tail) nil nil nil nil) ((X) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/centaur/misc/universal-equiv.lisp::universal-equiv-equivterms (nil nil nil nil (if) nil nil) ((nil) nil (atom) (let*) nil nil nil) ((equivs) nil nil ((equivname (caar equivs)) cons) nil nil nil) (nil nil (term1 term2) nil (list recursive-call) nil nil) ((equivname term1 term2 var1 var2) nil (cadar cdr) (esc-substitute) nil nil nil) ((equivs term1 equivs) nil (list) nil nil nil nil) (nil nil nil (cons) nil nil nil)) (/centaur/misc/universal-equiv.lisp::universal-equiv-multi-qvar-bindings (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((qvars) nil (`) nil (recursive-call) nil nil) ((witnesscall) nil ((, (car qvars)) 1+ cdr) nil nil nil nil) ((n qvars) nil nil (mv-nth) nil nil nil) (nil nil (, ,) nil nil nil nil) ((n witnesscall) nil nil nil nil nil nil)) (/centaur/misc/universal-equiv.lisp::universal-equiv-qvar-bindings (nil nil nil (let) nil nil nil) (nil nil ((qvars (if (and (consp qvars) (not (consp (cdr qvars)))) (car qvars) qvars))) nil (if) nil nil) (nil nil (term atom list) nil (universal-equiv-multi-qvar-bindings) nil nil) ((qvars qvars term) (0) nil (list) (list) nil nil) ((witness var1 var2 qvars term) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/misc/universal-equiv.lisp::universal-equiv-form (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil nil ((equivterms (` (and , (universal-equiv-equivterms (quote x) (quote y) equivs)))))) (nil nil (witness equivname-necc equivname-refl equivname-symm equivname-trans) nil nil nil nil) ((nil) nil (, in-theory local local local defequiv) (intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol) nil nil nil) ((equivname equivname equivname equivname equivname) nil (,) (disable) (concatenate concatenate concatenate concatenate concatenate if) (defthm defthm defthm) nil) ((-WITNESS -NECC -REFL -SYMM -TRANS qvars :hints (goal :in-theory (enable (, equivname))) :hints (goal (,@ (if qvars (` (:use ((:instance (, equivname-necc) (,@ (universal-equiv-qvar-bindings witness (quote y) (quote x) qvars)))) :expand (((, equivname) y x)))) (` (:in-theory (enable (, equivname))))))) :hints (goal (,@ (if qvars (` (:use ((:instance (, equivname-necc) (,@ (universal-equiv-qvar-bindings witness (quote x) (quote z) qvars))) (:instance (, equivname-necc) (,@ (universal-equiv-qvar-bindings witness (quote x) (quote z) qvars)) (x y) (y z))) :expand (((, equivname) x z)))) (` (:in-theory (enable (, equivname))))))) equivname) nil (quote symbol-name quote symbol-name quote symbol-name quote symbol-name quote symbol-name ` ` ,@ , , , ,) ((, equivname) implies implies) nil nil nil) ((string equivname string equivname string equivname string equivname string equivname equivname equivname-refl x x equivname-symm equivname-trans) nil nil (and (, equivname) (, equivname) and (, equivname)) (defun) ((, (if defquant (quote defquant) (quote defun-sk)))) nil)))
((/misc/defun-plus.lisp::strip-dcls-program-mode1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (member-eq (caar lst) (quote (type ignore ignorable))) t) nil nil nil nil) ((nil) nil nil (cond let) nil nil nil) (((temp (strip-keyword-list fields (cdar lst)))) nil ((member-eq (caar lst) fields) t) (cond) nil nil nil) (nil nil ((null temp) t) (recursive-call cons) nil nil nil) ((fields) nil (cdr car) (recursive-call recursive-call cons) nil nil nil) ((lst lst fields fields) nil (cdr cdr) (cons recursive-call) nil nil nil)) (/misc/defun-plus.lisp::strip-dcls-program-mode (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (stringp (car lst)) t) nil nil nil nil) ((nil) nil nil (cond let) nil nil nil) (((temp (strip-dcls-program-mode1 fields (cdar lst)))) nil ((member-eq (quote comment) fields) t) (cond) nil nil nil) (nil nil ((null temp) t) (recursive-call cons) nil nil nil) ((fields) nil (cdr car) (recursive-call recursive-call cons) nil nil nil) ((lst lst fields fields) nil (cdr cdr) (cons recursive-call) nil nil nil)) (/misc/defun-plus.lisp::fetch-dcl-fields-program-mode2 (nil nil nil (cond) nil nil nil) (nil nil ((endp kwd-list) t) nil nil nil nil) ((acc) nil nil (let) nil nil nil) (((acc (fetch-dcl-fields-program-mode2 field-names (cddr kwd-list) acc))) nil nil nil (if) nil nil) ((acc) nil nil (member-eq cons) nil nil nil) ((field-names acc) nil (car cadr) nil nil nil nil) ((kwd-list kwd-list) nil nil nil nil nil nil)) (/misc/defun-plus.lisp::fetch-dcl-fields-program-mode1 (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (member-eq (caar lst) (quote (type ignore ignorable))) t) nil nil nil nil) ((nil) nil nil nil (if fetch-dcl-fields-program-mode2) nil nil) ((field-names) nil (cdar) (member-eq cons recursive-call recursive-call) nil nil nil) ((field-names field-names lst field-names) nil (caar cdar cdr cdr) (recursive-call) nil nil nil) ((lst lst field-names lst lst) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil)) (/misc/defun-plus.lisp::fetch-dcl-fields-program-mode (nil nil nil nil (cond) nil nil) (nil nil ((endp lst) (stringp (car lst)) t) nil nil nil nil) ((nil) nil nil (append) (if) nil nil) (nil nil nil (member-eq cons recursive-call fetch-dcl-fields-program-mode1 recursive-call) nil nil nil) ((field-names field-names field-names field-names) nil (quote car cdr cdar cdr) (recursive-call) nil nil nil) ((comment lst field-names lst lst lst) nil (cdr) nil nil nil nil) ((lst) nil nil nil nil nil nil)) (/misc/defun-plus.lisp::fetch-dcl-field-program-mode (nil nil nil (fetch-dcl-fields-program-mode) nil nil nil) ((lst) nil (list) nil nil nil nil) ((field-name) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/defun-plus.lisp::generate-output-lemma-name (nil nil nil nil (if) nil nil) (nil nil (not) (intern-in-package-of-symbol intern-in-package-of-symbol) nil nil nil) ((number name name) nil nil nil (concatenate) (concatenate) nil) ((-OUTPUT-LEMMA -OUTPUT-LEMMA-) nil (quote symbol-name quote symbol-name) (coerce) nil nil nil) ((string name string name) nil (quote) (explode-atom) nil nil nil) ((number string) (10) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/defun-plus.lisp::generate-output-lemma-single (nil nil (`) nil nil nil nil) (((defthm (, (generate-output-lemma-name name nil)) (implies (, guards) (, output)) :hints (, output-hints))) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/defun-plus.lisp::generate-output-lemma-multiple (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((output) nil (`) nil nil (recursive-call) nil) ((name guards) nil (cdr 1+) (defthm) nil nil nil) ((output number) nil (,) (implies) nil nil nil) (nil nil (, ,) (generate-output-lemma-name) nil nil nil) ((name number guards) nil (car) nil nil nil nil)) (/misc/defun-plus.lisp::generate-output-lemmas (nil nil nil nil (if) nil nil) (nil nil (not) nil nil (generate-output-lemma-single generate-output-lemma-multiple) nil) ((name guards output output-hints name guards) (1) (cdr) (equal) nil nil nil) ((output) nil (car quote) nil nil nil nil) ((output and) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/defun-plus.lisp::generate-lemmas (nil nil nil nil (case-match) nil nil) ((body) nil (((quote if) ((quote atom) x) tbr (and (fbr-car ((quote car) x)) (!name ((quote cdr) x)))) &) nil nil nil nil) ((nil) nil nil (list) nil nil nil) (nil nil (` `) nil nil nil nil) (nil nil nil (defthm defthm) nil nil nil) (nil nil (, ,) (implies implies) nil nil nil) (nil nil ((, fbr-car) (, name)) (and and) (generate-lemma-names generate-lemma-names) nil nil)) (/misc/defun-plus.lisp::barp (nil nil (integerp) nil nil nil nil) ((x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
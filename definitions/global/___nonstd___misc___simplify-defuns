((/nonstd/misc/simplify-defuns.lisp::simplify-term1 (nil nil nil (prog2$) nil nil nil) (nil nil (initialize-brr-stack) (let*) nil nil nil) ((state) nil nil (er-let*) ((ens (ens state))) nil nil) (((pair (find-applicable-hint-settings *initial-clause-id* current-clause nil saved-pspv ctx thints wrld nil state))) nil (saved-pspv new-lit current-clause) (let) nil nil nil) (nil nil ((hint-settings (car pair))) nil (fcons-term* add-literal mv-let) nil nil) ((ens wrld :displayed-goal term :user-supplied-term term :orig-hints thints term new-lit t) nil (quote dumb-negate-lit-lst thints hint-settings) (fcons-term* cond er-let*) nil nil nil) ((equal hyps state (pspv (load-hint-settings-into-pspv t hint-settings saved-pspv nil wrld ctx state))) nil (quote quote cdr (null hint-settings) t) (cond) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-term* (nil nil nil nil (if) nil nil) (nil nil (zp value) (er-let*) nil nil nil) ((remaining-iters (term-ttree (simplify-term1 ttree term hyps equiv thints prove-assumptions ctx wrld state))) nil nil nil (list* if) nil nil) ((term t ttree) nil (value) (equal) nil nil nil) ((term hyps equiv thints prove-assumptions ctx wrld state) nil (car 1- cdr car) nil (list*) nil nil) ((term-ttree term nil ttree remaining-iters term-ttree term-ttree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-term (nil nil nil (state-global-let*) nil nil nil) (((inhibit-output-lst (if inhibit-output (union-eq (quote (proof-tree prove)) (@ inhibit-output-lst)) (@ inhibit-output-lst)))) nil nil (let) nil nil nil) (((name-tree (quote simplify-term))) nil nil (er-let*) nil nil nil) (nil nil nil ((thints (translate-hints name-tree hints ctx wrld state))) nil nil nil) ((repeat-limit nil term hyps equiv thints prove-assumptions ctx wrld state) nil (thyps term) nil nil nil nil) (nil nil nil nil (if if) nil nil) ((translate-flg translate-flg) nil (value value) nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::strip-leading-percent-from-symbol-list (nil nil nil nil (if) nil nil) ((acc) nil (endp) (recursive-call) nil nil nil) ((sym-list) nil (cdr) (cons) nil nil nil) ((sym-list acc) nil (strip-leading-percent-from-symbol) nil nil nil nil) (nil nil (car) nil nil nil nil) ((sym-list) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::percentify (nil nil nil nil (concatenate) nil nil) ((% name) nil (quote) nil nil nil nil) ((string) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::sublis-fn! (nil nil nil nil (mv-let) nil nil) (nil nil (erp) (assert$) (sublis-fn) nil nil) ((new-term alist term nil new-term) nil (null) nil nil nil nil) ((erp) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::%f-is-f-lemmas-rev (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (f-name %%f-name %%f f-body-is-%f-body_s %%f-is-f f-is-%f new-theory recp formals %%f-formals %f-formals f-formals equal-bodies) ((local (deftheory (, new-theory) (union-theories (quote ((, f-is-%f))) (theory (quote (, old-theory))))))) nil nil nil) (nil nil (symbol-name percentify car ,@) (intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern-in-package-of-symbol intern cons cons cons and) nil (defthm) (getprop)) ((f %f-name %%f-name %f %f %f %f ACL2 %f nil wrld formals-decls %%f formals %f formals f formals :hints (, (if recp (` (Goal :by (:functional-instance (, %%f-is-f) ((, %%f) (, %f))) :do-not (quote (preprocess)) :expand ((, %f-formals)))) (` (Goal :expand ((:free (, formals) (, %f-formals)) (:free (, formals) (, f-formals))) :in-theory (theory (quote (, old-theory))) :do-not (quote (preprocess)) (,@ (and (not equal-bodies) (` (:use (, f-body-is-%f-body_s)))))))))) nil (quote quote not ,) (equal equal) (concatenate cond) (concatenate concatenate) (concatenate)) ((f-name -BODY-IS- %f-name -BODY_S %%f-name -IS- f-name f-name -IS- %f-name THEORY- recursivep current-acl2-world recp untranslated-new-body orig-body f-is-%f) nil (quote quote quote quote , , recp equal-bodies t) (coerce) nil nil nil) ((string string string string f-formals %f-formals nil) nil (quote ` `) (explode-atom) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::get-state-value (nil nil nil nil (if) nil nil) ((nil) nil nil (f-boundp-global f-get-global) nil nil nil) ((sym state sym state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-repeat-limit (nil nil nil (or) nil nil nil) (nil (3) nil (get-state-value) nil nil nil) ((state) nil (quote) nil nil nil nil) ((recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-inhibit (nil nil nil (let) nil nil nil) (((val (get-state-value (quote simplify-inhibit) state))) nil nil nil nil (case) nil) ((val) nil ((t) (nil) otherwise) nil nil nil nil) ((nil val) nil (quote) nil nil nil nil) (nil nil nil nil nil nil (prove)) ((proof-tree warning observation event summary) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::mut-rec-formals (nil nil nil nil (if) nil nil) ((formals) nil (endp) (let*) nil nil nil) ((defs) nil nil ((def (car defs)) and) nil nil nil) ((formals-okp) nil (new-formals formals-okp) (recursive-call) nil nil nil) ((new-formals) nil (cdr) (and) (if) nil nil) ((formals defs) nil (true-listp caddr) (equal) (and) nil nil) ((def def formals new-formals new-formals) nil (consp null) nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::f-is-%f-list (nil nil nil nil (if) nil nil) ((acc) nil (endp) nil (recursive-call) nil nil) ((defs formals) nil (cdr) (let*) nil nil nil) ((defs) nil ((%f (cadar defs))) nil (if) nil nil) ((acc) nil (f) (eq cons) nil nil nil) ((%f f acc) nil (strip-leading-percent-from-symbol `) nil nil nil nil) ((%f) nil nil (equal) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::f-is-%f-induction-step-lemmas (nil nil nil nil (if) nil nil) ((acc) nil (endp) nil nil (recursive-call) nil) ((f-is-%f-list formals hyp) nil (cdr) (cons) nil nil nil) ((f-is-%f-list acc) nil nil (let*) nil nil nil) (nil nil (`) nil nil nil ((equality (car f-is-%f-list)))) (nil nil (f %f lemma-name f-formals %f-formals local) nil nil nil nil) (nil nil (car car) (intern cons cons) nil (defthm) nil)) (/nonstd/misc/simplify-defuns.lisp::f-is-%f-lemmas-mut-rec (nil nil nil nil (if) nil nil) ((acc) nil (endp) nil (recursive-call) nil nil) ((f-is-%f-list formals) nil (cdr) (cons) nil nil nil) ((f-is-%f-list acc) nil nil (let*) nil nil nil) (nil nil (`) nil ((equality (car f-is-%f-list))) nil nil) (nil nil (f %f lemma-name) nil nil (defthm) nil) ((:hints (Goal :do-not (quote (preprocess)))) nil (car car ,) (intern equal) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::mutual-recursion-lemmas (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (%%p %%p-formals %%p-property %%p-base %%p-induction-step not-zp-formal formal %%p-formal-minus-1 induction-hyp %%p-holds %%p-implies-f-is-%f-theory new-theory) nil nil nil nil) (nil nil (` car ` ` local local local local local local) (intern cons intern intern intern intern intern intern) (encapsulate) nil nil) ((%%p-name ACL2 %%p formals ACL2 ACL2 ACL2 formals ACL2 ACL2 ACL2 nil) nil (not (, %%p) local ,@) (and deftheory) (concatenate concatenate concatenate concatenate concatenate concatenate) (defthm encapsulate defthm defun) (encapsulate)) ((%%p-name -PROPERTY %%p-name -BASE %%p-name -INDUCTION_STEP %%p-name -HOLDS %%p-name -IMPLIES-F-IS-%F-THEORY THEORY- :hints (Goal :induct (%%sub1-induction (,@ formals)) :do-not (quote (preprocess)) :in-theory (union-theories (quote ((, %%p-base) (, %%p-induction-step) (:induction %%sub1-induction))) (theory (quote minimal-theory)))) nil nil :HINTS (Goal :in-theory (union-theories (quote ((, %%p))) (theory (quote minimal-theory))))) nil (quote quote quote zp 1- , , quote quote quote in-theory , , local local ,@ local ,@ , , , , declare %%and-tree) (coerce union-theories implies) (f-is-%f-lemmas-mut-rec) (defthm defthm) nil) ((string string string not-zp-formal %%p-formal-minus-1 string string string f-is-%f-list formals nil %%p-holds %%p-formals :instructions :instructions %%p-implies-f-is-%f-theory %%p-property %%p formals) nil (,@ , quote in-theory deflabel , in-theory , theory (, %%p) %%and-tree ,@) (explode-atom union-theories implies :promote implies :promote set-difference-theories xargs) nil (f-is-%f-induction-step-lemmas f-is-%f-base-lemmas) nil)) (/nonstd/misc/simplify-defuns.lisp::my-translate-rule-class1 (nil nil nil (let) nil nil nil) (((orig-corollary (cadr (assoc-keyword :corollary (cdr class))))) nil nil (er-let*) nil nil nil) (nil nil ((corollary (cond (orig-corollary (translate orig-corollary t t t ctx wrld state)) (t (value nil)))) value) nil nil nil nil) (nil nil (alist) (cons) nil nil nil) ((alist) nil (car) nil nil nil nil) ((nil name ctx wrld state class) nil (car cdr) (and) nil nil nil) ((class class corollary) nil nil nil (untranslate) nil nil)) (/nonstd/misc/simplify-defuns.lisp::my-translate-rule-class (nil nil nil (cond) nil nil nil) (nil nil ((symbolp x) t) nil nil nil nil) (nil nil (value) nil nil nil (my-translate-rule-class1)) ((x name x ctx wrld state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::my-translate-rule-classes1 (nil nil nil (cond) nil nil nil) (nil nil ((atom classes) t) nil nil nil nil) (nil nil (value) (er-let*) nil nil nil) ((nil) nil ((class (my-translate-rule-class name (car classes) ctx wrld state)) value) nil nil nil nil) (nil nil (rst) (cons) nil nil nil) ((class rst) nil nil nil nil nil (recursive-call)) ((name ctx wrld state) nil (cdr) nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::my-translate-rule-classes (nil nil nil (cond) nil nil nil) (nil nil ((atom classes) t) nil nil nil nil) (nil nil (value) nil nil nil (my-translate-rule-classes1)) ((classes name classes ctx wrld state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::strip-percents-from-lemma (nil nil nil nil (case-match) nil nil) ((lemma) nil ((defthm name formula . other) &) nil nil nil nil) (nil nil (value) (cond) nil nil nil) ((nil) nil ((member-eq defthm (quote (defthm defthmd))) t) nil nil nil nil) (nil nil (value) (let) nil nil nil) (((new-name (strip-leading-percent-from-symbol name)) nil) nil nil nil (if) nil nil) (nil nil (value) (eq let) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::strip-percents-from-lemmas (nil nil nil nil (if) nil nil) (nil nil (endp value) (er-let*) nil nil nil) ((lemmas (new-lemma (strip-percents-from-lemma (car lemmas) ctx wrld state))) nil (reverse) nil nil nil (recursive-call)) ((acc ctx wrld state) nil (cdr) nil (if) nil nil) ((lemmas new-lemma acc) nil nil (cons) nil nil nil) ((new-lemma acc) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-defuns (nil nil nil (cond) nil nil nil) (nil nil ((endp defs) t) nil nil nil nil) (nil nil nil (let) (mv-let) nil nil) (((formals (mut-rec-formals all-defs nil))) nil nil nil (if if) nil (erp)) ((formals def new-lemmas counter new-theory state lemmas counter old-theory ens wrld state erp) nil (quote car) (let*) nil (mv-let) nil) ((mut-rec defs t nil nil counter new-theory state all-defs new-lemmas counter new-theory ens wrld state) nil ((new-lemmas (mutual-recursion-lemmas formals (f-is-%f-list all-defs formals nil) counter old-theory)) declare cdr) (erp) (if) (er) nil) ((nil state val state soft Did not find a unique singleton list of formals for the ~
                     mutual-recursion nest starting with:~%~x0. t nil nil counter old-theory state defs def acc) nil (new-deftheory 1+ cadr quote car) (cons append ignore cons) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-form (nil nil nil (let) nil nil nil) (((car-form (and (consp form) (car form)))) nil nil nil nil nil (case)) ((car-form) nil ((defun defund) mutual-recursion defuns otherwise) nil nil nil nil) (nil nil nil nil nil (mv-let) nil) ((nil form lemmas counter old-theory ens wrld state nil lemmas counter old-theory ens wrld state nil nil lemmas counter old-theory state) nil (cdr cdr declare) (erp) (er) nil nil) ((form form val state soft Simplify-form does not yet handle DEFUNS, but it ~
                           could. t nil nil counter old-theory state) nil (quote) (ignore) nil nil nil) ((recursive-call erp val) nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::simplify-forms (nil nil nil (cond) nil nil nil) (nil nil ((endp forms) t) nil nil nil nil) (nil nil nil (pprogn) (mv-let) nil nil) (nil nil nil (newline) (cond) (mv) (erp)) ((*standard-co* state nil state simp-form lemmas new-counter new-theory state lemmas counter old-theory ens wrld state) nil (reverse car erp simp-form t) nil (case-match) nil nil) ((defs lemmas forms) nil ((((quote local) ((quote deftheory) . &)) . &) &) nil nil (mv) nil) ((lemmas t nil nil state lemmas new-counter new-theory ens wrld state defs lemmas new-counter new-theory ens wrld state) nil (cdr cdr cdr) (cons) nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::final-deftheory-1 (nil nil nil nil nil (cond) nil) (nil nil ((endp lemmas) (eq (caar lemmas) (quote defthm)) (eq (caar lemmas) (quote encapsulate)) t) nil nil nil nil) ((acc) nil nil (recursive-call recursive-call recursive-call) nil nil nil) ((acc) nil (cdr cdr cdr) (cons recursive-call) nil nil nil) ((lemmas acc lemmas acc lemmas) nil (cadar cddar) nil nil nil nil) ((lemmas lemmas) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::final-deftheory (nil nil (`) nil nil nil nil) (nil nil nil (deftheory) nil nil nil) ((%-removal-theory) nil nil (union-theories) nil nil nil) (nil nil (quote theory) nil nil nil nil) (nil nil (, quote) nil nil nil nil) ((minimal-theory) nil nil (final-deftheory-1) nil nil nil) ((lemmas nil) nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::initial-equality-events (nil nil nil nil nil (list) nil) (nil nil (car quote quote quote) nil nil nil nil) ((in-defs) nil (local local local) nil nil nil nil) (nil nil nil nil (defun defmacro) (defun) nil) ((%%sub1-induction n %%and-tree-fn %%and-tree) nil (args declare &rest) (%%and-tree-fn) (if if) nil nil) ((n len args args) nil (zp %%sub1-induction length) (xargs < cons let*) nil nil nil) ((n :mode :program len args (len2 (floor len 2)) args) (20) (1- quote) nil (list) nil nil)) (/nonstd/misc/simplify-defuns.lisp::write-lemma-file (nil nil nil (er-let*) nil nil nil) (nil nil ((in-lemmas (read-list infile ctx state))) nil nil (write-list) nil) ((outfile ctx state) nil (out-lemmas) (cons) nil nil nil) (nil nil (car) (append) nil nil (strip-percents-from-lemmas)) ((in-lemmas nil ctx state in-lemmas initial-events out-lemmas) nil (w) nil nil nil nil) ((state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::write-lemma-files (nil nil nil nil (if) nil nil) (nil nil (endp) nil (mv) (mv-let) nil) ((thm-file-pairs erp nil state) nil (declare) (erp) nil (recursive-call) (write-lemma-file)) ((val state ctx state erp ctx state) nil (caar cadar cddar ignore cdr) nil nil nil nil) ((thm-file-pairs thm-file-pairs thm-file-pairs val thm-file-pairs) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/misc/simplify-defuns.lisp::transform-defuns-fn (nil nil nil (let) nil nil nil) (nil nil ((ctx (quote transform-defuns))) nil (mv-let) nil nil) (nil nil (first-lemma) (erp) (read-list if) nil nil) ((in-defs state in-defs-file ctx state erp) nil (quote silent-error) nil (mv-let) nil nil) ((state) nil (local) nil (erp if if) nil nil) ((out-defs lemmas state erp) nil (silent-error) (deftheory or) (er-progn) (mv) nil) ((theory-0 out-defs-file equalities-file in-defs nil state nil nil nil state state) (0) (theory list quote ens w) nil (if if) (write-lemma-files) nil)))
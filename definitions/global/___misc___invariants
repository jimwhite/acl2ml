((/misc/invariants.lisp::get-clique-members (nil nil nil (or) nil nil nil) (nil nil nil nil (er) nil (getprop)) ((fn nil world hard Expected ~s0 to be in a mutually-recursive nest.~%) nil (quote quote quote) nil nil nil nil) ((recursivep current-acl2-world recursive-call) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::get-formals (nil nil nil nil nil nil (getprop)) ((fn nil world) nil (quote quote) nil nil nil nil) ((formals current-acl2-world) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::get-body (nil nil nil nil (access) nil nil) ((def-body :concl) nil (car) nil nil nil nil) (nil nil (last) nil nil nil nil) (nil nil nil nil nil nil (getprop)) ((fn nil world) nil (quote quote) nil nil nil nil) ((def-bodies current-acl2-world) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::inv-build-lemma-from-context (nil nil nil nil nil (cond) nil) (nil nil ((atom context) (eq (caar context) :hyp) (eq (caar context) :lambda) t) nil nil nil nil) (nil nil (`) (let) (recursive-call) (er) nil) ((concl hard Malformed context element: ~x0~%) nil (cdr (formals (cadar context)) quote car) (implies cons) (recursive-call) nil nil) ((hyps context nil recursive-call context) nil (, cadar actuals ` cdr) (and) nil nil nil) ((, hyps concl context context) nil (caddar) ((lambda (, formals) (declare (ignorable , formals)) (implies (and , hyps) (, concl)))) nil nil nil) ((context , actuals) nil nil nil nil nil nil)) (/misc/invariants.lisp::inv-clause-to-theorem (nil nil (`) nil nil nil nil) (nil nil nil (implies) nil nil nil) (nil nil (,) (and) nil nil nil) ((,) nil (dumb-negate-lit-lst car) nil nil nil nil) (nil nil (last) (butlast) nil nil nil) ((clause clause) (1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::inv-clauses-to-theorems (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((clauses) nil (inv-clause-to-theorem recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((clauses clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::inv-to-theorems (nil nil nil (er-let*) nil nil nil) (((clauses (simplify-with-prover term hints (quote inv-to-theorems) state))) nil (value) nil nil nil nil) (nil nil (inv-clauses-to-theorems) nil nil nil nil) ((clauses) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::calls-make-concls (nil nil nil nil (if) nil nil) ((nil) nil (atom) (let*) nil nil nil) ((calls) nil nil (cons) ((fn (caar calls))) nil nil) (nil nil (args formals inv `) nil (recursive-call) nil nil) ((fn-alist state) nil (cdar cdr cdr) (get-formals (lambda (, formals) (, inv))) nil nil nil) ((calls , args calls) nil (caar w) (assoc-eq) nil nil nil) ((calls state fn fn-alist) nil nil nil nil nil nil)) (/misc/invariants.lisp::gather-invariant-reqs-from-induction (nil nil nil nil (if) nil nil) (nil nil (atom value) (er-let*) nil nil nil) ((induction nil (reqs (gather-invariant-reqs-from-induction (cdr induction) fn-alist req hints state))) nil nil (let*) nil nil nil) (nil nil nil (er-let*) ((tests (cons req (access tests-and-calls (car induction) :tests)))) nil nil) (((lemmas (inv-to-theorems lemma-raw (or hints (quote ((goal :in-theory (theory (quote minimal-theory)))))) state))) nil (calls concls lemma-raw value) nil nil nil nil) (nil nil (`) (append) (access calls-make-concls) nil nil) ((tests-and-calls :calls calls fn-alist state lemmas reqs) nil (car) (implies) nil nil nil)) (/misc/invariants.lisp::clique-invariant-alist (nil nil nil nil (if) nil nil) ((nil) nil (atom) (let) nil nil nil) ((clique (guard (getprop (car clique) (quote guard) t (quote current-acl2-world) world))) nil nil (cons) nil nil nil) (nil nil nil (cons recursive-call) nil nil nil) ((guard world) nil (car cdr) nil nil nil nil) ((clique clique) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::name-and-number-lemmas (nil nil nil nil (if) nil nil) (nil nil (atom) (mv let) nil nil nil) ((lemmas nil nil (name (intern-in-package-of-symbol (concatenate (quote string) (symbol-name fn) -INVARIANT- (coerce (explode-atom n 10) (quote string))) fn))) nil nil nil (mv-let) nil nil) (nil nil (rest-names) (mv) nil (recursive-call) nil) ((rest-thms fn other-args) nil (cdr 1+) (cons cons) nil nil nil) ((lemmas n name rest-names rest-thms) nil (`) nil nil nil nil) (nil nil nil nil nil (defthm) nil)) (/misc/invariants.lisp::get-induction (nil nil nil nil nil nil (getprop)) ((fn nil world) nil (quote quote) nil nil nil nil) ((induction-machine current-acl2-world) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::gather-invariant-lemmas (nil nil nil nil (if) nil nil) (nil nil (atom) (er-let*) (mv) nil nil) ((alist nil nil state (lemmas (if use-induction (gather-invariant-reqs-from-induction (get-induction (caar alist) (w state)) full-alist (cdar alist) simpl-hints state) (gather-invariant-reqs (get-body (caar alist) (w state)) (list (` (:hyp (, (cdar alist))))) full-alist simpl-hints state nil)))) nil nil nil (mv-let) nil nil) (nil nil nil (rest-names) (mv-let) nil nil) ((rest-thms state full-alist simpl-hints use-induction other-args state) nil (cdr names) nil (mv) (name-and-number-lemmas) nil) ((alist thms lemmas other-args state) (0) (caar) (append append) nil nil nil) ((alist names rest-names thms rest-thms) nil nil nil nil nil nil)) (/misc/invariants.lisp::remove-these-keywords (nil nil nil nil (if) nil nil) ((args) nil nil (or) (if) nil nil) (nil nil (atom atom) (member-eq recursive-call) (list*) nil nil) ((args keys keys) nil (cdr car cddr car cadr) (recursive-call) nil nil nil) ((args args args args args keys) nil (cddr) nil nil nil nil) ((args) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::remove-numbered-entries (nil nil nil nil (if) nil nil) ((nil) nil (atom) nil (if) nil nil) ((lst) nil nil (member cons) (recursive-call) nil nil) ((n nums nums) nil (cdr 1+ car) nil (recursive-call) nil nil) ((lst n lst nums) nil (cdr 1+) nil nil nil nil) ((lst n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/misc/invariants.lisp::prove-invariants-fn (nil nil nil (let*) nil nil nil) (nil nil nil nil (mv-let) nil nil) (nil nil (fns simplify-hints omit use-induction other-args alist theory-name) (names let) nil nil nil) ((lemmas state alist alist simplify-hints use-induction other-args state) nil (cadr cadr cadr (names (remove-numbered-entries omit names 0)) value) (get-clique-members remove-these-keywords or intern-in-package-of-symbol) nil nil nil) ((clique-member world args alist clique-member) nil (quote lemmas `) (assoc-keyword assoc-keyword assoc-keyword clique-invariant-alist) (concatenate) nil nil) ((:simplify-hints args :omit args :use-induction args fns world -INVARIANTS) nil (quote symbol-name) (:simplify-hints) (remove-numbered-entries encapsulate) nil nil) ((:omit :use-induction string clique-member omit lemmas nil) (0) (,@) (deftheory) nil nil nil)))
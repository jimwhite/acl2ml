((/nonstd/workshops/1999/calculus/book/proof-outline.lisp::deps-aux (nil nil nil nil (if) nil nil) ((acc) nil (endp) nil nil (recursive-call) nil) ((deps filename all-deps) nil (cdr) nil (if) nil nil) ((deps acc) nil nil (and cons) nil nil nil) (nil nil (not cdar) (equal) nil (recursive-call) nil) ((filename deps all-deps all-deps acc) nil (caar cdar) (member-equal) nil nil nil) ((deps acc deps) nil (cdar) nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::last-form-in-file-aux (nil nil nil nil (mv-let) nil nil) (nil nil nil (eofp read-object) (if) nil nil) ((obj2 state channel state eofp) nil nil (mv) (recursive-call) nil nil) ((obj state obj2 channel state) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::last-form-in-file (nil nil nil nil (mv-let) nil nil) (nil nil (channel) nil (open-input-channel if) nil nil) ((state :object state channel) nil nil (string-append) (mv-let) (er) nil) ((fname .lisp soft Unable to open file ~s0 for :object input.) nil (result quote) (let string-append) (last-form-in-file-aux) nil nil) ((state nil channel state (state (close-input-channel channel state)) top-level fname .lisp) nil (value) nil nil nil nil) ((result) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::last-atomic-event-in-form (nil nil nil nil (cond) nil nil) (nil nil ((or (atom form) (atom (cdr form))) (eq (car form) (quote encapsulate)) (member (car form) (quote (defthm defthm-std)))) nil nil nil nil) ((nil form) nil (recursive-call) nil nil nil nil) (nil nil (car) nil nil nil nil) (nil nil (last) nil nil nil nil) ((form) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::last-atomic-event-in-file (nil nil nil (er-let*) nil nil nil) (((last-form (last-form-in-file filename state))) nil nil (let) nil nil nil) (((form (last-atomic-event-in-form last-form))) nil (value) nil nil nil nil) (nil nil nil nil (and) nil nil) ((form) nil nil (string-equal) (if) nil nil) ((filename form) nil (symbol-name caddr) (member) nil nil nil) ((form) nil (cadr car quote) nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::proof-alist-aux (nil nil nil nil (if) nil nil) (nil nil (endp value) (let*) nil nil nil) ((files nil (file (car files))) nil nil (er-let*) nil nil nil) (nil nil ((theorem (last-atomic-event-in-file file state))) nil (if) nil nil) ((theorem) nil (alist value value) nil nil nil nil) ((alist) nil nil (recursive-call cons) nil nil nil) ((state alist) nil (cdr) (cons) nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::proof-alist (nil nil nil (proof-alist-aux) nil nil nil) ((state) nil nil (cons) nil nil nil) ((top-file) nil nil (deps) nil nil nil) ((top-file dep-tree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::get-lemmas (nil nil nil nil (cond) nil nil) (nil nil ((endp dep-tree) (equal (caar dep-tree) name) t) nil nil nil nil) ((nil) nil nil (cons recursive-call) nil nil nil) ((name) nil (cdar cdr) (recursive-call) nil nil nil) ((dep-tree name dep-tree) nil (cdr) nil nil nil nil) ((dep-tree) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::dec (nil nil nil (and) nil nil nil) ((n) nil (1-) nil nil nil nil) ((n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::valid-keys (nil nil nil nil (cond) nil nil) (nil nil ((endp keys) (assoc-equal (car keys) alist) t) nil nil nil nil) ((nil) nil nil (cons recursive-call) nil nil nil) ((alist) nil (car cdr) (recursive-call) nil nil nil) ((keys alist keys) nil (cdr) nil nil nil nil) ((keys) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::my-fms (nil nil nil nil nil (mv-let) nil) ((state) nil (col declare) nil nil nil nil) ((state str alist chan state nil) (0) (ignore) nil nil nil nil) ((col) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/nonstd/workshops/1999/calculus/book/proof-outline.lisp::display-proof-outline-all-aux (nil nil nil (er-let*) nil nil nil) (nil nil ((proof-alist (if proof-alist (value proof-alist) (proof-alist top-lemma dep-tree state)))) nil (if) nil nil) (nil nil (new-lemmas-alist) (int= pprogn) nil nil nil) ((filename top-lemma dep-tree new-lemmas-alist proof-alist state) nil (length length value 1+) (newline) nil nil nil) ((filename n top-lemma dep-tree proof-alist state lemmas-alist new-lemmas-alist *standard-co* state :invisible n) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
((/ihs/ihs-init.lisp::pairwise-list (nil nil nil (cond) nil nil nil) (nil nil ((endp x) t) nil nil nil nil) ((nil) nil nil (cons) nil nil nil) (nil nil nil (list recursive-call) nil nil nil) (nil nil (car car cdr cdr) nil nil nil nil) ((x y x y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::let*$fn (nil nil nil (cond) nil nil nil) (nil nil ((endp bindings) t) nil nil nil nil) ((body) nil (`) nil nil nil nil) (nil nil nil (LET) nil nil nil) (((, (car bindings))) nil (,) nil nil nil nil) (nil nil nil (recursive-call) nil nil nil) ((body) nil (cdr) nil nil nil nil)) (/ihs/ihs-init.lisp::constant-syntaxp (nil nil nil (and) nil nil nil) (nil nil (consp) (eq) nil nil nil) ((x) nil (car quote) nil nil nil nil) ((x QUOTE) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::mlambda-fn (nil nil nil (cond) nil nil nil) (nil nil ((atom form) t) nil nil nil nil) (nil nil nil (cond) (list) nil nil) (nil nil ((member form args) t quote) (recursive-call recursive-call) nil nil nil) ((form CONS args args) nil (car cdr) (list) nil nil nil) ((form form form) nil (quote) nil nil nil nil) ((QUOTE) nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::e/d-fn (nil nil nil nil nil (cond) nil) (nil nil ((atom e/d-list) (not (listp (car e/d-list))) enable-p t) nil nil nil nil) ((theory) nil nil nil (recursive-call recursive-call) (er) nil) ((hard The arguments to the E/D macro must all be lists.
         This ==> ~p0, is not a list. nil t) nil (quote car ` cdr ` cdr) nil nil nil nil) ((e/d e/d-list e/d-list e/d-list) nil nil (UNION-THEORIES SET-DIFFERENCE-THEORIES) nil nil nil) (nil nil (, quote , quote) nil nil nil nil) ((theory theory) nil (, ,) nil nil nil nil)) (/ihs/ihs-init.lisp::rewrite-theory (nil nil nil nil (cond) nil nil) (nil nil ((endp theory) (and (consp (car theory)) (equal (caar theory) :rewrite)) t) nil nil nil nil) ((nil) nil (recursive-call) (cons) nil nil nil) (nil nil (car recursive-call cdr) nil nil nil nil) ((theory theory) nil (cdr) nil nil nil nil) ((theory) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::rewrite-free-theory (nil nil nil (set-difference-equal) nil nil nil) ((theory) nil (rewrite-theory) nil nil nil nil) ((theory) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::definition-theory (nil nil nil nil (cond) nil nil) (nil nil ((endp theory) (and (consp (car theory)) (equal (caar theory) :definition)) t) nil nil nil nil) ((nil) nil (recursive-call) (cons) nil nil nil) (nil nil (car recursive-call cdr) nil nil nil nil) ((theory theory) nil (cdr) nil nil nil nil) ((theory) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::definition-free-theory (nil nil nil (set-difference-equal) nil nil nil) ((theory) nil (definition-theory) nil nil nil nil) ((theory) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/ihs/ihs-init.lisp::defun-theory-fn (nil nil nil (cond) nil nil nil) (nil nil ((endp names) t) nil nil nil nil) (nil nil nil (cond let*) nil nil nil) (nil nil ((or quiet (null missing)) t) (cond) nil nil ((name (car names)))) ((nil) nil (defrune execrune inductrune typerune tail (not tail) t) nil nil (er) nil) ((hard The following names you supplied to ~
                          DEFUN-THEORY do not have a :DEFINITION ~
                          in the theory you ~
                          supplied.  Check to make sure that the theory is ~
                          correct (it defaults to (UNIVERSAL-THEORY :HERE)) ~
                          and that these are not the names of macros. ~
                          To avoid this message specify :QUIET T in the ~
                          call to DEFUN-THEORY. ~
                          Missing names: ~p0 missing) nil (quote ` ` ` `) (member-equal cons) nil (recursive-call) nil) ((DEFUN-THEORY defrune theory theory quiet defrune) nil (:DEFINITION :EXECUTABLE-COUNTERPART :INDUCTION :TYPE-PRESCRIPTION cdr) (cons) nil (append) nil)) (/ihs/ihs-init.lisp::defun-type/exec-theory-fn (nil nil nil (cond) nil nil nil) (nil nil ((endp names) t) nil nil nil nil) (nil nil nil (cond let*) nil nil nil) (nil nil ((or quiet (null missing)) t) (cond) nil ((name (car names))) nil) ((nil) nil (execrune inductrune typerune thy (null thy) t) nil nil (er) nil) ((hard The following names you supplied to ~
                       DEFUN-TYPE/EXEC-THEORY do not have an ~
                      :INDUCTION, ~
                      :EXECUTABLE-COUNTERPART, or any ~
                      :TYPE-PRESECRIPTIONs in the theory you ~
                      supplied.  Check to make sure that the theory is ~
                      correct (it defaults to (UNIVERSAL-THEORY :HERE)) ~
                      and that these are not the names of macros. ~
                      To avoid this message specify :QUIET T in the ~
                      call to DEFUN-TYPE/EXEC-THEORY. ~
                      Missing names: ~p0 missing) nil (quote ` ` `) (append) (append) (recursive-call) nil) ((DEFUN-TYPE/EXEC-THEORY theory quiet thy) nil (:EXECUTABLE-COUNTERPART :INDUCTION :TYPE-PRESCRIPTION cdr) (cons) (if if if) (recursive-call) nil)))
((/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::theta (nil nil nil nil (+) nil nil) (nil nil nil (bitn bitn *) nil nil nil) ((y y) (-2) (1-) (* bitn) nil nil nil) ((i y) (2) (1+) (*) nil nil nil) ((i) (2) nil (*) nil nil nil) ((i) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-theta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt theta) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::bmux4 (nil nil nil nil nil nil nil) ((zeta) nil (1 -1 2 -2 0) nil nil nil nil) ((x) (0) nil (*) (bits bits) nil nil) ((x) (0 2 0) (lognot 1- lognot 1-) nil nil nil nil) ((x n n) nil nil (*) nil nil nil) ((x) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::neg (nil nil nil nil (if) nil nil) (nil (1 0) nil (<) nil nil nil) ((x) (0) nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp4 (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn bitn *) (bmux4 bmux4) nil nil) ((x n x n) (0 0 2) (lognot zeta lognot zeta zeta 1-) nil nil nil nil) ((i i i) nil (neg neg 1-) nil nil nil nil) ((i) nil (zeta zeta) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-zeta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (*) nil nil nil) (nil nil (zeta 1-) (expt) nil nil nil) ((m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp4 (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil (pp4 recursive-call) nil nil) ((x n x n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp4-theta (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn bitn *) (bmux4 bmux4) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) (theta theta theta) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (theta theta) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp4-theta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp4-theta recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::m-mu-chi (nil nil nil (cond) nil nil nil) (nil nil ((equal mode (quote mu)) (equal mode (quote chi))) nil nil nil nil) (nil nil nil nil (if if) nil nil) (nil (1 0) (zp zp) (cons cons) nil nil nil) ((i i) (1 0) nil (cons cons) nil nil nil) ((i i) (1 1) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::phi (nil nil nil nil (if) nil nil) (nil (-1) nil (=) (bits) nil nil) (nil (3 1 0) nil (mu) (bits) nil nil) ((i y) (1 0) nil (mu) nil nil nil) ((i y) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-odd-powers-of-2 (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (expt) nil nil nil) (nil (2) (1- 1-) nil nil nil nil) ((m) nil nil (*) nil nil nil) ((m) (2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-phi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt phi) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp4-phi (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn bitn *) (bmux4 bmux4) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) (phi phi phi) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (phi phi) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp4-phi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp4-phi recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::gamma (nil nil nil nil (if) nil nil) (nil nil (zp) (bitn logior) nil nil nil) ((i c) (0) nil (bitn bitn) nil nil nil) ((a b) nil nil (+ +) nil nil nil) (nil (-1 -1) nil (* *) nil nil nil) ((i i) (2 2) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::delta (nil nil nil nil (if) nil nil) (nil nil (zp) (bitn logand) nil nil nil) ((i d) (0) (lognot) (logior) nil nil nil) (nil nil nil (logand logior logxor) nil nil nil) (nil nil nil (bitn bitn logand logand bitn bitn) nil nil nil) ((a b a b) nil (1- 1-) (+ + bitn bitn) nil (gamma gamma) nil) ((a a b c b a b c) (-2 -2) (1- 1-) (* * + + * *) nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::psi (nil nil nil nil (if) nil nil) (nil (0) (not) nil nil nil (+)) (nil nil (natp) (*) (bits bits) (gamma) (delta)) ((i a b i a b c i a b c d) (-4) (1+ 1+) (* * +) nil nil nil) ((i i) (2 2) nil (* *) nil (gamma) (delta)) ((i i a b c a b c d) (2 2) (1+ 1+) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-psi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (*) nil nil (recursive-call)) ((a b c d) nil (1-) (expt) nil nil (psi)) ((a b c d m) (2) (1-) (*) nil nil nil) ((m) (2) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp4-psi (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (1 1 1 1 1 1 0 1 1 0) (neg) (bitn bitn *) (bmux4 bmux4) nil nil) ((x n x n) (0 0 2) (lognot lognot 1-) nil nil nil (psi psi psi)) ((i a b c d i a b c d a b c d i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil nil nil nil (psi psi)) ((i a b c d i a b c d) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp4-psi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil nil nil) ((x a b c d n x a b c d n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::eta (nil nil nil nil nil (+) nil) (nil nil nil (bitn bitn * *) nil nil nil) ((y y) (2 -4) (1-) (* bitn bitn) nil nil nil) ((i y y) (3) (1+) (* +) nil nil nil) ((i) (3 2) nil (* *) nil nil nil) ((i i) (3 3) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-eta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil (* recursive-call) nil nil nil) ((y) nil (1-) (expt eta) nil nil nil) ((y m) (2) (1-) (*) nil nil nil) ((m) (3) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::bmux8 (nil nil nil nil nil nil nil) ((zeta) nil (1 -1 2 -2 3 -3 4 -4 0) nil nil nil nil) ((x) (0) nil (* * *) (bits bits bits bits) nil nil) ((x x x) (0 2 0 3 0 4 0) (lognot 1- lognot 1- lognot 1- lognot 1-) nil nil nil nil) ((x n n n n) nil nil (* * *) nil nil nil) ((x x x) (2 3 4) nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp8 (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (3 2 1 3 2 1 0 2 1 0) (neg) (bitn bitn *) (bmux8 bmux8) nil nil) ((x n x n) (0 0 3) (lognot xi lognot xi xi 1-) nil nil nil nil) ((i i i) nil (neg neg 1-) nil nil nil nil) ((i) nil (xi xi) nil nil nil nil) ((i i) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-xi (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil (recursive-call) (*) nil nil nil) (nil nil (xi 1-) (expt) nil nil nil) ((m) (2) (1-) (*) nil nil nil) ((m) (3) (1-) nil nil nil nil) ((m) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp8 (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil (pp8 recursive-call) nil nil) ((x n x n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::pp8-eta (nil nil nil nil (if) nil nil) (nil nil (zerop) nil nil nil nil) ((i n n) (3 2 1 3 2 1 0 2 1 0) (neg) (bitn bitn *) (bmux8 bmux8) nil nil) ((x n x n) (0 0 3) (lognot lognot 1-) (eta eta eta) nil nil nil) ((i y i y y i) nil (neg neg 1-) nil nil nil nil) ((i) nil nil (eta eta) nil nil nil) ((i y i y) nil nil nil nil nil nil)) (/rtl/rel8/support/lib2.delta1/mult-proofs.lisp::sum-pp8-eta (nil nil nil nil (if) nil nil) (nil (0) (zp) (+) nil nil nil) ((m) nil nil nil nil (pp8-eta recursive-call) nil) ((x y n x y n) nil (1- 1-) nil nil nil nil) ((m m) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))
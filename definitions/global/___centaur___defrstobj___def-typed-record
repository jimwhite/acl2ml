((/centaur/defrstobj/def-typed-record.lisp::symbol-list-names (nil nil nil nil (if) nil nil) ((nil) nil (atom) (cons) nil nil nil) ((x) nil (symbol-name recursive-call) nil nil nil nil) (nil nil (car cdr) nil nil nil nil) ((x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/centaur/defrstobj/def-typed-record.lisp::def-typed-record-fn (nil nil nil (let*) nil nil nil) (nil nil (`) nil nil nil nil) (nil nil (tr-p1 tr-p to-tr tr-bad-part tr-get1 tr-set1 tr-get tr-set tr-badguy array-to-tr tr-to-array tr-delete-indices array-rec-pair-p fi-pairs booleanp-of-elem-p elem-p-of-default elem-fix-correct elem-list-p-when-atom elem-list-p-of-cons) nil nil nil nil) ((nil) nil (` set-verify-guards-eagerness set-tau-auto-mode local local deflabel in-theory) (mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym mksym set-inhibit-warnings defthmd defthmd defthmd) (defun defun defun defun defun defun table) (defthmd defthmd defun defun defun defun defun defun defun defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthm defthmd) nil) ((name name name name name name name name name name name name name tr-p tr-p tr-p tr-p tr-p non-rec subsume nil :rule-classes :type-prescription :rule-classes :built-in-clause x x x r :hints (Goal :use ((:functional-instance elem-p-of-tr-get , fi-pairs))) :hints (Goal :use ((:functional-instance tr-get-of-tr-set-same , fi-pairs))) :hints (Goal :use ((:functional-instance tr-get-of-tr-set-diff , fi-pairs))) :hints (Goal :use ((:functional-instance tr-set-of-tr-get-same , fi-pairs))) :rule-classes (:rewrite :loop-stopper ((b a))) :hints (Goal :use ((:functional-instance tr-set-of-tr-set-diff , fi-pairs))) :hints (Goal :use ((:functional-instance tr-set-of-tr-set-same , fi-pairs))) :hints (Goal :use ((:functional-instance tr-get-of-tr-set-strong , fi-pairs))) :hints (Goal :use ((:functional-instance tr-get-of-nil , fi-pairs))) :hints (Goal :use ((:functional-instance tr-bad-part-of-tr-set , fi-pairs))) :hints (Goal :use ((:functional-instance tr-badguy-finds-counterexample , fi-pairs))) :hints (Goal :use ((:functional-instance tr-badguy-unless-equal , fi-pairs))) :hints (Goal :use ((:functional-instance equal-of-tr-set , fi-pairs))) :hints (Goal :use ((:functional-instance elem-p-of-nth , fi-pairs))) :hints (Goal :use ((:functional-instance tr-get-of-array-to-tr , fi-pairs))) :hints (Goal :use ((:functional-instance len-of-tr-to-array , fi-pairs))) :hints (Goal :use ((:functional-instance elem-list-p-of-tr-to-array , fi-pairs))) :hints (Goal :use ((:functional-instance tr-to-array-idempotent , fi-pairs))) :hints (Goal :use ((:functional-instance tr-to-array-of-tr-set , fi-pairs))) :hints (Goal :use ((:functional-instance tr-to-array-of-array-to-tr , fi-pairs))) :hints (Goal :use ((:functional-instance tr-delete-indices-of-nil , fi-pairs))) :hints (Goal :use ((:functional-instance tr-delete-indices-idempotent , fi-pairs))) :hints (Goal :use ((:functional-instance tr-delete-indices-of-tr-set , fi-pairs))) :hints (Goal :use ((:functional-instance tr-delete-indices-of-array-to-tr , fi-pairs))) :hints (Goal :use ((:functional-instance array-to-tr-inverse , fi-pairs))) :hints (Goal :use ((:functional-instance equal-of-array-to-tr , fi-pairs))) typed-records) (2) (quote quote quote quote quote quote quote quote quote quote quote quote quote quote quote quote quote quote , booleanp , , , , , in-theory in-theory , , , , , k declare , declare , k , , x declare , declare , declare , n declare , declare , , , , , , , , , , , , , , , , , , , , , , , , , , , quote) (equal implies equal or k (, tr-get1) k let* tr-badguy1 n n arr equal implies equal implies equal equal equal equal implies implies implies implies equal equal implies implies implies implies equal equal implies equal equal implies list) (if if cond cond if if if and) (and) nil) ((-tr-p1 -tr-p -to-tr -tr-bad-part -tr-get1 -tr-set1 -tr-get -tr-set -tr-badguy -array-to-tr -tr-to-array -tr-delete-indices -array-rec-pair-p booleanp-of-elem-p-for- elem-p-of-default-for- elem-fix-correct-for- elem-list-p-when-atom-for- elem-list-p-of-cons-for- booleanp-of-elem-p elem-p-of-default elem-fix-correct elem-list-p-when-atom elem-list-p-of-cons tr-p1 tr-p to-tr x tr-bad-part r tr-get1 r tr-set1 v r tr-get r k tr-set v r tr-badguy y array-to-tr arr rec tr-to-array rec arr tr-delete-indices rec array-rec-pair-p rec len r nil rec) nil (elem-default elem-fix elem-list-p tr-p1 tr-p to-tr tr-bad-part tr-get1 tr-set1 tr-get tr-set tr-badguy array-to-tr tr-to-array tr-delete-indices array-rec-pair-p , , atom , theory null consp (, tr-p1) car not (, tr-p) (, tr-p) cdr (or (endp r) (<< k (caar r))) (equal k (caar r)) t (or (endp r) (<< k (caar r))) (equal k (caar r)) t car car car zp zp zp , , not not , (, tr-bad-part) (, tr-bad-part) not syntaxp , len , , , , , , , , , , , , , , ,) (equal and cons xargs xargs xargs xargs xargs xargs (, tr-delete-indices) xargs = equal mksym (, tr-get) equal equal (, tr-get) mksym (, tr-get) mksym (, tr-badguy) mksym and (, tr-badguy) mksym equal mksym and (, tr-get) mksym max mksym and mksym and equal equal equal mksym (, tr-delete-indices) mksym (, tr-delete-indices) (, tr-delete-indices) equal (, tr-delete-indices) (, tr-delete-indices) mksym mksym equal cons cons) (subst if (rec ((, to-tr) r)) if (, tr-set) (, array-to-tr) update-nth (, tr-to-array) (, tr-set) mksym subst (, tr-set) (, tr-set) (, tr-set) if mksym mksym if mksym mksym mksym and mksym (, array-to-tr)) (mksym mksym mksym mksym mksym mksym) (and and and)) ((elem-p elem-default elem-p elem-fix x x car-cons cdr-cons car-cdr-elim natp zp true-listp-update-nth posp len booleanp x x x x nil x r r :guard :guard new-rec1 bad :verify-guards nil :guard n rec arr :guard n arr rec :guard n rec :guard len rec tr-p tr-get elem-p tr-get tr-set a tr-get tr-set tr-set tr-get a r tr-set tr-set tr-set tr-set a y a y r tr-get tr-set a tr-get a nil elem-default tr-bad-part tr-set r tr-badguy x y tr-badguy x y tr-set name tr-get array-to-tr key tr-to-array tr-to-array tr-to-array tr-to-array tr-set tr-to-array array-to-tr arr1 tr-delete-indices n nil tr-delete-indices n n rec tr-delete-indices tr-set tr-delete-indices array-to-tr n n rec array-to-tr n array-to-tr tr-p :fi-pairs :theorems tr-p1 tr-p to-tr tr-bad-part tr-get1 tr-set1 tr-get tr-set tr-badguy array-to-tr tr-to-array tr-delete-indices array-rec-pair-p) (0 0 0) (, , , , , , , , , , , , , quote , , , not , , quote , , , , , consp consp (, tr-p1) , not car (, tr-p) (, tr-p1) , cdar (, tr-p1) (, to-tr) rec1 bad new-rec1 (, to-tr) (, to-tr) natp , posp len quote quote quote ` quote quote quote quote quote quote quote quote quote quote quote quote quote , quote quote quote quote not quote quote , quote , quote len quote , quote force force quote natp natp , , quote force force force force force quote quote quote natp natp quote quote quote natp quote) (lambda lambda lambda or (, tr-get1) cons cons and nth - and (, tr-get) - - (, tr-delete-indices) equal (, tr-get) (, tr-get) (, tr-get) equal equal (, tr-get) equal equal or equal and < and (, tr-get) + < <= (, tr-delete-indices) <= (, tr-delete-indices) (, tr-delete-indices) (, tr-delete-indices) equal equal equal and union-theories) (subst if if (, tr-set) update-nth (, tr-set) subst (, tr-set) subst (, tr-set) (, tr-set) (, tr-set) (, tr-set) (, tr-set) subst (, array-to-tr) (, tr-to-array) subst (, tr-to-array) (, tr-to-array) (, tr-to-array) update-nth (, tr-to-array) (, array-to-tr) (, tr-to-array) (, array-rec-pair-p) (, array-rec-pair-p)) nil nil)))
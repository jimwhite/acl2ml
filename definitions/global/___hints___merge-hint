((/hints/merge-hint.lisp::listify-untranslated-expand-hint (nil nil nil nil nil (cond) nil) (nil nil ((eq arg :lambdas) (and (consp arg) (symbolp (car arg)) (not (eq (car arg) :lambdas))) (and (consp arg) (consp (car arg)) (eq (caar arg) (quote lambda))) t) nil nil nil nil) ((arg) nil (list list list) nil nil nil nil) ((arg arg arg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/merge-hint.lisp::listify-untranslated-hands-off (nil nil nil nil (cond) nil nil) (nil nil ((and arg (symbolp arg)) (and (consp arg) (eq (car arg) (quote lambda))) t) nil nil nil nil) ((arg) nil (list list) nil nil nil nil) ((arg arg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/merge-hint.lisp::listify-untranslated-use (nil nil nil nil (cond) nil nil) (nil nil ((atom arg) (or (eq (car arg) :instance) (eq (car arg) :functional-instance) (eq (car arg) :theorem) (runep arg wrld)) t) nil nil nil nil) ((arg) nil (list list) nil nil nil nil) ((arg arg) nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/merge-hint.lisp::true-list-of-non-empty-true-listsp (nil nil nil (cond) nil nil nil) (nil nil ((atom x) t) nil nil nil nil) (nil nil nil (equal) (and) nil nil) ((x nil) nil (consp true-listp recursive-call) nil nil nil nil) (nil nil (car car cdr) nil nil nil nil) ((x x x) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/merge-hint.lisp::remove-assoc-equals (nil nil nil nil (cond) nil nil) (nil nil ((endp alist) (equal key (caar alist)) t) nil nil nil nil) ((nil) nil nil (recursive-call cons) nil nil nil) ((key) nil (cdr car) (recursive-call) nil nil nil) ((alist alist key) nil (cdr) nil nil nil nil) ((alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)) (/hints/merge-hint.lisp::merge-restrict-hints (nil nil nil nil (cond) nil nil) (nil nil ((endp alist1) (assoc-equal (car (car alist1)) alist2) t) nil nil nil nil) ((alist2) nil nil (cons cons) nil nil nil) (nil nil (car) (cons recursive-call recursive-call) nil nil nil) ((alist1 alist2) nil (car cdr) (union-equal remove-assoc-equals remove-assoc-equals) nil nil nil) ((alist2 alist1) nil (car cdr cdr car cdr car) nil nil nil nil) ((alist1 alist1) nil (car car car) (assoc-equal) nil nil nil)) (/hints/merge-hint.lisp::mergeable-theory-expressionp (nil nil nil nil (and) nil nil) (nil nil (consp true-listp) nil nil (cond) nil) ((arg) nil (cdr (eq (car arg) (quote enable)) (eq (car arg) (quote disable)) (eq (car arg) (quote e/d)) t) nil nil nil nil) ((arg t t nil) nil nil nil (and) nil nil) (nil nil (true-listp true-listp) (equal) nil nil nil) (nil (3) (len cadr caddr) nil nil nil nil) ((arg arg arg) nil nil nil nil nil nil)) (/hints/merge-hint.lisp::merge-mergeable-theory-expressions (nil nil nil nil nil (case) nil) (nil nil (car ENABLE DISABLE t) nil nil nil nil) ((val2) nil (` ` `) nil nil nil nil) (nil nil nil (union-theories set-difference-theories set-difference-theories) nil nil nil) (nil nil (, quote , quote quote) (union-theories) nil nil nil) ((val1 val1) nil (, , , quote ,) nil nil nil nil) ((val1) nil (cdr cdr , caddr) nil nil nil nil)) (/hints/merge-hint.lisp::merge-hint (nil nil nil nil (cond) nil nil) (nil nil ((endp keyword-alist) (eq (car keyword-alist) key) t) nil nil nil nil) (nil nil nil (list let) (list*) nil nil) ((key val2 (val1 (cadr keyword-alist))) nil (car cadr) nil nil (recursive-call) nil) ((key keyword-alist keyword-alist key val2 wrld) nil (:ERROR :NO-OP :EXPAND :RESTRICT :DO-NOT :DO-NOT-INDUCT :HANDS-OFF :USE :OR :BY :CASES :IN-THEORY :NONLINEARP :INDUCT :BDD otherwise cddr) nil nil nil nil) ((keyword-alist) nil nil (let cond cond) (list* list* list* list* list* list* list* list* list* list* list* list*) (cond) nil) ((:NO-OP T :EXPAND :RESTRICT :DO-NOT :DO-NOT-INDUCT :HANDS-OFF :USE :OR :BY :CASES :INDUCT :ERROR) nil ((str This hint produced several errors:~ ~*0~%) cddr cddr cddr ` cddr cddr cddr cddr cddr cddr cddr (mergeable-theory-expressionp val2) t (not (or (eq val1 t) (eq val1 nil))) (not (or (eq val2 t) (eq val2 nil))) (eq val1 val2) t cddr (equal val1 val2) t cddr) (cond union-equal union-equal let msg) (cond cond cond cond cond) nil nil)) (/hints/merge-hint.lisp::merge-hints (nil nil nil (cond) nil nil nil) (nil nil ((endp old-keyword-alist) t) nil nil nil nil) ((new-keyword-alist) nil nil nil (recursive-call) nil nil) ((wrld) nil (cddr) nil nil (merge-hint) nil) ((new-keyword-alist wrld old-keyword-alist) nil (car cadr) nil nil nil nil) ((old-keyword-alist old-keyword-alist) nil nil nil nil nil nil) (nil nil nil nil nil nil nil)))